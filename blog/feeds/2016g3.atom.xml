<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016g3.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-11-15T20:53:00+08:00</updated><entry><title>40323206日誌 - OpenCV (Dots)</title><link href="http://project.mde.tw/blog/40323206ri-zhi-opencv-dots.html" rel="alternate"></link><updated>2016-11-15T20:53:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2016-11-15:blog/40323206ri-zhi-opencv-dots.html</id><summary type="html">&lt;p&gt;物體角落(點)的辨識 --- cv2.cornerHarris &amp;amp; cv2.dilate&lt;/p&gt;


&lt;h3&gt;★cv2.cornerHarris的使用&amp;格式&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/zne7h7s.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/F05kwRB"&gt;http://imgur.com/F05kwRB&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import numpy as np

filename = 'chessboard.png'
img = cv2.imread(filename)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

gray = np.float32(gray)
dst = cv2.cornerHarris(gray,2,3,0.04)

#result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst&gt;0.01*dst.max()]=[0,0,255]

cv2.imshow('dst',img)
if cv2.waitKey(0) &amp; 0xff == 27:
    cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例執行(已灰階)前後之比較&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/chMPHbO.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★套用於齒輪辨識&lt;/h3&gt;

&lt;h4&gt;
有包含圓和圓心的辨識&amp;單獨作角落抓點
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
from matplotlib import pyplot as plt

img = cv2.imread("gear2.png", 1)
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
cv2.imwrite('graygear.png', imgGray)

# 抓點
gray = np.float32(imgGray)
dst = cv2.cornerHarris(gray,2,3,0.04)

# result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst&gt;0.01*dst.max()]=[0,0,255]

cv2.imshow('dst',img)

# 抓圓
circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,1,20,
                            param1=60,param2=50,minRadius=0,maxRadius=60)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # draw the outer circle
    cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2)
    # draw the center of the circle
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img)


cv2.waitKey(0)


cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;/br&gt;

&lt;h3&gt;★齒輪辨識目的&lt;/h3&gt;
&lt;h4&gt;配合之前的圓心可以初步抓出齒輪的外徑、內徑，方便之後直行計算相關程式的條件。&lt;/h4&gt;
&lt;/br&gt;

&lt;h3&gt;★齒輪辨識結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/116TeT4.jpg"&gt;
&lt;/br&gt;</summary><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323206日誌 - OpenCV (Circles)</title><link href="http://project.mde.tw/blog/40323206ri-zhi-opencv-circles.html" rel="alternate"></link><updated>2016-11-14T20:16:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2016-11-14:blog/40323206ri-zhi-opencv-circles.html</id><summary type="html">&lt;p&gt;圓形的辨識 --- cv2.HoughCircles&lt;/p&gt;


&lt;h3&gt;★cv2.HoughCircles的使用&amp;格式&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/sSe92Wx.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/EyLp3Qx"&gt;http://imgur.com/EyLp3Qx&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import numpy as np

img = cv2.imread('opencv_logo.png',0)
img = cv2.medianBlur(img,5)
cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)

circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,
                            1,20,
                            param1=50,
                            param2=40, 
                            minRadius=0,
                            maxRadius=0)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # draw the outer circle
    cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),3)
    # draw the center of the circle
    cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',cimg)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例執行前後之比較&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/fSWa1OC.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★套用於齒輪辨識&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
from matplotlib import pyplot as plt

# 讀取圖檔
img = cv2.imread("gear1.png", 1)
# 圖檔轉灰階
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 灰階後進行存檔
cv2.imwrite('graygear.png', imgGray)

# 使用灰階圖抓圓
circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,
                            1,20,
                            param1=60,
                            param2=50,
                            minRadius=0,
                            maxRadius=60)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # 圓形的繪製
    cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2)
    # 圓心的繪製
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img)

cv2.waitKey(0)
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★齒輪辨識目的&lt;/h3&gt;

&lt;h4&gt;找出齒輪的圓心位置，方便之後直行計算相關程式的條件。&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★齒輪辨識結果&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/1gvQ3vH.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323214日誌-Opencv範例</title><link href="http://project.mde.tw/blog/40323214ri-zhi-opencvfan-li.html" rel="alternate"></link><updated>2016-08-04T15:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2016-08-04:blog/40323214ri-zhi-opencvfan-li.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.Windows執行範例程式&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;1.範例程式&lt;/h4&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import sys

cascPath = "haarcascade_frontalface_default.xml"
faceCascade = cv2.CascadeClassifier(cascPath)

video_capture = cv2.VideoCapture(0)

while True:
    # 逐一以影格取像
    ret, frame = video_capture.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    faces = faceCascade.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5,
        minSize=(30, 30),
        flags=cv2.CASCADE_SCALE_IMAGE
     )

    # 在辨識的臉形外圍畫一個矩形
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # 呈現影像
    cv2.imshow('Video', frame)

    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# 停止執行
video_capture.release()
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;2.執行結果&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/H6NpM2F.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;二.網路上的相關範例&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
from webcam_gui import webcam_gui

def imgproc(frame):

    # convert color to gray scale and show it
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    cv2.imshow('gray', gray)

    blur = cv2.blur(gray, (5,5))
    edge = cv2.Canny(blur, 30, 100)
    edge = cv2.blur(edge, (2,2))
    cv2.imshow('blured edge', edge)


    # convert image to black and white and show it
    thresh1, thresh = cv2.threshold(edge, 60, 255, cv2.THRESH_BINARY)
    cv2.imshow('thresh', thresh)

    # find contours!
    _,contours, hry = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # draw all the contours
    cpframe = frame.copy()
    cv2.drawContours(cpframe, contours, -1, (0,255,0), 3)
    cv2.imshow('cpframe', cpframe)

    # ================== TODO ===================

    # Modify these code to suit your need
    contours = [ctr for ctr in contours if cv2.contourArea(ctr) &gt; 100]
    contours = [cv2.approxPolyDP(ctr, 5 , True) for ctr in contours]
    contours = [ctr for ctr in contours if cv2.isContourConvex(ctr)]

    # ============================================


    # draw on the frame
    cv2.drawContours(frame, contours, -1, (0,255,0), 3)

    return frame

if __name__ == "__main__":
    webcam_gui(imgproc, video_src=0)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;1.執行結果&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/J9Z93mG.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;三.執行範例後心得&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;執行老師範例後，配合視訊裝置，可以呼叫出影像，並且進行人臉辨識。另外，我也在網路上查詢了其他相關範例，但程式碼更為複雜難懂，而網路上的範例是使用python2.x版本，所以必須換成python3的版本。
&lt;/br&gt;
&lt;/br&gt;
由於剛接觸到程式以及Opencv，所以有很多範例的程式碼是尚未瞭解的。
&lt;/br&gt;
&lt;/br&gt;
因此，我從Opencv的基礎語法中開始學習，包含cv2.imread()，cv2.imshow()，cv2.imwrite()等，先從如何呼叫圖片視窗，再到呼叫影片視窗。
&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;四.目前碰到的問題&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
1.不知道如何學習範例程式中的辨識輪廓部分，以及辨識輪廓的數值是從何處來的。
&lt;/br&gt;
&lt;/br&gt;
2.有些程式中會提到Xml檔案，但不知道是如何製作出來。
&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;五.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
1.拍.電.視.時間Github範例程式:https://github.com/fatcloud/PyCV-time
&lt;/br&gt;
&lt;/br&gt;
2.OpenCv基礎語法學習網頁:http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_table_of_contents_gui/py_table_of_contents_gui.html
&lt;/br&gt;
&lt;/br&gt;
3.大兵萊恩學習OpenCv路程:http://gogoprivateryan.blogspot.tw/2015/09/opencv-3-opencv-python-face-recognition.html
&lt;/br&gt;
&lt;/br&gt;
4.Python2 to Python3程式改變部分:https://docs.python.org/2/library/2to3.html&lt;/p&gt;</summary><category term="OpenCv"></category></entry></feed>