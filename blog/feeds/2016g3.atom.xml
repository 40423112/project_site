<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE) - 2016g3</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016g3.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2017-03-06T19:30:00+08:00</updated><entry><title>40323203&amp;05&amp;06日誌 - Measuring distance</title><link href="http://project.mde.tw/blog/403232030506ri-zhi-measuring-distance.html" rel="alternate"></link><published>2017-03-06T19:30:00+08:00</published><updated>2017-03-06T19:30:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2017-03-06:/blog/403232030506ri-zhi-measuring-distance.html</id><summary type="html">&lt;p&gt;辨識圖片中兩物體的實際距離
&lt;/br&gt;
Measuring distance between objects in an image&lt;/p&gt;
</summary><content type="html">&lt;p&gt;辨識圖片中兩物體的實際距離
&lt;/br&gt;
Measuring distance between objects in an image&lt;/p&gt;


&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/pSaQUS0"&gt;http://imgur.com/pSaQUS0&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
#以圖片最左矩形寬作為依據的距離測量
from scipy.spatial import distance as dist
from imutils import perspective
from imutils import contours
import numpy as np
import argparse
import imutils
import cv2

def midpoint(ptA, ptB):
    return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5)

ap = argparse.ArgumentParser()

#讓圖檔於開啟指令執行時輸入最左端的矩形寬度
#cmd進入py檔和圖檔所在資料夾後，輸入python 1117_distance.py --width 寬度(inch) 開啟
#寬度可直接輸入數字
ap.add_argument("-w", "--width", type=float, required=True)

args = vars(ap.parse_args())

#讀取圖檔→灰階→模糊
#cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7
img = cv2.imread("gear4.png", 1)
Gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(Gray, (3, 3), 0)

#輪廓描邊→補空&amp;侵蝕
edged = cv2.Canny(gray, 50, 100)
edged = cv2.dilate(edged, None, iterations=1)
edged = cv2.erode(edged, None, iterations=1)

#進行偵測
cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,
    cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if imutils.is_cv2() else cnts[1]

#以最左矩形四點&amp;中心為基準到其他物品的距離標示線顏色
(cnts, _) = contours.sort_contours(cnts)
colors = ((0, 0, 255), (240, 0, 159), (0, 165, 255), (255, 255, 0),
    (255, 0, 255))
refObj = None

#進行一連串的輪廓校準
for c in cnts:
    # 忽略過小的輪廓 (限定輪廓描繪範圍)
    if cv2.contourArea(c) &lt; 1500:
        continue

    # 計算輪廓旋轉邊界
    gear4 = cv2.minAreaRect(c)
    gear4 = cv2.cv.BoxPoints(gear4) if imutils.is_cv2() else cv2.boxPoints(gear4)
    gear4 = np.array(gear4, dtype="int")

    # 重新設定邊界角落座標的順序, 由左上 右上 右下 左下, 順時針方向繞
    gear4 = perspective.order_points(gear4)

    # 計算物體的中心
    cX = np.average(gear4[:, 0])
    cY = np.average(gear4[:, 1])

# 以左邊邊界輪廓當基準, 當參考對象
    if refObj is None:
        # 計算物品左右邊界的中點
        (tl, tr, br, bl) = gear4
        (tlblX, tlblY) = midpoint(tl, bl)
        (trbrX, trbrY) = midpoint(tr, br)

        # 用座標法計算兩物體中心距離
        D = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))
        refObj = (gear4, (cX, cY), D / args["width"])
        continue

    # 輪廓描繪
    orig = img.copy()
    cv2.drawContours(orig, [gear4.astype("int")], -1, (0, 255, 0), 2) # 其餘物品的輪廓描繪
    cv2.drawContours(orig, [refObj[0].astype("int")], -1, (0, 255, 0), 2) # 最左邊物品的輪廓描繪

    # refObj[0] = 最左邊物品輪廓邊緣的左上
    # refObj[1] = 物品中心
    # refCoords為基準物, objCoords為測量物
    refCoords = np.vstack([refObj[0], refObj[1]])
    objCoords = np.vstack([gear4, (cX, cY)])

    for ((xA, yA), (xB, yB), color) in zip(refCoords, objCoords, colors):
        # 基準物的四個角&amp;中心點 測量物的四個角&amp;中心點 點到點的距離
        cv2.circle(orig, (int(xA), int(yA)), 5, color, -1)
        cv2.circle(orig, (int(xB), int(yB)), 5, color, -1)
        cv2.line(orig, (int(xA), int(yA)), (int(xB), int(yB)), color, 2)

        #用座標距離法算出圖中的座標距離，並和實際的距離做比值，求出待測實際距離
        D = dist.euclidean((xA, yA), (xB, yB)) / refObj[2]
        (mX, mY) = midpoint((xA, yA), (xB, yB))
        cv2.putText(orig, "{:.1f}in".format(D), (int(mX), int(mY - 10)),
        cv2.FONT_HERSHEY_SIMPLEX, 0.55, color, 2)
        # "{:.1f}in" 取到小數點第一位

        cv2.imshow("Image", orig)
        cv2.waitKey(0)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;★範例執行結果&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/RmMEEJw.jpg"&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/A1h453s.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★Numpy &amp; Scipy 運用的主要數學計算&lt;/h3&gt;

&lt;h4&gt;
用numpy找出物體的中心
&lt;/br&gt;
用scipy進行距離計算，計算的方式是用座標法：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/sSEWyxe.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎計算過程
&lt;/br&gt;
1.以一開始輸入的基準物(最左的物體)實際寬度和用座標法在圖片中算出的寬度做比值
&lt;/br&gt;
2.分別假設基準物和待測物的座標為(X1,Y1)和(X2,Y2)帶入座標法計算出圖片中的距離
&lt;/br&gt;
3.把第二步驟求出的距離帶入第一步驟求出的比值，算出待測物的實際距離
&lt;/h4&gt;

&lt;h3&gt;★細部程式介紹&lt;/h3&gt;

&lt;h4&gt;
【cv2.GaussianBlur】圖像模糊
&lt;/br&gt;
&lt;/br&gt;
◎使用格式：
&lt;/br&gt;
&lt;img src="http://i.imgur.com/PLY5k4D.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎範例程式
&lt;/br&gt;
&lt;pre class="brush: bash"&gt;
import cv2

img = cv2.imread('gear4.png')

# cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7
# cv2.blur指令: blur = cv2.blur(img, (5,5))
# 相較於 cv2.blur, cv2.GaussianBlur多一個參數color σ（顏色空間的標準差），此數值越大使得模糊效果更明顯
blur = cv2.GaussianBlur(img, (5,5), 0)

cv2.imshow("Image", blur)
cv2.waitKey(0)
&lt;/pre&gt;
&lt;/br&gt;
◎結果：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/E4SpYIr.jpg"&gt;

&lt;/br&gt;
&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;
【cv2.Canny &amp; cv2.dilate &amp; cv2.erode】描繪輪廓→擴張輪廓→修邊侵蝕
&lt;/br&gt;
&lt;/br&gt;
◎使用格式：
&lt;/br&gt;
&lt;img src="http://i.imgur.com/tUUUeEQ.jpg"&gt;
&lt;img src="http://i.imgur.com/C7ngCSo.jpg"&gt;
&lt;img src="http://i.imgur.com/YjrILr2.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎範例程式
&lt;/br&gt;
&lt;pre class="brush: bash"&gt;
import cv2

img = cv2.imread('gear4.png',0)
edges = cv2.Canny(img,10,50)
edged = cv2.dilate(edges, None, iterations=1)
erosion = cv2.erode(edged,None,iterations = 1)

cv2.imshow("Image1", edges)
cv2.imshow("Image2", edged)
cv2.imshow("Image3", erosion)
cv2.waitKey(0)
&lt;/pre&gt;
&lt;/br&gt;
◎結果：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNVKqS6.jpg"&gt;
&lt;img src="http://i.imgur.com/2qZJ5Z8.jpg"&gt;
&lt;img src="http://i.imgur.com/VLVWr8G.jpg"&gt;
&lt;/br&gt;
&lt;/h4&gt;</content><category term="Kmol &amp; OpenCV &amp; Python"></category></entry><entry><title>40323214日誌- Install Scipy on windows</title><link href="http://project.mde.tw/blog/40323214ri-zhi-install-scipy-on-windows.html" rel="alternate"></link><published>2017-01-20T21:00:00+08:00</published><updated>2017-01-20T21:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2017-01-20:/blog/40323214ri-zhi-install-scipy-on-windows.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.Scipy基本介紹&lt;/h3&gt;

&lt;h4&gt;SciPy是一個開源的Python演算法庫和數學工具包。
&lt;/br&gt;
SciPy包含的模組有最佳化、線性代數、積分、插值、特殊函式、快速傅立葉變換、訊號處理和圖像處理、常微分方程求解和其他科學與工程中常用的計算。與其功能相類似的軟體還有MATLAB、GNU Octave和Scilab。
&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;二.安裝過程&lt;/h3&gt;
&lt;h4&gt;1.首先到http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy 網址中下載對應python(3.4.4)版本的whl檔案。Numpy這個函式庫也可以在這邊下載http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/lmr28o6.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/4gJaBxP.png"&gt;
&lt;/br&gt;
2.接著利用系統管理員找到載好檔案的路徑。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jpFKDDm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
3.再來打上對應python版本資料夾的路徑，進到scripts中，打上pip install "載好檔案的名稱前兩個英文字再按tab鍵"也就是"sc然後按tab或是nu再按tab"按下enter後就會開始下載了。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/YOZfiTb.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
4.最後在python的互動端中，使用Import測試是否有安裝成功。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/UmOR6zH.png"&gt;
&lt;/h4&gt;
&lt;h3&gt;三.安裝原因&lt;/h3&gt;
&lt;h4&gt;
1.在Opencv執行範例時需要使用。
&lt;/br&gt;
&lt;/br&gt;
2.由於直接使用pip install scipy無法正常下載，所以上網找了其他的安裝方法。
&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;四.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
1.維基百科:https://zh.wikipedia.org/zh-tw/SciPy
&lt;/br&gt;
&lt;/br&gt;
2.whl檔載點:http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
&lt;/br&gt;
&lt;/br&gt;
3.下載步驟參考影片:https://www.youtube.com/watch?v=jnpC_Ib_lbc
&lt;/h4&gt;&lt;/p&gt;</content><category term="OpenCv"></category></entry><entry><title>40323214日誌-齒輪計算</title><link href="http://project.mde.tw/blog/40323214ri-zhi-chi-lun-ji-suan.html" rel="alternate"></link><published>2016-11-23T10:00:00+08:00</published><updated>2016-11-23T10:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2016-11-23:/blog/40323214ri-zhi-chi-lun-ji-suan.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.齒輪的公式轉換&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;執行程式&lt;/h4&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import math
import sympy
from sympy import pi
#a=壓力角
#算節圓直徑
def tes1(m,t):
    d=m*t
    return(d)

#有效齒深
def tes2(m):
    h=2*m
    return(h)

#算模數 d1=外徑
def tes3(d1):
    m=d1/(t+2)
    return(m)

#基圓直徑
def tes4(d,a):
    dg=d *math.cos(a)
    return(dg)

#周節
def tes5(m):
    t0=pi.evalf()*m
    return(t0)
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;二.執行後心得&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;以上程式是關於計算正齒輪的數值，在小組做出辨識齒輪的外徑以及尺數之後，導入上述程式可以求得齒輪其他的數值，例如模數、節圓直徑...等。
&lt;/br&gt;
&lt;/br&gt;
而辨識出壓力角之後，就可以再計算更多關於齒輪的數值。
&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;三.執行後問題&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
在寫完這些程式之後，發現 sympy函式庫出現問題"No module named 'sympy'"，而原因是導入pi這個函式需要使用到sympy，所以自己在網路上找了解答，發現原來是環境裡面並沒有這個函式庫，於是我從"https://pypi.python.org/pypi/sympy"網址中下載了安裝檔，並且把所需的資料拉進環境路徑裡面，就能夠正常執行計算式子。
&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;五.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
1.齒輪計算公式:http://coccad.com/subject/about/2427.html
&lt;/br&gt;
&lt;/br&gt;
2.Sympy安裝網頁:https://pypi.python.org/pypi/sympy
&lt;/br&gt;
&lt;/h4&gt;&lt;/p&gt;</content><category term="OpenCv"></category></entry><entry><title>40323205日誌 - OpenCV (繪圖函式)</title><link href="http://project.mde.tw/blog/40323205ri-zhi-opencv-hui-tu-han-shi.html" rel="alternate"></link><published>2016-11-17T22:30:00+08:00</published><updated>2016-11-17T22:30:00+08:00</updated><author><name>40323205</name></author><id>tag:project.mde.tw,2016-11-17:/blog/40323205ri-zhi-opencv-hui-tu-han-shi.html</id><summary type="html">&lt;h4&gt;繪圖函式 - cv2.line, cv2.circle, cv2.rectangle, cv2.ellipse&lt;/h4&gt;

</summary><content type="html">&lt;h4&gt;繪圖函式 - cv2.line, cv2.circle, cv2.rectangle, cv2.ellipse&lt;/h4&gt;



&lt;h4&gt;目前電腦都可畫出線、矩形、圓、橢圓，並更改黑色背景大小。&lt;/h4&gt;

&lt;h3&gt;【畫線】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/dC0Jpmg.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫線-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((512,512,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.line(img,(0,0),(511,511),(255,0,0),5)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫矩形】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/xHEpGBC.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫矩形-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((200,200,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.rectangle(img,(10,10),(100,150),(0,255,0),10)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫圓】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/pIBit41.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫圓-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((300,300,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.circle(img,(100,150), 100, (0,0,255), -1)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫橢圓】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/wkuBhn5.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫橢圓-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((450,450,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.ellipse(img,(256,256),(100,50),20,150,360, (255,0,255),3)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;後記 - 目前正在研究其他OpenCV程式，在這裡先呈現最基礎的繪圖函式。&lt;/h4&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323203日誌 - OpenCV(載入圖像)</title><link href="http://project.mde.tw/blog/40323203ri-zhi-opencvzai-ru-tu-xiang.html" rel="alternate"></link><published>2016-11-17T22:00:00+08:00</published><updated>2016-11-17T22:00:00+08:00</updated><author><name>40323203</name></author><id>tag:project.mde.tw,2016-11-17:/blog/40323203ri-zhi-opencvzai-ru-tu-xiang.html</id><summary type="html">&lt;h3&gt;載入圖片及影像--cv2.imread,cv2.VideoCapture&lt;/h3&gt;

</summary><content type="html">&lt;h3&gt;載入圖片及影像--cv2.imread,cv2.VideoCapture&lt;/h3&gt;



&lt;hr&gt;
&lt;h4&gt;載入圖片程式&lt;/h4&gt;

&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

#載入jpg圖檔
#imread:讀取圖片，並將資料寫入Mat/flags:影像標誌
#IMREAD_COLOR:彩色模式可用1表示
#IMREAD_GRAYSCALE:灰度圖可用0表示
#IMREAD_UNCHANGED:透明度可用-1表示
image = cv2.imread("DSC00040.jpg", flags=cv2.IMREAD_COLOR)

#WINDOW_NORMAL:調節窗口大小
#WINDOW_AUTOSIZE:固定窗口大小
cv2.namedWindow('image',cv2.WINDOW_NORMAL) 

cv2.imshow('image',image) 
cv2.waitKey(0) 
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;顯示圖片結果可為彩色及黑白:&lt;/h4&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/1nXHjD7.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;載入影片程式&lt;/h4&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

#Capture:拍攝,紀錄
cap = cv2.VideoCapture('00007.avi')

while(cap.isOpened()):
    ret, frame = cap.read()

    #cvtColor：轉換影像色域，程式以轉換RGB到gray為例
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    cv2.imshow('frame',gray)
    if cv2.waitKey(6) &amp; 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323206日誌 - OpenCV (Dots)</title><link href="http://project.mde.tw/blog/40323206ri-zhi-opencv-dots.html" rel="alternate"></link><published>2016-11-15T20:53:00+08:00</published><updated>2016-11-15T20:53:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2016-11-15:/blog/40323206ri-zhi-opencv-dots.html</id><summary type="html">&lt;p&gt;物體角落(點)的辨識 --- cv2.cornerHarris &amp;amp; cv2.dilate&lt;/p&gt;
</summary><content type="html">&lt;p&gt;物體角落(點)的辨識 --- cv2.cornerHarris &amp;amp; cv2.dilate&lt;/p&gt;


&lt;h3&gt;★cv2.cornerHarris的使用&amp;格式&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/zne7h7s.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/F05kwRB"&gt;http://imgur.com/F05kwRB&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import numpy as np

filename = 'chessboard.png'
img = cv2.imread(filename)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

gray = np.float32(gray)
dst = cv2.cornerHarris(gray,2,3,0.04)

#result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst&gt;0.01*dst.max()]=[0,0,255]

cv2.imshow('dst',img)
if cv2.waitKey(0) &amp; 0xff == 27:
    cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例執行(已灰階)前後之比較&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/chMPHbO.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★套用於齒輪辨識&lt;/h3&gt;

&lt;h4&gt;
有包含圓和圓心的辨識&amp;單獨作角落抓點
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
from matplotlib import pyplot as plt

img = cv2.imread("gear2.png", 1)
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
cv2.imwrite('graygear.png', imgGray)

# 抓點
gray = np.float32(imgGray)
dst = cv2.cornerHarris(gray,2,3,0.04)

# result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst&gt;0.01*dst.max()]=[0,0,255]

cv2.imshow('dst',img)

# 抓圓
circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,1,20,
                            param1=60,param2=50,minRadius=0,maxRadius=60)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # draw the outer circle
    cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2)
    # draw the center of the circle
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img)


cv2.waitKey(0)


cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;/br&gt;

&lt;h3&gt;★齒輪辨識目的&lt;/h3&gt;
&lt;h4&gt;配合之前的圓心可以初步抓出齒輪的外徑、內徑，方便之後直行計算相關程式的條件。&lt;/h4&gt;
&lt;/br&gt;

&lt;h3&gt;★齒輪辨識結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/116TeT4.jpg"&gt;
&lt;/br&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323206日誌 - OpenCV (Circles)</title><link href="http://project.mde.tw/blog/40323206ri-zhi-opencv-circles.html" rel="alternate"></link><published>2016-11-14T20:16:00+08:00</published><updated>2016-11-14T20:16:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2016-11-14:/blog/40323206ri-zhi-opencv-circles.html</id><summary type="html">&lt;p&gt;圓形的辨識 --- cv2.HoughCircles&lt;/p&gt;
</summary><content type="html">&lt;p&gt;圓形的辨識 --- cv2.HoughCircles&lt;/p&gt;


&lt;h3&gt;★cv2.HoughCircles的使用&amp;格式&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/sSe92Wx.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/EyLp3Qx"&gt;http://imgur.com/EyLp3Qx&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import numpy as np

img = cv2.imread('opencv_logo.png',0)
img = cv2.medianBlur(img,5)
cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)

circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,
                            1,20,
                            param1=50,
                            param2=40, 
                            minRadius=0,
                            maxRadius=0)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # draw the outer circle
    cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),3)
    # draw the center of the circle
    cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',cimg)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例執行前後之比較&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/fSWa1OC.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★套用於齒輪辨識&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
from matplotlib import pyplot as plt

# 讀取圖檔
img = cv2.imread("gear1.png", 1)
# 圖檔轉灰階
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 灰階後進行存檔
cv2.imwrite('graygear.png', imgGray)

# 使用灰階圖抓圓
circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,
                            1,20,
                            param1=60,
                            param2=50,
                            minRadius=0,
                            maxRadius=60)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # 圓形的繪製
    cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2)
    # 圓心的繪製
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img)

cv2.waitKey(0)
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★齒輪辨識目的&lt;/h3&gt;

&lt;h4&gt;找出齒輪的圓心位置，方便之後直行計算相關程式的條件。&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★齒輪辨識結果&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/1gvQ3vH.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323214日誌-Opencv範例</title><link href="http://project.mde.tw/blog/40323214ri-zhi-opencvfan-li.html" rel="alternate"></link><published>2016-08-04T15:00:00+08:00</published><updated>2016-08-04T15:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2016-08-04:/blog/40323214ri-zhi-opencvfan-li.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.Windows執行範例程式&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;1.範例程式&lt;/h4&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import sys

cascPath = "haarcascade_frontalface_default.xml"
faceCascade = cv2.CascadeClassifier(cascPath)

video_capture = cv2.VideoCapture(0)

while True:
    # 逐一以影格取像
    ret, frame = video_capture.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    faces = faceCascade.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5,
        minSize=(30, 30),
        flags=cv2.CASCADE_SCALE_IMAGE
     )

    # 在辨識的臉形外圍畫一個矩形
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # 呈現影像
    cv2.imshow('Video', frame)

    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# 停止執行
video_capture.release()
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;2.執行結果&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/H6NpM2F.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;二.網路上的相關範例&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
from webcam_gui import webcam_gui

def imgproc(frame):

    # convert color to gray scale and show it
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    cv2.imshow('gray', gray)

    blur = cv2.blur(gray, (5,5))
    edge = cv2.Canny(blur, 30, 100)
    edge = cv2.blur(edge, (2,2))
    cv2.imshow('blured edge', edge)


    # convert image to black and white and show it
    thresh1, thresh = cv2.threshold(edge, 60, 255, cv2.THRESH_BINARY)
    cv2.imshow('thresh', thresh)

    # find contours!
    _,contours, hry = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # draw all the contours
    cpframe = frame.copy()
    cv2.drawContours(cpframe, contours, -1, (0,255,0), 3)
    cv2.imshow('cpframe', cpframe)

    # ================== TODO ===================

    # Modify these code to suit your need
    contours = [ctr for ctr in contours if cv2.contourArea(ctr) &gt; 100]
    contours = [cv2.approxPolyDP(ctr, 5 , True) for ctr in contours]
    contours = [ctr for ctr in contours if cv2.isContourConvex(ctr)]

    # ============================================


    # draw on the frame
    cv2.drawContours(frame, contours, -1, (0,255,0), 3)

    return frame

if __name__ == "__main__":
    webcam_gui(imgproc, video_src=0)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;1.執行結果&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/J9Z93mG.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;三.執行範例後心得&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;執行老師範例後，配合視訊裝置，可以呼叫出影像，並且進行人臉辨識。另外，我也在網路上查詢了其他相關範例，但程式碼更為複雜難懂，而網路上的範例是使用python2.x版本，所以必須換成python3的版本。
&lt;/br&gt;
&lt;/br&gt;
由於剛接觸到程式以及Opencv，所以有很多範例的程式碼是尚未瞭解的。
&lt;/br&gt;
&lt;/br&gt;
因此，我從Opencv的基礎語法中開始學習，包含cv2.imread()，cv2.imshow()，cv2.imwrite()等，先從如何呼叫圖片視窗，再到呼叫影片視窗。
&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;四.目前碰到的問題&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
1.不知道如何學習範例程式中的辨識輪廓部分，以及辨識輪廓的數值是從何處來的。
&lt;/br&gt;
&lt;/br&gt;
2.有些程式中會提到Xml檔案，但不知道是如何製作出來。
&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;五.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
1.拍.電.視.時間Github範例程式:https://github.com/fatcloud/PyCV-time
&lt;/br&gt;
&lt;/br&gt;
2.OpenCv基礎語法學習網頁:http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_table_of_contents_gui/py_table_of_contents_gui.html
&lt;/br&gt;
&lt;/br&gt;
3.大兵萊恩學習OpenCv路程:http://gogoprivateryan.blogspot.tw/2015/09/opencv-3-opencv-python-face-recognition.html
&lt;/br&gt;
&lt;/br&gt;
4.Python2 to Python3程式改變部分:https://docs.python.org/2/library/2to3.html&lt;/p&gt;</content><category term="OpenCv"></category></entry></feed>