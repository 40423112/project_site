<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/all.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-07-03T14:50:30+08:00</updated><entry><title>40323230日誌 - 105/07/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703.html" rel="alternate"></link><updated>2016-07-03T14:50:30+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:blog/40323230ri-zhi-1050703.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;


&lt;h2&gt;Notes :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="http://www.activestate.com/activeperl/downloads" title="activestate.com"&gt;Active State&lt;/a&gt;下載了 ActivePerl，使用的是5.24.0／x64版。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="visualstudio.com"&gt;Microsoft&lt;/a&gt;下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;GitHub&lt;/a&gt;下載Solvespace的原始碼，另外在&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace&lt;/a&gt;提供下載的頁面中也有一個較舊版的原始碼。&lt;/p&gt;
&lt;p&gt;裝完之後用CMD從安裝目錄的\VC\bin啟動vcvars32.bat，r就可以編譯內容了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iCFeYAe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;關於NMAKE的使用方法，找了幾個中國的網站介紹：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://www.cnblogs.com/kekec/archive/2013/04/21/3007277.html" title="cnblogs.com"&gt;NMAKE的指令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.csdn.net/cneaglelee/article/details/11714803" title="csdn.net"&gt;NMAKE的開發環境設置&lt;/a&gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>PySerial 問題</title><link href="http://project.mde.tw/blog/pyserial-wen-ti.html" rel="alternate"></link><updated>2016-07-02T20:40:03+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-02:blog/pyserial-wen-ti.html</id><summary type="html">&lt;p&gt;今日讀的進度，以及筆記&lt;/p&gt;


&lt;h2&gt;發現到的問題&lt;/h2&gt;

&lt;p&gt;主要是安裝wxpython phoenix 和他原本使用的wxpython不一樣，因此需要更改一些兩者的不同，但是在wxTerminal的部分可以跑出gui介面，但是再傳收值得部分，有些許問題，來自於wxpython和wxpython phoenix 的部分他們不互相支援，可能是他們還有些問題&lt;/p&gt;
&lt;p&gt;主要出問題的部分是來自於line 349&lt;/p&gt;
&lt;p&gt;git clone :https://github.com/pyserial/pyserial  在example裡面的wxTerminal.py啟動收值部分有些許問題&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uIMc1rm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src= "http://i.imgur.com/xMa2cwn.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pFmSRlE.png"&gt;&lt;/p&gt;
&lt;h3&gt;底下為我寫的測試的程式&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

import serial

with serial.Serial() as ser:
    ser.baudrate = 9600
    ser.port = 'COM6'
    ser.open()
    print(ser.name)
#    ser.write(b'hello')
    while(1):
# transform data

        #ser.write(b"hello")


        x = ser.read().decode

        print(x)
&lt;/pre&gt;

&lt;h3&gt;實際測試部分&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/uIMc1rm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aEOnq9R.png"&gt;&lt;/p&gt;
&lt;h3&gt;最後補上  認真==鑽牛角尖的第二組  量螺絲&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/UlaIizY.jpg"&gt;&lt;/p&gt;</summary><category term="wxpython"></category></entry><entry><title>40323230紀錄</title><link href="http://project.mde.tw/blog/40323230ji-lu.html" rel="alternate"></link><updated>2016-07-02T13:30:01+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-02:blog/40323230ji-lu.html</id><summary type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;


&lt;h2&gt;V-REP Example Learning Reviews&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;嘗試用英文說明&lt;/h4&gt;
&lt;/br&gt;
&lt;h2&gt;Notes :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;The "Scene hierarchy" panel can show whole of outward and entity in a tree.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy" title="coppeliarobotics.com"&gt;Scene hierarchy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/cqIHtFn.jpg" &gt;
&lt;/br&gt;
&lt;h3&gt;In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Any parts can insert a script to control them.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;"Dummy" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummies.htm" title="coppeliarobotics.com"&gt;Dummy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/caU2SLx.jpg" &gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;目前整理完幾何部件的檔案。存於\users\g2_files\VREP_Simulation.ttt中。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNvEHRc.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="V-rep"></category></entry><entry><title>40323131日誌 105/07/01</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050701.html" rel="alternate"></link><updated>2016-07-02T12:49:15+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-02:blog/40323131ri-zhi-1050701.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;python2語法 修改成python3語法&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;下圖框框處，原本的程式碼是 gettext.install(domain, './locale', unicode = 1)，我是將unicode = 1 拿掉&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/S4niXlw.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;底下的程式碼原本為imp.reload(sys) 
sys.setdefaultencoding('utf-8') ，在這裡我是將後面的sys.setdefaultencoding('utf-8') 拿掉，因為好像python3默認的編碼原本就是utf-8了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/g1UJkp7.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的問題&lt;/h3&gt;
&lt;h4&gt;下面的錯誤是說模組沒有被loaded，所以無法導入，不過我去找了一下它的目錄裡頭是有bufferedcanvas這個檔案的，所以就不清楚錯誤出在哪裡&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/K3srBRX.png"&gt;
&lt;/br&gt;
&lt;h4&gt;接著底下的這個問題大概是我卡最久的地方，self.bgcolor = wx.Colour()，錯誤是說Colour這個物件沒有歸類在SetFromName裡頭，我試了蠻多次，結果都差不多....&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/tgWDvca.png"&gt;
&lt;/br&gt;
&lt;h4&gt;於是我又進到wx套件裡頭去找有沒有Colour這個物件，是找到蠻多有Colour字母的檔案，不過我不清楚要import哪一個&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/k3SVgXL.png"&gt;
&lt;/br&gt;
&lt;h3&gt;由於自己對於python的物件導向沒什麼概念，class跟__init__這些都不是很熟，感覺整天修改下來根本沒改什麼東西，所以感覺蠻有挫折感的...，另外用python3裡頭內建的2to3.py檔下去修改python2轉成python3語法的錯誤，感覺方便許多，我用的指令是python y:\Python34\Tools\Scipts\2to3.py -w 要修改的py檔，y:\Python34\Tools\Scipts\2to3.py 這裡是給定2to3.py檔的位置給它，-w是write的意思，然後才是要修改的py檔案&lt;/h3&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/07/01</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050701.html" rel="alternate"></link><updated>2016-07-02T12:49:15+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-02:blog/40323250ri-zhi-1050701.html</id><summary type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;


&lt;h2&gt;★暑期第一個禮拜的 星期四★&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h2&gt;心得 :&lt;/h2&gt;
&lt;h3&gt;今天在網路上找了一堆範例影片 ,每一部片都快一個小時 ,然後都不知道怎麼運用 ,但至少對V-rep功能多了解一些了。&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;★暑期第一個禮拜的 星期五★&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;基本功能 : &lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;導入stl檔案&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/import.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;先點選導入的檔案 ,然後點選Edit選單下的Grouping / Merging ,點選 Divide selected shapes 分離零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/divide_objects.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;分離完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/divide_done.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;拆解可能遇到的問題&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_problems.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;加入旋轉軸 : 在右側視窗點選右鍵 , 新增 → 節點 → 旋轉軸
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;新增完成 ,快點兩下圖示 ,可以設定相關性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;橘色框框為旋轉軸長度及直徑 ,旋轉軸最後可以設定隱藏&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;如果相關參數都設定好了 ,點選右鍵→編輯→使旋轉軸與零件結合成一物件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結合後的從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_parent.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;心得 :&lt;/h2&gt;
&lt;h3&gt;V-rep很好玩 ,但是它組裝的層次又比creo2.0又更上一檔次了 ,
俗話說的好 「良藥苦口」,好用的東西種剛開始總是特別棘手。 &lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;★暑期第一個禮拜的 星期六★&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;工廠認證 及 探查狀況&lt;/h3&gt;
&lt;h3&gt;傳統機臺幾乎沒有精度可言 ,一年級時故障的機臺也都沒有維修 ,只怕使用傳統機臺會成為受害者 ,不敢使用!!&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入攝影機&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;vision_sensor類型可分為 :
a.為orthographic type  及  b.為perspective type&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_types.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 ,
綠色框框為範圍內的px格數(?) (2^n ,2~256) ,棕色框框為攝影機大小&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將旋轉桿和攝影機結合並設定從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/add_2views.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/first_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/second_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;啟動程式來跑看看囉~&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision.gif"&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>PySerial進度</title><link href="http://project.mde.tw/blog/pyserialjin-du.html" rel="alternate"></link><updated>2016-07-02T12:49:15+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-02:blog/pyserialjin-du.html</id><summary type="html">&lt;p&gt;今日讀的進度，以及筆記&lt;/p&gt;


&lt;h3&gt;三個要件&lt;/h3&gt;

&lt;p&gt;1.pyserial&lt;/p&gt;
&lt;p&gt;2.wxpython with Phoenix&lt;/p&gt;
&lt;p&gt;3.python3以上的版本&lt;/p&gt;
&lt;h3&gt;2.7版的wxxpython和phoenix wxpython api比較&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://wxpython.org/Phoenix/docs/html/classic_vs_phoenix.html#classic-vs-phoenix"&gt;網站連結&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PySerial documation about io control&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://pyserial.readthedocs.io/en/latest/shortintro.html"&gt;網站連結&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Wxxpython API Module&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://wxpython.org/Phoenix/docs/html/main.html"&gt;網站連結&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Wxxpython GUI Bulider wxGlade&lt;/h3&gt;

&lt;p&gt;今日寫程式遇到的問題點&lt;/p&gt;
&lt;p&gt;1.在wxTeriminal中遇到問題來自於他沒辦法顯示我傳給他的值&lt;/p&gt;
&lt;p&gt;2.以及他的pyserial中，需要詳細測試他所收到以及送的值的格式&lt;/p&gt;
&lt;p&gt;3.才能自己寫一套for python3 Gui的程式控制&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GUqnneU.jpg"&gt;&lt;/p&gt;
&lt;p&gt;要能成功執行下方的程式必須要安裝&lt;/p&gt;
&lt;p&gt;1.python 3.4+&lt;/p&gt;
&lt;p&gt;2.wxPython Phoenix&lt;/p&gt;
&lt;p&gt;3.pyserial&lt;/p&gt;
&lt;h3&gt;關於程式碼有更改後的&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

#file name wxSerialConfigDialog.py

import wx
import serial
import serial.tools.list_ports

SHOW_BAUDRATE = 1 &lt;&lt; 0
SHOW_FORMAT = 1 &lt;&lt; 1
SHOW_FLOW = 1 &lt;&lt; 2
SHOW_TIMEOUT = 1 &lt;&lt; 3
SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT


class SerialConfigDialog(wx.Dialog):
    """\
    Serial Port configuration dialog, to be used with pySerial 2.0+
    When instantiating a class of this dialog, then the "serial" keyword
    argument is mandatory. It is a reference to a serial.Serial instance.
    the optional "show" keyword argument can be used to show/hide different
    settings. The default is SHOW_ALL which corresponds to
    SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be
    found in this module (not the class).
    """

    def __init__(self, *args, **kwds):
        # grab the serial keyword and remove it from the dict
        self.serial = kwds['serial']
        del kwds['serial']
        self.show = SHOW_ALL
        if 'show' in kwds:
            self.show = kwds.pop('show')
        # begin wxGlade: SerialConfigDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_2 = wx.StaticText(self, -1, "Port")
        self.choice_port = wx.Choice(self, -1, choices=[])
        self.label_1 = wx.StaticText(self, -1, "Baudrate")
        self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN)
        self.sizer_1_staticbox = wx.StaticBox(self, -1, "Basics")
        self.panel_format = wx.Panel(self, -1)
        self.label_3 = wx.StaticText(self.panel_format, -1, "Data Bits")
        self.choice_databits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_4 = wx.StaticText(self.panel_format, -1, "Stop Bits")
        self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_5 = wx.StaticText(self.panel_format, -1, "Parity")
        self.choice_parity = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, "Data Format")
        self.panel_timeout = wx.Panel(self, -1)
        self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, "Use Timeout")
        self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, "")
        self.label_6 = wx.StaticText(self.panel_timeout, -1, "seconds")
        self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, "Timeout")
        self.panel_flow = wx.Panel(self, -1)
        self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, "RTS/CTS")
        self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, "Xon/Xoff")
        self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, "Flow Control")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        # attach the event handlers
        self.__attach_events()

    def __set_properties(self):
        # begin wxGlade: SerialConfigDialog.__set_properties
        self.SetTitle("Serial Port Configuration")
        self.choice_databits.SetSelection(0)
        self.choice_stopbits.SetSelection(0)
        self.choice_parity.SetSelection(0)
        self.text_ctrl_timeout.Enable(False)
        self.button_ok.SetDefault()
        # end wxGlade
        self.SetTitle("Serial Port Configuration")
        if self.show &amp; SHOW_TIMEOUT:
            self.text_ctrl_timeout.Enable(0)
        self.button_ok.SetDefault()

        if not self.show &amp; SHOW_BAUDRATE:
            self.label_1.Hide()
            self.combo_box_baudrate.Hide()
        if not self.show &amp; SHOW_FORMAT:
            self.panel_format.Hide()
        if not self.show &amp; SHOW_TIMEOUT:
            self.panel_timeout.Hide()
        if not self.show &amp; SHOW_FLOW:
            self.panel_flow.Hide()

        # fill in ports and select current setting
        preferred_index = 0
        self.choice_port.Clear()
        self.ports = []
        for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())):
            self.choice_port.Append('{} - {}'.format(portname, desc))
            self.ports.append(portname)
            if self.serial.name == portname:
                preferred_index = n
        self.choice_port.SetSelection(preferred_index)
        if self.show &amp; SHOW_BAUDRATE:
            preferred_index = None
            # fill in baud rates and select current setting
            self.combo_box_baudrate.Clear()
            for n, baudrate in enumerate(self.serial.BAUDRATES):
                self.combo_box_baudrate.Append(str(baudrate))
                if self.serial.baudrate == baudrate:
                    preferred_index = n
            if preferred_index is not None:
                self.combo_box_baudrate.SetSelection(preferred_index)
            else:
                self.combo_box_baudrate.SetValue('{}'.format(self.serial.baudrate))
        if self.show &amp; SHOW_FORMAT:
            # fill in data bits and select current setting
            self.choice_databits.Clear()
            for n, bytesize in enumerate(self.serial.BYTESIZES):
                self.choice_databits.Append(str(bytesize))
                if self.serial.bytesize == bytesize:
                    index = n
            self.choice_databits.SetSelection(index)
            # fill in stop bits and select current setting
            self.choice_stopbits.Clear()
            for n, stopbits in enumerate(self.serial.STOPBITS):
                self.choice_stopbits.Append(str(stopbits))
                if self.serial.stopbits == stopbits:
                    index = n
            self.choice_stopbits.SetSelection(index)
            # fill in parities and select current setting
            self.choice_parity.Clear()
            for n, parity in enumerate(self.serial.PARITIES):
                self.choice_parity.Append(str(serial.PARITY_NAMES[parity]))
                if self.serial.parity == parity:
                    index = n
            self.choice_parity.SetSelection(index)
        if self.show &amp; SHOW_TIMEOUT:
            # set the timeout mode and value
            if self.serial.timeout is None:
                self.checkbox_timeout.SetValue(False)
                self.text_ctrl_timeout.Enable(False)
            else:
                self.checkbox_timeout.SetValue(True)
                self.text_ctrl_timeout.Enable(True)
                self.text_ctrl_timeout.SetValue(str(self.serial.timeout))
        if self.show &amp; SHOW_FLOW:
            # set the rtscts mode
            self.checkbox_rtscts.SetValue(self.serial.rtscts)
            # set the rtscts mode
            self.checkbox_xonxoff.SetValue(self.serial.xonxoff)

    def __do_layout(self):
        # begin wxGlade: SerialConfigDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_flow_staticbox.Lower()
        sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL)
        self.sizer_timeout_staticbox.Lower()
        sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL)
        self.sizer_format_staticbox.Lower()
        sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL)
        grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0)
        self.sizer_1_staticbox.Lower()
        sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL)
        sizer_basics = wx.FlexGridSizer(3, 2, 0, 0)
        sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0)
        sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0)
        sizer_basics.AddGrowableCol(1)
        sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0)
        sizer_2.Add(sizer_1, 0, wx.EXPAND, 0)
        grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        self.panel_format.SetSizer(sizer_format)
        sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0)
        sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0)
        sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        self.panel_timeout.SetSizer(sizer_timeout)
        sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0)
        sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add((10, 10), 1, wx.EXPAND, 0)
        self.panel_flow.SetSizer(sizer_flow)
        sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK)
        wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel)
        if self.show &amp; SHOW_TIMEOUT:
            wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout)

    def OnOK(self, events):
        success = True
        self.serial.port = self.ports[self.choice_port.GetSelection()]
        if self.show &amp; SHOW_BAUDRATE:
            try:
                b = int(self.combo_box_baudrate.GetValue())
            except ValueError:
                with wx.MessageDialog(
                        self,
                        'Baudrate must be a numeric value',
                        'Value Error',
                        wx.OK | wx.ICON_ERROR) as dlg:
                    dlg.ShowModal()
                success = False
            else:
                self.serial.baudrate = b
        if self.show &amp; SHOW_FORMAT:
            self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()]
            self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()]
            self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()]
        if self.show &amp; SHOW_FLOW:
            self.serial.rtscts = self.checkbox_rtscts.GetValue()
            self.serial.xonxoff = self.checkbox_xonxoff.GetValue()
        if self.show &amp; SHOW_TIMEOUT:
            if self.checkbox_timeout.GetValue():
                try:
                    self.serial.timeout = float(self.text_ctrl_timeout.GetValue())
                except ValueError:
                    with wx.MessageDialog(
                            self,
                            'Timeout must be a numeric value',
                            'Value Error',
                            wx.OK | wx.ICON_ERROR) as dlg:
                        dlg.ShowModal()
                    success = False
            else:
                self.serial.timeout = None
        if success:
            self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        self.EndModal(wx.ID_CANCEL)

    def OnTimeout(self, events):
        if self.checkbox_timeout.GetValue():
            self.text_ctrl_timeout.Enable(True)
        else:
            self.text_ctrl_timeout.Enable(False)

# end of class SerialConfigDialog


class MyApp(wx.App):
    """Test code"""
    def OnInit(self):
        wx.InitAllImageHandlers()

        ser = serial.Serial()
        print(ser)
        # loop until cancel is pressed, old values are used as start for the next run
        # show the different views, one after the other
        # value are kept.
        for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL):
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser, show=flags)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        # the user can play around with the values, CANCEL aborts the loop
        while True:
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        return 0

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;

&lt;h3&gt;主程式部分&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

#file name wxTerminal.py

import codecs
import serial
import threading
import wx
import wxSerialConfigDialog

# ----------------------------------------------------------------------
# Create an own event type, so that GUI updates can be delegated
# this is required as on some platforms only the main thread can
# access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave
# could be used too, but an event is more elegant.

SERIALRX = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0)


class SerialRxEvent(wx.PyCommandEvent):
    eventType = SERIALRX

    def __init__(self, windowID, data):
        wx.PyCommandEvent.__init__(self, self.eventType, windowID)
        self.data = data

    def Clone(self):
        self.__class__(self.GetId(), self.data)

# ----------------------------------------------------------------------

ID_CLEAR = wx.NewId()
ID_SAVEAS = wx.NewId()
ID_SETTINGS = wx.NewId()
ID_TERM = wx.NewId()
ID_EXIT = wx.NewId()
ID_RTS = wx.NewId()
ID_DTR = wx.NewId()

NEWLINE_CR = 0
NEWLINE_LF = 1
NEWLINE_CRLF = 2


class TerminalSetup:
    """
    Placeholder for various terminal settings. Used to pass the
    options to the TerminalSettingsDialog.
    """
    def __init__(self):
        self.echo = False
        self.unprintable = False
        self.newline = NEWLINE_CRLF


class TerminalSettingsDialog(wx.Dialog):
    """Simple dialog with common terminal settings like echo, newline mode."""

    def __init__(self, *args, **kwds):
        self.settings = kwds['settings']
        del kwds['settings']
        # begin wxGlade: TerminalSettingsDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.checkbox_echo = wx.CheckBox(self, -1, "Local Echo")
        self.checkbox_unprintable = wx.CheckBox(self, -1, "Show unprintable characters")
        self.radio_box_newline = wx.RadioBox(self, -1, "Newline Handling", choices=["CR only", "LF only", "CR+LF"], majorDimension=0, style=wx.RA_SPECIFY_ROWS)
        self.sizer_4_staticbox = wx.StaticBox(self, -1, "Input/Output")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.__attach_events()
        self.checkbox_echo.SetValue(self.settings.echo)
        self.checkbox_unprintable.SetValue(self.settings.unprintable)
        self.radio_box_newline.SetSelection(self.settings.newline)

    def __set_properties(self):
        # begin wxGlade: TerminalSettingsDialog.__set_properties
        self.SetTitle("Terminal Settings")
        self.radio_box_newline.SetSelection(0)
        self.button_ok.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalSettingsDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_4_staticbox.Lower()
        sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL)
        sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4)
        sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4)
        sizer_4.Add(self.radio_box_newline, 0, 0, 0)
        sizer_2.Add(sizer_4, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId())

    def OnOK(self, events):
        """Update data wil new values and close dialog."""
        self.settings.echo = self.checkbox_echo.GetValue()
        self.settings.unprintable = self.checkbox_unprintable.GetValue()
        self.settings.newline = self.radio_box_newline.GetSelection()
        self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        """Do not update data but close dialog."""
        self.EndModal(wx.ID_CANCEL)

# end of class TerminalSettingsDialog


class TerminalFrame(wx.Frame):
    """Simple terminal program for wxPython"""

    def __init__(self, *args, **kwds):
        self.serial = serial.Serial()
        self.serial.timeout = 0.5   # make sure that the alive event can be checked from time to time
        self.settings = TerminalSetup()  # placeholder for the settings
        self.thread = None
        self.alive = threading.Event()
        # begin wxGlade: TerminalFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        # Menu Bar
        self.frame_terminal_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_CLEAR, "&amp;Clear", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(ID_SAVEAS, "&amp;Save Text As...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_TERM, "&amp;Terminal Settings...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_EXIT, "&amp;Exit", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "&amp;File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_RTS, "RTS", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_DTR, "&amp;DTR", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_SETTINGS, "&amp;Port Settings...", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "Serial Port")
        self.SetMenuBar(self.frame_terminal_menubar)
        # Menu Bar end
        self.text_ctrl_output = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE | wx.TE_READONLY)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS)
        self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        # end wxGlade
        self.__attach_events()          # register events
        self.OnPortSettings(None)       # call setup dialog on startup, opens port
        if not self.alive.isSet():
            self.Close()

    def StartThread(self):
        """Start the receiver thread"""
        self.thread = threading.Thread(target=self.ComPortThread)
        self.thread.setDaemon(1)
        self.alive.set()
        self.thread.start()
        self.serial.rts = True
        self.serial.dtr = True
        self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts)
        self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr)

    def StopThread(self):
        """Stop the receiver thread, wait until it's finished."""
        if self.thread is not None:
            self.alive.clear()          # clear alive event for thread
            self.thread.join()          # wait until thread has finished
            self.thread = None

    def __set_properties(self):
        # begin wxGlade: TerminalFrame.__set_properties
        self.SetTitle("Serial Terminal")
        self.SetSize((546, 383))
        self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, ""))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        # register events at the controls
        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey)
        self.Bind(EVT_SERIALRX, self.OnSerialRead)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnExit(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Menu point Exit"""
        self.Close()

    def OnClose(self, event):
        """Called on application shutdown."""
        self.StopThread()               # stop reader thread
        self.serial.close()             # cleanup
        self.Destroy()                  # close windows, exit app

    def OnSaveAs(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Save contents of output window."""
        with wx.FileDialog(
                None,
                "Save Text As...",
                ".",
                "",
                "Text File|*.txt|All Files|*",
                wx.SAVE) as dlg:
            if dlg.ShowModal() == wx.ID_OK:
                filename = dlg.GetPath()
                with codecs.open(filename, 'w', encoding='utf-8') as f:
                    text = self.text_ctrl_output.GetValue().encode("utf-8")
                    f.write(text)

    def OnClear(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Clear contents of output window."""
        self.text_ctrl_output.Clear()

    def OnPortSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """
        Show the port settings dialog. The reader thread is stopped for the
        settings change.
        """
        if event is not None:           # will be none when called on startup
            self.StopThread()
            self.serial.close()
        ok = False
        while not ok:
            with wxSerialConfigDialog.SerialConfigDialog(
                    self,
                    -1,
                    "",
                    show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW,
                    serial=self.serial) as dialog_serial_cfg:
                dialog_serial_cfg.CenterOnParent()
                result = dialog_serial_cfg.ShowModal()
            # open port if not called on startup, open it on startup and OK too
            if result == wx.ID_OK or event is not None:
                try:
                    self.serial.open()
                except serial.SerialException as e:
                    with wx.MessageDialog(self, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)as dlg:
                        dlg.ShowModal()
                else:
                    self.StartThread()
                    self.SetTitle("Serial Terminal on {} [{},{},{},{}{}{}]".format(
                        self.serial.portstr,
                        self.serial.baudrate,
                        self.serial.bytesize,
                        self.serial.parity,
                        self.serial.stopbits,
                        ' RTS/CTS' if self.serial.rtscts else '',
                        ' Xon/Xoff' if self.serial.xonxoff else '',
                        ))
                    ok = True
            else:
                # on startup, dialog aborted
                self.alive.clear()
                ok = True

    def OnTermSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """\
        Menu point Terminal Settings. Show the settings dialog
        with the current terminal settings.
        """
        with TerminalSettingsDialog(self, -1, "", settings=self.settings) as dialog:
            dialog.CenterOnParent()
            dialog.ShowModal()

    def OnKey(self, event):
        """\
        Key event handler. If the key is in the ASCII range, write it to the
        serial port. Newline handling and local echo is also done here.
        """
        code = event.GetUnicodeKey()
        if code &lt; 256:   # XXX bug in some versions of wx returning only capital letters
            code = event.GetKeyCode()
        if code == 13:                      # is it a newline? (check for CR which is the RETURN key)
            if self.settings.echo:          # do echo if needed
                self.text_ctrl_output.AppendText('\n')
            if self.settings.newline == NEWLINE_CR:
                self.serial.write(b'\r')     # send CR
            elif self.settings.newline == NEWLINE_LF:
                self.serial.write(b'\n')     # send LF
            elif self.settings.newline == NEWLINE_CRLF:
                self.serial.write(b'\r\n')   # send CR+LF
        else:
            char = chr(code)
            if self.settings.echo:          # do echo if needed
                self.WriteText(char)
            self.serial.write(char.encode('UTF-8', 'replace'))         # send the character

    def WriteText(self, text):
        if self.settings.unprintable:
            text = ''.join([c if (c &gt;= ' ' and c != '\x7f') else chr(0x2400 + ord(c)) for c in text])
        self.text_ctrl_output.AppendText(text)

    def OnSerialRead(self, event):
        """Handle input from the serial port."""
        self.WriteText(event.data.decode('UTF-8', 'replace'))

    def ComPortThread(self):
        """\
        Thread that handles the incoming traffic. Does the basic input
        transformation (newlines) and generates an SerialRxEvent
        """
        while self.alive.isSet():
            b = self.serial.read(self.serial.in_waiting or 1)
            if b:
                # newline transformation
                if self.settings.newline == NEWLINE_CR:
                    b = b.replace(b'\r', b'\n')
                elif self.settings.newline == NEWLINE_LF:
                    pass
                elif self.settings.newline == NEWLINE_CRLF:
                    b = b.replace(b'\r\n', b'\n')
                event = SerialRxEvent(self.GetId(), b)
                self.GetEventHandler().AddPendingEvent(event)

    def OnRTS(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.rts = event.IsChecked()

    def OnDTR(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.dtr = event.Checked()

# end of class TerminalFrame


class MyApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_terminal = TerminalFrame(None, -1, "")
        self.SetTopWindow(frame_terminal)
        frame_terminal.Show(True)
        return 1

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;</summary><category term="wxpython"></category></entry><entry><title>yen - RGA 基因演算法</title><link href="http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-rga-ji-yin-yan-suan-fa.html</id><summary type="html">&lt;p&gt;RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算.&lt;/p&gt;


&lt;pre class="brush: python"&gt;
# https://github.com/flukeskywalker/PyRGA
# 原始程式為 Python2 修改為 Python3 格式
# 除了原先的最大化適應值外, 增加最小化方法設定
import numpy as np
import random
from math import *

# 請注意各代族群數必須為 4 的倍數
class GA: # popsize must be multiple of 4
    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
        self.EPSILON = 10e-6
        self.INFINITY = 10e6
        self.pop = []
        self.fits = []
        self.obj = obj
        self.dim = dim
        self.popsize = popsize
        self.ngen = ngen
        self.pc = pc
        self.pm = pm
        self.etac = etac
        self.etam = etam
        # min = 1 表最小化, min = -1 表最大化
        self.min = min
        self.RIGID = 0
        self.lowb = -self.INFINITY*np.ones(self.dim)
        self.highb = self.INFINITY*np.ones(self.dim)
        self.tourneylist = range(0, self.popsize)
        self.tourneysize = 2 # works for 2 for now
        self.bestmemyet = np.zeros(self.dim)
        # 若是求最大值
        if self.min == -1:
            self.bestfityet = -np.inf
        else:
        # 若是求最小值
            self.bestfityet = np.inf
        self.pop_init()

    def pop_init(self):
        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
        for member in self.pop:
            for i in range(self.dim):
                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
        self.fits = [self.obj(member) for member in self.pop]
        #self.pop_print()
        return

    def setbounds(self, lows, highs):
        for i in range(self.dim):
            self.lowb[i] = lows[i]
            self.highb[i] = highs[i]
        self.pop_init()
        return

    def run(self):
        for gen in range(self.ngen):
            print("Generation ", gen)
            self.pop = self.getnewpop()
            self.eval_pop()
            #self.pop_print()
        return [self.bestmemyet, self.bestfityet]

    def getnewpop(self):
        newpop = []
        #self.tourneylist = range(0, self.popsize)
        random.shuffle(list(self.tourneylist))
        self.tourneypos = 0
        for i in range(0, self.popsize, 2):
            [p1, p2] = self.getparents() #return parents, not just indices
            [c1, c2] = self.xover(p1, p2) #return children, not just indices
            c1 = self.mutate(c1)
            c2 = self.mutate(c2)
            newpop.append(c1)
            newpop.append(c2)
        return newpop

    def getparents(self):
        if (self.popsize - self.tourneypos) &lt; self.tourneysize:
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize

        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
        return [p1, p2]

    def xover(self, p1, p2): # Here p1 and p2 are pop members
        c1 = np.zeros_like(p1)
        c2 = np.zeros_like(p2)
        if random.random()&lt;=self.pc: # do crossover
            for i in range(p1.size):
                if random.random()&lt;0.5: # 50% variables crossover
                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                else:
                    [c1[i], c2[i]] = [p1[i], p2[i]]
        else:
            c1 = p1
            c2 = p2
        return [c1, c2]

    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
        if p1&gt;p2:
            p1, p2 = p2, p1 # p1 must be smaller
        mean = (p1+p2)*0.5
        diff = (p2-p1)
        dist = max(min(p1-low, high-p2), 0)
        if (self.RIGID and diff &gt; self.EPSILON):
            alpha = 1.0 + (2.0*dist/diff)
            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
            seed = umax*random.random()
        else:
            seed = random.random()
        beta = self.getbeta(seed)
        if (abs(diff*beta) &gt; self.INFINITY):
            beta = self.INFINITY/diff
        c2 = mean + beta*0.5*diff
        c1 = mean - beta*0.5*diff
        c1 = max(low, min(c1, high))
        c2 = max(low, min(c2, high))
        return [c1, c2]

    def getbeta(self, seed):
        if (1 - seed) &lt; self.EPSILON:
            seed = 1 - self.EPSILON
        seed = max(0.0, seed)
        if seed &lt; 0.5:
            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
        else:
            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
        return beta

    def getdelta(self, seed, delta_low, delta_high):
        if seed &gt;= 1.0 - (self.EPSILON/1e3):
            return delta_high
        if seed &lt;= (self.EPSILON/1e3):
            return delta_low
        if seed &lt;= 0.5:
            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
        else:
            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
        return delta

    def mutate(self, member):
        mut_member = np.zeros_like(member)
        for i in range(member.size):
            low = self.lowb[i]
            high = self.highb[i]
            if random.random() &lt;= self.pm: # pm is simply the prob of a variable to mutate
                if self.RIGID:
                    value = member[i]
                    delta_low = max((low-value)/(high-low), -1.0)
                    delta_high = min((high-value)/(high-low), 1.0)
                    if abs(delta_low)&lt;abs(delta_high):
                        delta_high = -delta_low
                    else:
                        delta_low = -delta_high
                else:
                    delta_low = -1.0
                    delta_high = 1.0
                seed = random.random()
                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                mut_member[i] = max(low, min(member[i] + delta, high))
            else:
                mut_member[i] = member[i]
        return mut_member

    def eval_pop(self):
        self.fits = [self.obj(member) for member in self.pop]
        # 若是最大化適應值題目者
        if self.min == -1:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmax(self.fits)
        else:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmin(self.fits)
        bestmember = self.pop[bestindex]
        bestfitness = self.fits[bestindex]
        # self.min = -1 for maximization, self.min = 1 for minimization
        if self.min == -1:
            # 若是在族群中的最佳適應值大於目前為止最佳的適應值
            if bestfitness &gt; self.bestfityet:
                # 則將此最大適應值指為目前為止最佳適應值
                self.bestfityet = bestfitness
                # 並且將最佳族群成員指向目前最佳成員
                self.bestmemyet = bestmember
        else:
            if bestfitness &lt; self.bestfityet:
                self.bestfityet = bestfitness
                self.bestmemyet = bestmember
        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)

    def pop_print(self):
        for i in range(self.popsize):
            print(self.pop[i], self.fits[i])
        return

# 若單獨存在則需導入 GA 所有方法
#import GA
#from GA import *
import numpy as np

def square(x):
    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
    term3 = term1+term2
    return term3

# 最大化體積題目
def volume(x):
    surface = 80.0
    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
    volume = x[0]*x[1]*z
    return volume


def miniex1(x):
    '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    term1 = 1.5 - x[0] + x[0]*x[1]
    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
    return term1*term1 + term2*term2 + term3*term3

def miniex2(x):
    '''Schaffer function #2. Minimium at (0,0), equal to 0
    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    return 0.5 + (pow(sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)

''' 開始四連桿運算
'''
class Point(object):
    '''Creates a point on a coordinate plane with values x and y.'''
    def __init__(self, x, y):
        '''Defines x and y variables'''
        self.x = x
        self.y = y

def triangletip_coord(x0, y0, R0, R1, x1, y1, localt):
    mech_loop = -1
    tip_coord = Point(0,0)
    if (localt &gt;= 0 and localt &lt; pi):
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    else:
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    return tip_coord

def distance(x0, y0, x1, y1):
    return sqrt(pow((x1-x0),2) + pow((y1-y0),2))

def rr(L1, dd, theta):
    return sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta))

# input_angles  = [] 也就是必須為 list 且各樹為 NUM_OF_POINTS
def mechanism(x0, y0, x1, y1, L1, L2, L3, L5, L6, input_angles):
    '''
    mechanism(0,0,10,0,5,20,10,10,10,input_angles)
    x0 = 0.0;
    y0 = 0.0;
    x1 = 10.0;
    y1 = 0.0;
    L1 = 5.0;
    L2 = 10;
    L3 = 10;
    L5 = 10;
    L6 = 10;
    '''
    link1_tip = Point(0,0)
    link2_tip = Point(0,0)
    output_points = list()
    degree = pi/180.
    NUM_OF_POINTS = 5
    dd_length = distance(x0, y0, x1, y1)
    # 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式
    angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));
    for i in range(NUM_OF_POINTS):
        angle = input_angles[i]*degree
        rr_length = rr(L1, dd_length, angle)
        # 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle)
        #print(angle, rr_length, link1_tip.x, link1_tip.y)
        # 第二次三角形疊代
        # 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length))
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2)
        # 第三次三角形疊代 (改為以 finaltip_coord() 取值, 而非第三次疊代
        '''
        triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        '''
        # 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points.append(finaltip_coord(link1_tip, link2_tip, L5, L6))
    return output_points

def finaltip_coord(tip1_coord, tip2_coord, r1, r2):
    tip3_coord = Point(0,0)
    length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2))
    length4 = sqrt(pow(r1,2) + pow(r2,2))
    theta3 = acos((tip2_coord.x - tip1_coord.x) / length3)
    theta4 = acos(r1/length4)
    tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4)
    tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4)
    return tip3_coord

# 誤差函式
def error_function(output_points, target_points):
    NUM_OF_POINTS = 5
    error = 0
    for i in range(NUM_OF_POINTS):
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y))
    return error

# 組成機構的變數個樹 9 + 通過點數所對應的角度值, 若通過 5 點則共有 14 個變數
#   mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);
def fourbar(x):
    PENALITY = 1000
    NUM_OF_POINTS = 10

    # x0 與 x1 點位於 -50 與 50 中間, 0, 1, 2, 3
    for i in range(4):
        if(x[i] &lt; -50 or x[i] &gt; 50):
            return PENALITY
    # 三個連桿值, 一定要為正, 4, 5, 6,
    for i in range(4, 7):
        if(x[i] &lt; 0 or x[i] &gt;50):
            return PENALITY

    # L5 L6 可以為 0 或負值, 7, 8 
    for i in range(7, 9):
        if(x[i] &lt; -50 or x[i] &gt; 50):
            return PENALITY

    # 角度值一定要大於 0
    for i in range(NUM_OF_POINTS):
        if(x[9+i] &lt; 0):
            return PENALITY

    result = 0
    target_points = list()
    output_points = list()
    input_angles = list()
    # 定義四連桿關鍵點所要通過的點
    p1 = Point(1, 1)
    p2 = Point(2, 2)
    p3 = Point(3, 3)
    p4 = Point(4, 4)
    p5 = Point(5, 5)
    p6 = Point(6, 6)
    p7 = Point(7, 7)
    p8 = Point(8, 8)
    p9 = Point(9, 9)
    p10 = Point(10, 10)
    target_points = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]
    for i in range(9, 9+NUM_OF_POINTS):
        input_angles.append(x[i])
    # 這裡要加入查驗各參數是否符合四連桿組成條件
    try:
        output_points = mechanism(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],input_angles)
    except:
        return PENALITY
    result = error_function(output_points, target_points)
    return result

#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
#ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# 請注意 popsize 必須為 4 的倍數
#ga=GA(miniex1, dim=2, popsize=12, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
ga=GA(fourbar, dim=19, popsize=120000, ngen=10000, pc=0.9, pm=0.5, etac=2, etam=100, min=1)
#ga.setbounds(np.zeros(10), 10*np.ones(10))
#ga.setbounds(-10*np.ones(10), 10*np.ones(10))
ga.setbounds(-50*np.ones(20), 50*np.ones(20))
#ga.pop_init()
print(ga.run())
&lt;/pre&gt;

&lt;p&gt;利用 C 與 Differential Evolution 解上述相同問題的原始碼:&lt;/p&gt;
&lt;pre class="brush: c"&gt;
    // 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散??

    /***************************************************************
    **                                                            **
    **        D I F F E R E N T I A L     E V O L U T I O N       **
    **                                                            **
    ** Program: de.c                                              **
    ** Version: 3.6                                               **
    **                                                            **
    ** Authors: Dr. Rainer Storn                                  **
    **          c/o ICSI, 1947 Center Street, Suite 600           **
    **          Berkeley, CA 94707                                **
    **          Tel.:   510-642-4274 (extension 192)              **
    **          Fax.:   510-643-7684                              **
    **          E-mail: storn@icsi.berkeley.edu                   **
    **          WWW: http://http.icsi.berkeley.edu/~storn/        **
    **          on leave from                                     **
    **          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
    **          D-81739 Muenchen, Germany                         **
    **          Tel:    636-40502                                 **
    **          Fax:    636-44577                                 **
    **          E-mail: rainer.storn@zfe.siemens.de               **
    **                                                            **
    **          Kenneth Price                                     **
    **          836 Owl Circle                                    **
    **          Vacaville, CA 95687                               **
    **          E-mail: kprice@solano.community.net               ** 
    **                                                            **
    ** This program implements some variants of Differential      **
    ** Evolution (DE) as described in part in the techreport      **
    ** tr-95-012.ps of ICSI. You can get this report either via   **
    ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
    ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
    ** A more extended version of tr-95-012.ps is submitted for   **
    ** publication in the Journal Evolutionary Computation.       ** 
    **                                                            **
    ** You may use this program for any purpose, give it to any   **
    ** person or change it according to your needs as long as you **
    ** are referring to Rainer Storn and Ken Price as the origi-  **
    ** nators of the the DE idea.                                 **
    ** If you have questions concerning DE feel free to contact   **
    ** us. We also will be happy to know about your experiences   **
    ** with DE and your suggestions of improvement.               **
    **                                                            **
    ***************************************************************/
    /**H*O*C**************************************************************
    **                                                                  **
    ** No.!Version! Date ! Request !    Modification           ! Author **
    ** ---+-------+------+---------+---------------------------+------- **
    **  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
    **    +      +       +         + included                  +        **
    **  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
    **  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
    **  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
    **  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
    **  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
    **    +      +       +         + initialization            +        **
    **  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
    **  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
    **  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
    **  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
    **  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
    **  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
    **  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
    **  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
    **                                                                  **
    ***H*O*C*E***********************************************************/

    #include "stdio.h"
    #include "stdlib.h"
    #include "math.h"
    #include "memory.h"
    #include &amp;lt;time.h&amp;gt;

    // 最大族群數, NP
    #define MAXPOP  5000
    // 最大向量維度, D
    #define MAXDIM  35
    #define MAXIMAPROBLEM 0
    #define PENALITY 1000

    /*------Constants for rnd_uni()--------------------------------------------*/

    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)

    // 與機構合成相關的常數定義
    #define PI 3.1415926
    #define degree PI/180.0
    #define mech_loop -1
    #define NUM_OF_POINTS 10

    /*------------------------Macros----------------------------------------*/

    /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                               /* works only for small  */
                                                               /* arrays, but is faster.*/

    /*------------------------Globals---------------------------------------*/

    long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
    double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
    double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];

    /*---------Function declarations----------------------------------------*/

    void  assignd(int D, double a[], double b[]);
    double rnd_uni(long *idum);    /* uniform pseudo random number generator */
    double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */

    // 與機構合成相關的函式宣告
    double distance(double x0, double y0, double x1, double y1);
    double rr(double L1, double dd, double theta);
    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt);
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);

    /*---------Function definitions-----------------------------------------*/
    // 指定向量 b 為 a
    void  assignd(int D, double a[], double b[])
    /**C*F****************************************************************
    **                                                                  **
    ** Assigns D-dimensional vector b to vector a.                      **
    ** You might encounter problems with the macro ASSIGND on some      **
    ** machines. If yes, better use this function although it's slower. **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
       int j;
       for (j=0; j&amp;lt;D; j++)
       {
          a[j] = b[j];
       }
    }

    // 產生 0 ~ 1 間的亂數
    double rnd_uni(long *idum)
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :rnd_uni()                                        **
    ** LONG_NAME      :random_uniform                                   **
    ** AUTHOR         :(see below)                                      **
    **                                                                  **
    ** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
    **                 dom number in the interval [0,1]. For further    **
    **                 reference see Press, W.H. et alii, Numerical     **
    **                 Recipes in C, Cambridge University Press, 1992.  **
    **                                                                  **
    ** FUNCTIONS      :none                                             **
    **                                                                  **
    ** GLOBALS        :none                                             **
    **                                                                  **
    ** PARAMETERS     :*idum    serves as a seed value                  **
    **                                                                  **
    ** PRECONDITIONS  :*idum must be negative on the first call.        **
    **                                                                  **
    ** POSTCONDITIONS :*idum will be changed                            **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
      long j;
      long k;
      static long idum2=123456789;
      static long iy=0;
      static long iv[NTAB];
      double temp;

      if (*idum &amp;lt;= 0)
      {
        if (-(*idum) &amp;lt; 1) *idum=1;
        else *idum = -(*idum);
        idum2=(*idum);
        for (j=NTAB+7;j&amp;gt;=0;j--)
        {
          k=(*idum)/IQ1;
          *idum=IA1*(*idum-k*IQ1)-k*IR1;
          if (*idum &amp;lt; 0) *idum += IM1;
          if (j &amp;lt; NTAB) iv[j] = *idum;
        }
        iy=iv[0];
      }
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &amp;lt; 0) *idum += IM1;
      k=idum2/IQ2;
      idum2=IA2*(idum2-k*IQ2)-k*IR2;
      if (idum2 &amp;lt; 0) idum2 += IM2;
      j=iy/NDIV;
      iy=iv[j]-idum2;
      iv[j] = *idum;
      if (iy &amp;lt; 1) iy += IMM1;
      if ((temp=AM*iy) &amp;gt; RNMX) return RNMX;
      else return temp;

    }/*------End of rnd_uni()--------------------------*/

    // 將上下限轉為全域變數
    double inibound_h;      /* upper parameter bound              */
    double inibound_l;      /* lower parameter bound              */
    // 與機構合成相關的全域變數
    // 宣告一個座標結構
    struct Coord {
        double x;
        double y;
      // 這裡保留 double z;
    };

    main(int argc, char *argv[])
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :main()                                           **
    ** LONG_NAME      :main program                                     **
    ** AUTHOR         :Rainer Storn, Kenneth Price                      **
    **                                                                  **
    ** DESCRIPTION    :driver program for differential evolution.       **
    **                                                                  **
    ** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
    **                 fopen(), fclose(), fscanf().                     **
    **                                                                  **
    ** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
    **                                                                  **
    ** PARAMETERS     :argc            #arguments = 3                   **
    **                 argv            pointer to argument strings      **
    **                                                                  **
    ** PRECONDITIONS  :main must be called with three parameters        **
    **                 e.g. like de1 &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;, if     **
    **                 the executable file is called de1.               **
    **                 The input file must contain valid inputs accor-  **
    **                 ding to the fscanf() section of main().          **
    **                                                                  **
    ** POSTCONDITIONS :main() produces consecutive console outputs and  **
    **                 writes the final results in an output file if    **
    **                 the program terminates without an error.         **
    **                                                                  **
    ***C*F*E*************************************************************/

    {
       char  chr;             /* y/n choice variable                */
       char  *strat[] =       /* strategy-indicator                 */
       {
                "",
                "DE/best/1/exp",
                "DE/rand/1/exp",
                "DE/rand-to-best/1/exp",
                "DE/best/2/exp",
                "DE/rand/2/exp",
                "DE/best/1/bin",
                "DE/rand/1/bin",
                "DE/rand-to-best/1/bin",
                "DE/best/2/bin",
                "DE/rand/2/bin"
       };

       int   i, j, L, n;      /* counting variables                 */
       int   r1, r2, r3, r4;  /* placeholders for random indexes    */
       int   r5;              /* placeholders for random indexes    */
       int   D;               /* Dimension of parameter vector      */
       int   NP;              /* number of population members       */
       int   imin;            /* index to member with lowest energy */
       int   refresh;         /* refresh rate of screen output      */
       int   strategy;        /* choice parameter for screen output */
       int   gen, genmax, seed;   

       long  nfeval;          /* number of function evaluations     */

       double trial_cost;      /* buffer variable                    */
       // 將上下限轉為全域變數, 可能要根據各變數加以設定
       //double inibound_h;      /* upper parameter bound              */
       //double inibound_l;      /* lower parameter bound              */
       double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
       double cost[MAXPOP];    /* obj. funct. values                 */
       double cvar;            /* computes the cost variance         */
       double cmean;           /* mean cost                          */
       double F,CR;            /* control variables of DE            */
       double cmin;            /* help variables                     */

       FILE  *fpin_ptr;
       FILE  *fpout_ptr;

    // 計算執行過程所需時間起點, 需要導入 time.h
      clock_t start = clock();

    /*------Initializations----------------------------*/

     //if (argc != 3)                                 /* number of arguments */
     //{
        //printf("\nUsage : de &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;\n");
        //exit(1);
     //}

    // 將結果寫入 out.dat
     fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                              /* to see whether it already exists */
     /*
     if ( fpout_ptr != NULL )
     {
        printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
        printf("want to overwrite it, \nanything else if you want to exit.\n");
        chr = (char)getchar();
        if ((chr != 'y') &amp;amp;&amp;amp; (chr != 'Y'))
        {
          exit(1);
        }
        fclose(fpout_ptr);
     }
    */

    /*-----Read input data------------------------------------------------*/

     //fpin_ptr   = fopen(argv[1],"r");
    /*
     if (fpin_ptr == NULL)
     {
        printf("\nCannot open input file\n");
        exit(1);
     }*/

     //fscanf(fpin_ptr,"%d",&amp;amp;strategy);       /*---choice of strategy-----------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;genmax);         /*---maximum number of generations------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;refresh);        /*---output refresh cycle---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;D);              /*---number of parameters---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;NP);             /*---population size.-------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_h);    /*---upper parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_l);    /*---lower parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;F);             /*---weight factor----------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;CR);            /*---crossing over factor---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;seed);           /*---random seed------------------------*/
    // 目前已經採用 strategy 3 可以得到最佳結果
      strategy = 3;
      genmax = 2000;
      refresh = 100;
      // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
      D = 19;
      NP = 200;
      inibound_h = 50.;
      inibound_l = 0.;
    /*得到最佳解
      F = 0.85;
    CR 必須介於 0 to 1. 之間
      CR = 1.;
    */
      F = 0.85;
      CR = 1.;
      seed = 3;

     //fclose(fpin_ptr);

    /*-----Checking input variables for proper range----------------------------*/

      if (D &amp;gt; MAXDIM)
      {
         printf("\nError! D=%d &amp;gt; MAXDIM=%d\n",D,MAXDIM);
         exit(1);
      }
      if (D &amp;lt;= 0)
      {
         printf("\nError! D=%d, should be &amp;gt; 0\n",D);
         exit(1);
      }
      if (NP &amp;gt; MAXPOP)
      {
         printf("\nError! NP=%d &amp;gt; MAXPOP=%d\n",NP,MAXPOP);
         exit(1);
      }
      if (NP &amp;lt;= 0)
      {
         printf("\nError! NP=%d, should be &amp;gt; 0\n",NP);
         exit(1);
      }
      if ((CR &amp;lt; 0) || (CR &amp;gt; 1.0))
      {
         printf("\nError! CR=%f, should be ex [0,1]\n",CR);
         exit(1);
      }
      if (seed &amp;lt;= 0)
      {
         printf("\nError! seed=%d, should be &amp;gt; 0\n",seed);
         exit(1);
      }
      if (refresh &amp;lt;= 0)
      {
         printf("\nError! refresh=%d, should be &amp;gt; 0\n",refresh);
         exit(1);
      }
      if (genmax &amp;lt;= 0)
      {
         printf("\nError! genmax=%d, should be &amp;gt; 0\n",genmax);
         exit(1);
      }
      if ((strategy &amp;lt; 0) || (strategy &amp;gt; 10))
      {
         printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
         exit(1);
      }
      if (inibound_h &amp;lt; inibound_l)
      {
         printf("\nError! inibound_h=%f &amp;lt; inibound_l=%f\n",inibound_h, inibound_l);
         exit(1);
      }


    /*-----Open output file-----------------------------------------------*/

       //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */

       //if (fpout_ptr == NULL)
       //{
          //printf("\nCannot open output file\n");
          //exit(1);
       //}


    /*-----Initialize random number generator-----------------------------*/

     rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
     nfeval       =  0;  /* reset number of function evaluations */



    /*------Initialization------------------------------------------------*/
    /*------Right now this part is kept fairly simple and just generates--*/
    /*------random numbers in the range [-initfac, +initfac]. You might---*/
    /*------want to extend the init part such that you can initialize-----*/
    /*------each parameter separately.------------------------------------*/

       for (i=0; i&amp;lt;NP; i++)
       {
          for (j=0; j&amp;lt;D; j++) /* spread initial population members */
          {
            c[i][j] = inibound_l + rnd_uni(&amp;amp;rnd_uni_init)*(inibound_h - inibound_l);
          }
          cost[i] = evaluate(D,c[i],&amp;amp;nfeval); /* obj. funct. value */
       }
       cmin = cost[0];
       imin = 0;
       for (i=1; i&amp;lt;NP; i++)
       {
         if(MAXIMAPROBLEM == 1)
         {
           // 改為最大化
            if (cost[i]&amp;gt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
          else
          {
            // 最小化問題
            if (cost[i]&amp;lt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
       }

       assignd(D,best,c[imin]);            /* save best member ever          */
       assignd(D,bestit,c[imin]);          /* save best member of generation */

       pold = &amp;amp;c; /* old population (generation G)   */
       pnew = &amp;amp;d; /* new population (generation G+1) */

    /*=======================================================================*/
    /*=========Iteration loop================================================*/
    /*=======================================================================*/

       gen = 0;                          /* generation counter reset */
       while ((gen &amp;lt; genmax) /*&amp;amp;&amp;amp; (kbhit() == 0)*/) /* remove comments if conio.h */
       {                                            /* is accepted by compiler    */
          gen++;
          imin = 0;

          for (i=0; i&amp;lt;NP; i++)         /* Start of loop through ensemble  */
          {
         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 2 !!!     */
           r1 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while(r1==i);            

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 3 !!!     */
           r2 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r2==i) || (r2==r1));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 4 !!!     */
           r3 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r3==i) || (r3==r1) || (r3==r2));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 5 !!!     */
           r4 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 6 !!!     */
           r5 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));


    /*=======Choice of strategy===============================================================*/
    /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
    /*=======DE :  stands for Differential Evolution==========================================*/
    /*=======x  :  a string which denotes the vector to be perturbed==========================*/
    /*=======y  :  number of difference vectors taken for perturbation of x===================*/
    /*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
    /*                                                                                        */
    /*=======There are some simple rules which are worth following:===========================*/
    /*=======1)  F is usually between 0.5 and 1 (in rare cases &amp;gt; 1)===========================*/
    /*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
    /*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
    /*           happens.                                                                     */
    /*=======4)  If you increase NP, F usually has to be decreased============================*/
    /*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/


    /*=======EXPONENTIAL CROSSOVER============================================================*/

    /*-------DE/best/1/exp--------------------------------------------------------------------*/
    /*-------Our oldest strategy but still not bad. However, we have found several------------*/
    /*-------optimization problems where misconvergence occurs.-------------------------------*/
         if (strategy == 1) /* strategy DE0 (not in our paper) */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/1/exp-------------------------------------------------------------------*/
    /*-------This is one of my favourite strategies. It works especially well when the-------*/
    /*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
    /*-------as a first guess.---------------------------------------------------------------*/
         else if (strategy == 2) /* strategy DE1 in the techreport */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
    /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
    /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
    /*-------should play around with all three control variables.----------------------------*/
         else if (strategy == 3) /* similiar to DE2 but generally better */
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                       
             tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
         else if (strategy == 4)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
         else if (strategy == 5)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }

    /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/

    /*-------DE/best/1/bin--------------------------------------------------------------------*/
         else if (strategy == 6) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/1/bin-------------------------------------------------------------------*/
         else if (strategy == 7) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
         else if (strategy == 8) 
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/best/2/bin--------------------------------------------------------------------*/
         else if (strategy == 9)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/2/bin--------------------------------------------------------------------*/
         else
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }


    /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/

         trial_cost = evaluate(D,tmp,&amp;amp;nfeval);  /* Evaluate new vector in tmp[] */
       if(MAXIMAPROBLEM == 1)
       {
        // 改為最大化
           if (trial_cost &amp;gt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;gt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }
        else
        {
              // 最小化問題
           if (trial_cost &amp;lt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;lt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }

          }   /* End mutation loop through pop. */

          assignd(D,bestit,best);  /* Save best population member of current iteration */

          /* swap population arrays. New generation becomes old one */

          pswap = pold;
          pold  = pnew;
          pnew  = pswap;

    /*----Compute the energy variance (just for monitoring purposes)-----------*/

          cmean = 0.;          /* compute the mean value first */
          for (j=0; j&amp;lt;NP; j++)
          {
             cmean += cost[j];
          }
          cmean = cmean/NP;

          cvar = 0.;           /* now the variance              */
          for (j=0; j&amp;lt;NP; j++)
          {
             cvar += (cost[j] - cmean)*(cost[j] - cmean);
          }
          cvar = cvar/(NP-1);


    /*----Output part----------------------------------------------------------*/

          if (gen%refresh==1)   /* display after every refresh generations */
          { /* ABORT works only if conio.h is accepted by your compiler */
        printf("\n\n                         PRESS ANY KEY TO ABORT"); 
        printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);

        for (j=0;j&amp;lt;D;j++)
        {
          printf("\n best[%d]=%-15.10g",j,best[j]);
        }
        printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
        printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
                   NP,F,CR,cvar);
          }

          fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
       }
    /*=======================================================================*/
    /*=========End of iteration loop=========================================*/
    /*=======================================================================*/

    /*-------Final output in file-------------------------------------------*/


       fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);

       for (j=0;j&amp;lt;D;j++)
       {
         fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
       }
       fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
       fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
               NP,F,CR,cvar); 

      fclose(fpout_ptr);

      /* Code you want timed here */
      printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
       return(0);
    }

    /*-----------End of main()------------------------------------------*/

    // 適應函式 fittness function (cost function)
    double evaluate(int D, double tmp[], long *nfeval)
    {
      // 先處理通過 5 個點的四連桿問題
      // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
      // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
      // L1 為第一桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[4]
      // L2 為第二桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[5]
      // L3 為第三桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[6]
      // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
      // L5, L6 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
      // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
      // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
      // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
      // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
      /* void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
      struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
      double input_angles[NUM_OF_POINTS], result;
      int i;

      (*nfeval)++;

      target_points[0].x = 1.0;
      target_points[0].y = 1.0;

      target_points[1].x = 2.0;
      target_points[1].y = 2.0;

      target_points[2].x = 3.0;
      target_points[2].y = 3.0;

      target_points[3].x = 4.0;
      target_points[3].y = 4.0;

      target_points[4].x = 5.0;
      target_points[4].y = 5.0;

      target_points[5].x = 6.0;
      target_points[5].y = 6.0;

      target_points[6].x = 7.0;
      target_points[6].y = 7.0;

      target_points[7].x = 8.0;
      target_points[7].y = 8.0;

      target_points[8].x = 9.0;
      target_points[8].y = 9.0;

      target_points[9].x = 10.0;
      target_points[9].y = 10.0;

      // 輸入角度值與 tmp[] 的設定
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        input_angles[i] = tmp[i + 9];
      }
      // 呼叫 mechanism() 以便計算 output_points[]
      mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);

      // for debug
      /*
      if(*nfeval%3000 == 0)
      {
        for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
        {
          printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
        }
        printf("#####################################\n");
      }
      */
      // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
      result = error_function(output_points, target_points);
      // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result

      // x0 與 x1 點位於 -500 與 500 中間
        for(i = 0; i &amp;lt; 4; i++)
      {
        if(tmp[i] &amp;lt; -50 || tmp[i] &amp;gt; 50){
          return PENALITY;
        }
      }

      // 三個連桿值, 一定要為正
        for(i = 4; i &amp;lt; 7; i++)
      {
        if(tmp[i] &amp;lt; 0 || tmp[i] &amp;gt; 50){
          return PENALITY;
        }
      }

        // L5 L6 可以為 0 或負值
        for(i = 7; i &amp;lt; 9; i++)
      {
        if(tmp[i] &amp;lt; -50 || tmp[i] &amp;gt; 50){
          return PENALITY;
        }
      }

      // 角度值一定要大於 0

      for(i = 1; i &amp;lt;= NUM_OF_POINTS; i++)
      {
        if((tmp[D-i] &amp;lt; 0)){
          return PENALITY;
        }
      }

      return result;

      /*
       double result=0, surface = 80.0, z, volume, penality;
       (*nfeval)++;
       z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
       volume = tmp[0]*tmp[1]*z;

      if(volume &amp;lt;= 0){
        return PENALITY;
      }

      if((tmp[0] &amp;lt;= inibound_l)|| (tmp[0] &amp;gt;inibound_h)){
        return PENALITY;
      }

      if((tmp[1] &amp;lt;= inibound_l) || (tmp[1] &amp;gt;inibound_h)){
        return PENALITY;
      }
      // volume must &amp;gt;0 and max volume
      // 目前為最小化問題
       return 1+1/(volume*volume);
       */
    }

    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
    {
        struct Coord tip_coord;

        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
        }
        else
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
        pow(x1-x0,2))/2)+x0;
        }

    // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    // 利用 sqrtt 居中進行代換所得到的式子
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;

        }
        else
        {
            tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
        }

      return tip_coord;
    }

    double distance(double x0, double y0, double x1, double y1)
    {
        double distance_value;
        distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
        return distance_value;
    }

    double rr(double L1, double dd, double theta)
    {
        double rr_value;
        rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta));
        return rr_value;
    }

    // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
    {
      // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
      // 以下為可能的處理變數宣告
      // 這裡希望能夠定義一個 struct 來處理座標點
      double rr_length, dd_length, angle;
      struct Coord link1_tip, link2_tip, triangle_tip;
        double angle2, angle3;
      int i;

      // 開始進行三角形頂點座標的計算
      // 以下變數由每一個體向量提供
      /*
        x0 = 0.0;
        y0 = 0.0;
        x1 = 10.0;
        y1 = 0.0;
        L1 = 5.0;
        L2 = 20;
        L3 = 10;
        L5 = 10;
        L6 = 10;
      */
      dd_length = distance(x0, y0, x1, y1);
      /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
      angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));

      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        // 先建立第一點座標, 即 i=0 者
        // i=0;
        // angle = i*degree;
        /*
        // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
        if(i &amp;gt; 0)
        {
          input_angles[i] = input_angles[i] + input_angles[i-1];
        }
        */
        angle = input_angles[i]*degree;
        rr_length = rr(L1, dd_length, angle);
        // 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
        // 第二次三角形疊代
        /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
        // 第三次三角形疊代
        //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
      }
    }

    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
    {
      double error = 0.0;
      int i;
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
      }
      return error;
    }

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
    {
      struct Coord tip3_coord;
      double theta3, theta4, length3, length4;
      length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
      length4 = sqrt(pow(r1,2) + pow(r2,2));  
      theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
      theta4 = acos(r1 / length4);
      tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
      tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);

      return tip3_coord;
    }
&lt;/pre&gt;

&lt;p&gt;為了要讓 C 程式碼可以在 Pelican 網誌 Markdown 格式編輯模式下能夠與 highlight 套件結合, 首先程式碼中的所有大於與小於符號必須轉為 html special charactor 之外, 還要全部內縮, 否則內容將會在 Pelican 轉換過程中被視為 html 而自動加入錯誤的標註符號.&lt;/p&gt;
&lt;p&gt;以下則為 de 25 點四連桿尺寸合成參考程式:&lt;/p&gt;
&lt;pre class="brush: c"&gt;
    /***************************************************************
    **                                                            **
    **        D I F F E R E N T I A L     E V O L U T I O N       **
    **                                                            **
    ** Program: de.c                                              **
    ** Version: 3.6                                               **
    **                                                            **
    ** Authors: Dr. Rainer Storn                                  **
    **          c/o ICSI, 1947 Center Street, Suite 600           **
    **          Berkeley, CA 94707                                **
    **          Tel.:   510-642-4274 (extension 192)              **
    **          Fax.:   510-643-7684                              **
    **          E-mail: storn@icsi.berkeley.edu                   **
    **          WWW: http://http.icsi.berkeley.edu/~storn/        **
    **          on leave from                                     **
    **          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
    **          D-81739 Muenchen, Germany                         **
    **          Tel:    636-40502                                 **
    **          Fax:    636-44577                                 **
    **          E-mail: rainer.storn@zfe.siemens.de               **
    **                                                            **
    **          Kenneth Price                                     **
    **          836 Owl Circle                                    **
    **          Vacaville, CA 95687                               **
    **          E-mail: kprice@solano.community.net               ** 
    **                                                            **
    ** This program implements some variants of Differential      **
    ** Evolution (DE) as described in part in the techreport      **
    ** tr-95-012.ps of ICSI. You can get this report either via   **
    ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
    ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
    ** A more extended version of tr-95-012.ps is submitted for   **
    ** publication in the Journal Evolutionary Computation.       ** 
    **                                                            **
    ** You may use this program for any purpose, give it to any   **
    ** person or change it according to your needs as long as you **
    ** are referring to Rainer Storn and Ken Price as the origi-  **
    ** nators of the the DE idea.                                 **
    ** If you have questions concerning DE feel free to contact   **
    ** us. We also will be happy to know about your experiences   **
    ** with DE and your suggestions of improvement.               **
    **                                                            **
    ***************************************************************/
    /**H*O*C**************************************************************
    **                                                                  **
    ** No.!Version! Date ! Request !    Modification           ! Author **
    ** ---+-------+------+---------+---------------------------+------- **
    **  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
    **    +      +       +         + included                  +        **
    **  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
    **  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
    **  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
    **  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
    **  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
    **    +      +       +         + initialization            +        **
    **  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
    **  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
    **  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
    **  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
    **  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
    **  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
    **  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
    **  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
    **                                                                  **
    ***H*O*C*E***********************************************************/

    #include "stdio.h"
    #include "stdlib.h"
    #include "math.h"
    #include "memory.h"
    #include &amp;lt;time.h&amp;gt;

    // 最大族群數, NP
    #define MAXPOP  5000
    // 最大向量維度, D
    #define MAXDIM  60
    // 1 為最大化問題, 0 為最小化問題
    #define MAXIMAPROBLEM 0
    // 可能要配合最大或最小化進行變號
    #define PENALITY 1.0E20

    /*------Constants for rnd_uni()--------------------------------------------*/

    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)

    // 與機構合成相關的常數定義
    #define PI 3.1415926
    #define degree PI/180.0
    #define mech_loop -1
    #define NUM_OF_POINTS 25

    /*------------------------Macros----------------------------------------*/

    /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                               /* works only for small  */
                                                               /* arrays, but is faster.*/

    /*------------------------Globals---------------------------------------*/

    long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
    double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
    double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];

    /*---------Function declarations----------------------------------------*/

    void  assignd(int D, double a[], double b[]);
    double rnd_uni(long *idum);    /* uniform pseudo random number generator */
    double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */

    // 與機構合成相關的函式宣告
    double distance(double x0, double y0, double x1, double y1);
    double rr(double L1, double dd, double theta);
    struct Coord triangletip_coord(double x0, double y0, double R0, double R1, double x1, double y1, double localt);
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);
    // 用來利用 tip1 與 tip2 的座標, 以及 r1, r2 求最後的三角形頂點座標
    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);

    /*---------Function definitions-----------------------------------------*/
    // 指定向量 b 為 a
    void  assignd(int D, double a[], double b[])
    /**C*F****************************************************************
    **                                                                  **
    ** Assigns D-dimensional vector b to vector a.                      **
    ** You might encounter problems with the macro ASSIGND on some      **
    ** machines. If yes, better use this function although it's slower. **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
       int j;
       for (j=0; j&amp;lt;D; j++)
       {
          a[j] = b[j];
       }
    }

    // 產生 0 ~ 1 間的亂數
    double rnd_uni(long *idum)
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :rnd_uni()                                        **
    ** LONG_NAME      :random_uniform                                   **
    ** AUTHOR         :(see below)                                      **
    **                                                                  **
    ** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
    **                 dom number in the interval [0,1]. For further    **
    **                 reference see Press, W.H. et alii, Numerical     **
    **                 Recipes in C, Cambridge University Press, 1992.  **
    **                                                                  **
    ** FUNCTIONS      :none                                             **
    **                                                                  **
    ** GLOBALS        :none                                             **
    **                                                                  **
    ** PARAMETERS     :*idum    serves as a seed value                  **
    **                                                                  **
    ** PRECONDITIONS  :*idum must be negative on the first call.        **
    **                                                                  **
    ** POSTCONDITIONS :*idum will be changed                            **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
      long j;
      long k;
      static long idum2=123456789;
      static long iy=0;
      static long iv[NTAB];
      double temp;

      if (*idum &amp;lt;= 0)
      {
        if (-(*idum) &amp;lt; 1) *idum=1;
        else *idum = -(*idum);
        idum2=(*idum);
        for (j=NTAB+7;j&amp;gt;=0;j--)
        {
          k=(*idum)/IQ1;
          *idum=IA1*(*idum-k*IQ1)-k*IR1;
          if (*idum &amp;lt; 0) *idum += IM1;
          if (j &amp;lt; NTAB) iv[j] = *idum;
        }
        iy=iv[0];
      }
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &amp;lt; 0) *idum += IM1;
      k=idum2/IQ2;
      idum2=IA2*(idum2-k*IQ2)-k*IR2;
      if (idum2 &amp;lt; 0) idum2 += IM2;
      j=iy/NDIV;
      iy=iv[j]-idum2;
      iv[j] = *idum;
      if (iy &amp;lt; 1) iy += IMM1;
      if ((temp=AM*iy) &amp;gt; RNMX) return RNMX;
      else return temp;

    }/*------End of rnd_uni()--------------------------*/

    // 將上下限轉為全域變數
    double inibound_h;      /* upper parameter bound              */
    double inibound_l;      /* lower parameter bound              */
    // 與機構合成相關的全域變數
    // 宣告一個座標結構
    struct Coord {
        double x;
        double y;
      // 這裡保留 double z;
    };

    int main(int argc, char *argv[])
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :main()                                           **
    ** LONG_NAME      :main program                                     **
    ** AUTHOR         :Rainer Storn, Kenneth Price                      **
    **                                                                  **
    ** DESCRIPTION    :driver program for differential evolution.       **
    **                                                                  **
    ** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
    **                 fopen(), fclose(), fscanf().                     **
    **                                                                  **
    ** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
    **                                                                  **
    ** PARAMETERS     :argc            #arguments = 3                   **
    **                 argv            pointer to argument strings      **
    **                                                                  **
    ** PRECONDITIONS  :main must be called with three parameters        **
    **                 e.g. like de1 &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;, if     **
    **                 the executable file is called de1.               **
    **                 The input file must contain valid inputs accor-  **
    **                 ding to the fscanf() section of main().          **
    **                                                                  **
    ** POSTCONDITIONS :main() produces consecutive console outputs and  **
    **                 writes the final results in an output file if    **
    **                 the program terminates without an error.         **
    **                                                                  **
    ***C*F*E*************************************************************/

    {
       char  chr;             /* y/n choice variable                */
       char  *strat[] =       /* strategy-indicator                 */
       {
                "",
                "DE/best/1/exp",
                "DE/rand/1/exp",
                "DE/rand-to-best/1/exp",
                "DE/best/2/exp",
                "DE/rand/2/exp",
                "DE/best/1/bin",
                "DE/rand/1/bin",
                "DE/rand-to-best/1/bin",
                "DE/best/2/bin",
                "DE/rand/2/bin"
       };

       int   i, j, L, n;      /* counting variables                 */
       int   r1, r2, r3, r4;  /* placeholders for random indexes    */
       int   r5;              /* placeholders for random indexes    */
       int   D;               /* Dimension of parameter vector      */
       int   NP;              /* number of population members       */
       int   imin;            /* index to member with lowest energy */
       int   refresh;         /* refresh rate of screen output      */
       int   strategy;        /* choice parameter for screen output */
       int   gen, genmax, seed;   

       long  nfeval;          /* number of function evaluations     */

       double trial_cost;      /* buffer variable   */

       // 將上下限轉為全域變數, 可能要根據各變數加以設定
       //double inibound_h;      /* upper parameter bound              */
       //double inibound_l;      /* lower parameter bound              */
       double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
       double cost[MAXPOP];    /* obj. funct. values                 */
       double cvar;            /* computes the cost variance         */
       double cmean;           /* mean cost                          */
       double F,CR;            /* control variables of DE            */
       double cmin;            /* help variables                     */

       FILE  *fpin_ptr;
       FILE  *fpout_ptr;

    // 計算執行過程所需時間起點, 需要導入 time.h
      clock_t start = clock();

    /*------Initializations----------------------------*/

     //if (argc != 3)                                 /* number of arguments */
     //{
        //printf("\nUsage : de &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;\n");
        //exit(1);
     //}

    // 將結果寫入 out.dat
     fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                              /* to see whether it already exists */
     /*
     if ( fpout_ptr != NULL )
     {
        printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
        printf("want to overwrite it, \nanything else if you want to exit.\n");
        chr = (char)getchar();
        if ((chr != 'y') &amp;amp;&amp;amp; (chr != 'Y'))
        {
          exit(1);
        }
        fclose(fpout_ptr);
     }
    */

    /*-----Read input data------------------------------------------------*/

     //fpin_ptr   = fopen(argv[1],"r");
    /*
     if (fpin_ptr == NULL)
     {
        printf("\nCannot open input file\n");
        exit(1);
     }*/

     //fscanf(fpin_ptr,"%d",&amp;amp;strategy);       /*---choice of strategy-----------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;genmax);         /*---maximum number of generations------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;refresh);        /*---output refresh cycle---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;D);              /*---number of parameters---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;NP);             /*---population size.-------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_h);    /*---upper parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_l);    /*---lower parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;F);             /*---weight factor----------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;CR);            /*---crossing over factor---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;seed);           /*---random seed------------------------*/
      strategy = 3;
      genmax = 200000;
      // refresh 為每幾筆運算後進行資料列印
      refresh = 100;
      // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 25 (NUM_OF_POINTS) 個通過點角度值
      // tmp[0~8] 為機構尺寸, tmp[9~33] 為通過點角度值
      D = 9 + NUM_OF_POINTS;
      NP = 200;
      // 機構變數值上限
      inibound_h = 50.;
      // 機構變數值下限
      inibound_l = 0.;
      // for strategy 1, F=0.9, CR = 1.
      // for strategy 2 F=0.7, CR=0.5
      // 一個小時得到 9.7 的誤差
      // 25 點的題目, 若 penality 只取 1000 則 F = 0.7 似乎為 最大 bound for strategy 1, CR = 1.
      F = 0.85;
      CR = 0.7;
      seed = 3;

     //fclose(fpin_ptr);

    /*-----Checking input variables for proper range----------------------------*/

      if (D &amp;gt; MAXDIM)
      {
         printf("\nError! D=%d &amp;gt; MAXDIM=%d\n",D,MAXDIM);
         exit(1);
      }
      if (D &amp;lt;= 0)
      {
         printf("\nError! D=%d, should be &amp;gt; 0\n",D);
         exit(1);
      }
      if (NP &amp;gt; MAXPOP)
      {
         printf("\nError! NP=%d &amp;gt; MAXPOP=%d\n",NP,MAXPOP);
         exit(1);
      }
      if (NP &amp;lt;= 0)
      {
         printf("\nError! NP=%d, should be &amp;gt; 0\n",NP);
         exit(1);
      }
      if ((CR &amp;lt; 0) || (CR &amp;gt; 1.0))
      {
         printf("\nError! CR=%f, should be ex [0,1]\n",CR);
         exit(1);
      }
      if (seed &amp;lt;= 0)
      {
         printf("\nError! seed=%d, should be &amp;gt; 0\n",seed);
         exit(1);
      }
      if (refresh &amp;lt;= 0)
      {
         printf("\nError! refresh=%d, should be &amp;gt; 0\n",refresh);
         exit(1);
      }
      if (genmax &amp;lt;= 0)
      {
         printf("\nError! genmax=%d, should be &amp;gt; 0\n",genmax);
         exit(1);
      }
      if ((strategy &amp;lt; 0) || (strategy &amp;gt; 10))
      {
         printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
         exit(1);
      }
      if (inibound_h &amp;lt; inibound_l)
      {
         printf("\nError! inibound_h=%f &amp;lt; inibound_l=%f\n",inibound_h, inibound_l);
         exit(1);
      }


    /*-----Open output file-----------------------------------------------*/

       //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */

       //if (fpout_ptr == NULL)
       //{
          //printf("\nCannot open output file\n");
          //exit(1);
       //}


    /*-----Initialize random number generator-----------------------------*/

     rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
     nfeval       =  0;  /* reset number of function evaluations */



    /*------Initialization------------------------------------------------*/
    /*------Right now this part is kept fairly simple and just generates--*/
    /*------random numbers in the range [-initfac, +initfac]. You might---*/
    /*------want to extend the init part such that you can initialize-----*/
    /*------each parameter separately.------------------------------------*/

       for (i=0; i&amp;lt;NP; i++)
       {
          for (j=0; j&amp;lt;D; j++) /* spread initial population members */
          {
            c[i][j] = inibound_l + rnd_uni(&amp;amp;rnd_uni_init)*(inibound_h - inibound_l);
          }
          cost[i] = evaluate(D,c[i],&amp;amp;nfeval); /* obj. funct. value */
       }
       cmin = cost[0];
       imin = 0;
       for (i=1; i&amp;lt;NP; i++)
       {
         if(MAXIMAPROBLEM == 1)
         {
           // 最大化問題
            if (cost[i]&amp;gt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
          else
          {
            // 最小化問題
            if (cost[i]&amp;lt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
       }

       assignd(D,best,c[imin]);            /* save best member ever          */
       assignd(D,bestit,c[imin]);          /* save best member of generation */

       pold = &amp;amp;c; /* old population (generation G)   */
       pnew = &amp;amp;d; /* new population (generation G+1) */

    /*=======================================================================*/
    /*=========Iteration loop================================================*/
    /*=======================================================================*/

       gen = 0;                          /* generation counter reset */
       while ((gen &amp;lt; genmax) /*&amp;amp;&amp;amp; (kbhit() == 0)*/) /* remove comments if conio.h */
       {                                            /* is accepted by compiler    */
          gen++;
          imin = 0;

          for (i=0; i&amp;lt;NP; i++)         /* Start of loop through ensemble  */
          {
         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 2 !!!     */
           r1 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while(r1==i);            

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 3 !!!     */
           r2 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r2==i) || (r2==r1));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 4 !!!     */
           r3 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r3==i) || (r3==r1) || (r3==r2));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 5 !!!     */
           r4 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 6 !!!     */
           r5 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));


    /*=======Choice of strategy===============================================================*/
    /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
    /*=======DE :  stands for Differential Evolution==========================================*/
    /*=======x  :  a string which denotes the vector to be perturbed==========================*/
    /*=======y  :  number of difference vectors taken for perturbation of x===================*/
    /*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
    /*                                                                                        */
    /*=======There are some simple rules which are worth following:===========================*/
    /*=======1)  F is usually between 0.5 and 1 (in rare cases &amp;gt; 1)===========================*/
    /*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
    /*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
    /*           happens.                                                                     */
    /*=======4)  If you increase NP, F usually has to be decreased============================*/
    /*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/


    /*=======EXPONENTIAL CROSSOVER============================================================*/

    /*-------DE/best/1/exp--------------------------------------------------------------------*/
    /*-------Our oldest strategy but still not bad. However, we have found several------------*/
    /*-------optimization problems where misconvergence occurs.-------------------------------*/
    // 1 為最原始的解題邏輯方法
         if (strategy == 1) /* strategy DE0 (not in our paper) */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/1/exp-------------------------------------------------------------------*/
    /*-------This is one of my favourite strategies. It works especially well when the-------*/
    /*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
    /*-------as a first guess.---------------------------------------------------------------*/
      // 配合邏輯方法 2 選用 R=0.7, CR=0.5
       else if (strategy == 2) /* strategy DE1 in the techreport */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
    /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
    /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
    /*-------should play around with all three control variables.----------------------------*/
         // 方法 3 建議 F=0.85 CR=1.
       else if (strategy == 3) /* similiar to DE2 but generally better */
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                       
             tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
         else if (strategy == 4)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
         else if (strategy == 5)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }

    /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/

    /*-------DE/best/1/bin--------------------------------------------------------------------*/
         else if (strategy == 6) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/1/bin-------------------------------------------------------------------*/
         else if (strategy == 7) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
         else if (strategy == 8) 
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/best/2/bin--------------------------------------------------------------------*/
         else if (strategy == 9)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/2/bin--------------------------------------------------------------------*/
         else
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }


    /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
         trial_cost = evaluate(D,tmp,&amp;amp;nfeval);  /* Evaluate new vector in tmp[] */
       if(MAXIMAPROBLEM == 1)
       {
        // 改為最大化
           if (trial_cost &amp;gt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;gt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }
        else
        {
              // 最小化問題
           if (trial_cost &amp;lt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;lt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }

          }   /* End mutation loop through pop. */

          assignd(D,bestit,best);  /* Save best population member of current iteration */

          /* swap population arrays. New generation becomes old one */

          pswap = pold;
          pold  = pnew;
          pnew  = pswap;

    /*----Compute the energy variance (just for monitoring purposes)-----------*/

          cmean = 0.;          /* compute the mean value first */
          for (j=0; j&amp;lt;NP; j++)
          {
             cmean += cost[j];
          }
          cmean = cmean/NP;

          cvar = 0.;           /* now the variance              */
          for (j=0; j&amp;lt;NP; j++)
          {
             cvar += (cost[j] - cmean)*(cost[j] - cmean);
          }
          cvar = cvar/(NP-1);


    /*----Output part----------------------------------------------------------*/

          if (gen%refresh==1)   /* display after every refresh generations */
          { /* ABORT works only if conio.h is accepted by your compiler */
        printf("\n\n                         PRESS ANY KEY TO ABORT"); 
        printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);

        for (j=0;j&amp;lt;D;j++)
        {
          printf("\n best[%d]=%-15.10g",j,best[j]);
        }
        printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
        printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
                   NP,F,CR,cvar);
          }

          fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
       }
    /*=======================================================================*/
    /*=========End of iteration loop=========================================*/
    /*=======================================================================*/

    /*-------Final output in file-------------------------------------------*/


       fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);

       for (j=0;j&amp;lt;D;j++)
       {
         fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
       }
       fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
       fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
               NP,F,CR,cvar); 

      fclose(fpout_ptr);

      /* Code you want timed here */
      printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
      return(0);
    }

    /*-----------End of main()------------------------------------------*/

    // 適應函式 fittness function (cost function)
    double evaluate(int D, double tmp[], long *nfeval)
    {
      // 先處理通過 5 個點的四連桿問題
      // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
      // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
      // L1 為第一桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[4]
      // L2 為第二桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[5]
      // L3 為第三桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[6]
      // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
      // L5, L6 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
      // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
      // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
      // 這裡的輸入角度值, 將採用以第一角度&amp;gt;0 作為起點, 隨後則為角度增量, 也都必須大於零
      // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
      // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
      /* void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
      struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
      double input_angles[NUM_OF_POINTS], result, total_angle;
      int i;

      (*nfeval)++;

      target_points[0].x = 4.5;
      target_points[0].y = 6.75;

      target_points[1].x = 5.07;
      target_points[1].y = 6.85;

      target_points[2].x = 5.45;
      target_points[2].y = 6.84;

      target_points[3].x = 5.89;
      target_points[3].y = 6.83;

      target_points[4].x = 6.41;
      target_points[4].y = 6.8;

      target_points[5].x = 6.92;
      target_points[5].y = 6.58;

      target_points[6].x = 7.03;
      target_points[6].y = 5.99;

      target_points[7].x = 6.95;
      target_points[7].y = 5.45;

      target_points[8].x = 6.77;
      target_points[8].y = 5.03;

      target_points[9].x = 6.4;
      target_points[9].y = 4.6;

      target_points[10].x = 5.91;
      target_points[10].y = 4.03;

      target_points[11].x = 5.43;
      target_points[11].y = 3.56;

      target_points[12].x = 4.93;
      target_points[12].y = 2.94;

      target_points[13].x = 4.67;
      target_points[13].y = 2.6;

      target_points[14].x = 4.38;
      target_points[14].y = 2.2;

      target_points[15].x = 4.04;
      target_points[15].y = 1.67;

      target_points[16].x = 3.76;
      target_points[16].y = 1.22;

      target_points[17].x = 3.76;
      target_points[17].y = 1.97;

      target_points[18].x = 3.76;
      target_points[18].y = 2.78;

      target_points[19].x = 3.76;
      target_points[19].y = 3.56;

      target_points[20].x = 3.76;
      target_points[20].y = 4.34;

      target_points[21].x = 3.76;
      target_points[21].y = 4.91;

      target_points[22].x = 3.76;
      target_points[22].y = 5.47;

      target_points[23].x = 3.8;
      target_points[23].y = 5.98;

      target_points[24].x = 4.07;
      target_points[24].y = 6.4;


      // 輸入角度值與 tmp[] 的設定
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        input_angles[i] = tmp[i + 9];
      }

      // 呼叫 mechanism() 以便計算 output_points[]
      mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);

      // for debug
      /*
      if(*nfeval%5000 == 0)
      {
        for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
        {
          printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
        }
        printf("#####################################\n");
      }
    */
      // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
      result = error_function(output_points, target_points);
      // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result

     // x0 與 x1 點位於 -50 與 50 中間
        for(i = 0; i &amp;lt; 4; i++)
      {
        if(tmp[i] &amp;lt; -100 || tmp[i] &amp;gt; 100){
          return PENALITY;
        }
      }

      // 三個連桿值, 一定要為正
        for(i = 4; i &amp;lt; 7; i++)
      {
        if(tmp[i] &amp;lt; 0 || tmp[i] &amp;gt; 100){
          return PENALITY;
        }
      }

        // L5 L6 可以為 0 或負值
        for(i = 7; i &amp;lt; 9; i++)
      {
        if(tmp[i] &amp;lt; -100 || tmp[i] &amp;gt; 100){
          return PENALITY;
        }
      }

      // 角度值不可以小於 0

      for(i = 1; i &amp;lt;= NUM_OF_POINTS; i++)
      {
        if(tmp[D-i] &amp;lt; 0){
          return PENALITY;
        }
      }


      /*
      for(i = 0; i &amp;lt; D - NUM_OF_POINTS; i++)
      {
          if((tmp[i] &amp;lt;= inibound_l)|| (tmp[i] &amp;gt;inibound_h)){
          return PENALITY;
        }
      }

      for(i = 1; i &amp;lt;= NUM_OF_POINTS; i++)
      {
        if(tmp[D-i] &amp;lt; 0){
          return PENALITY;
        }
      }
      */
      return result;

      /*
       double result=0, surface = 80.0, z, volume, penality;
       (*nfeval)++;
       z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
       volume = tmp[0]*tmp[1]*z;

      if(volume &amp;lt;= 0){
        return PENALITY;
      }

      if((tmp[0] &amp;lt;= inibound_l)|| (tmp[0] &amp;gt;inibound_h)){
        return PENALITY;
      }

      if((tmp[1] &amp;lt;= inibound_l) || (tmp[1] &amp;gt;inibound_h)){
        return PENALITY;
      }
      // volume must &amp;gt;0 and max volume
      // 目前為最小化問題
       return 1+1/(volume*volume);
       */
    }

    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
    {
        struct Coord tip_coord;

        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
        }
        else
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
        pow(x1-x0,2))/2)+x0;
        }

    // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    // 利用 sqrtt 居中進行代換所得到的式子
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;

        }
        else
        {
            tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
        }

      return tip_coord;
    }

    double distance(double x0, double y0, double x1, double y1)
    {
        double distance_value;
        distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
        return distance_value;
    }

    double rr(double L1, double dd, double theta)
    {
        double rr_value;
        rr_value = sqrt(L1*L1+dd*dd - 2*L1*dd*cos(theta));
        return rr_value;
    }

    // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
    {
      // 這裡的輸入角度, 改採第一角度為起始角, 隨後的角度值則為增量值
      // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
      // 以下為可能的處理變數宣告
      // 這裡希望能夠定義一個 struct 來處理座標點
      double rr_length, dd_length, angle;
      struct Coord link1_tip, link2_tip, triangle_tip;
        double angle2, angle3;
      int i;

      // 開始進行三角形頂點座標的計算
      // 以下變數由每一個體向量提供
      /*
        x0 = 0.0;
        y0 = 0.0;
        x1 = 10.0;
        y1 = 0.0;
        L1 = 5.0;
        L2 = 20;
        L3 = 10;
        L5 = 10;
        L6 = 10;
      */
      dd_length = distance(x0, y0, x1, y1);
      /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
      // 假如採用 finaltip_coord, 則不需要 angle3
      angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));

      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        // 先建立第一點座標, 即 i=0 者
        // i=0;
        // angle = i*degree;

        /*
        // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
        if(i &amp;gt; 0)
        {
          input_angles[i] = input_angles[i] + input_angles[i-1];
        }
        */
        angle = input_angles[i]*degree;
        rr_length = rr(L1, dd_length, angle);
        // 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
        // 第二次三角形疊代
        /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
        // 第三次三角形疊代
        //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
      }
    }

    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
    {
      double error = 0.0;
      int i;
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
      }
      return error;
    }

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
    {
      struct Coord tip3_coord;
      double theta3, theta4, length3, length4;
      length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
      length4 = sqrt(pow(r1,2) + pow(r2,2));  
      theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
      theta4 = acos(r1 / length4);
      tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
      tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);

      return tip3_coord;
    }
&lt;/pre&gt;</summary><category term="RGA"></category></entry><entry><title>yen - 機械設計專題的表達、技術領域與考量層面</title><link href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-de-biao-da-ji-shu-ling-yu-yu-kao-liang-ceng-mian.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ji-jie-she-ji-zhuan-ti-de-biao-da-ji-shu-ling-yu-yu-kao-liang-ceng-mian.html</id><summary type="html">&lt;p&gt;這是一個利用 Python3 的模組 blockdiag: &lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt;, 將文字敘述轉為 2D 流程圖的範例.&lt;/p&gt;


&lt;p&gt;機械設計專題內容流程圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/mde_project.png" width="800"/&gt;&lt;/p&gt;
&lt;p&gt;機械設計專題&lt;a href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-sui-shen-kai-fa-dian-nao.html"&gt;隨身卡片電腦規劃&lt;/a&gt;流程圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/rpi_shopping_flow.png" width="800"/&gt;&lt;/p&gt;
&lt;p&gt;機械設計專題內容流程圖的文字敘述:&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
blockdiag {
    default_shape = roundedbox;
    // 內定寬度為 128
    node_width = 140;
    // 內定高度為 40
    node_height = 50;
    default_fontsize = 15;
    default_node_color = "lightyellow";
    edge_layout = flowchart;
    // 表達方式
    表達 [label = "六種表達方式"];
    1 [label = "口語表達(聲音)"];
    2 [label = "文字表達"];
    3 [label = "2D表達(靜態影像)"];
    4 [label = "3D表達(動態影像)"];
    5 [label = "理論表達(定量分析)"];
    6 [label = "實體表達"];
    表達 -&gt; 1;
    表達 -&gt; 2;
    表達 -&gt; 3;
    表達 -&gt; 4;
    表達 -&gt; 5;
    表達 -&gt; 6;
    // 學門
    學門 [label = "四種技術領域"];
    學門1 [label = "熱流力學"];
    學門2 [label = "固體力學"];
    學門3 [label = "電機電子"];
    學門4 [label = "資訊通信"];
    學門 -&gt; 學門1;
    學門 -&gt; 學門2;
    學門 -&gt; 學門3;
    學門 -&gt; 學門4;
    // 流程
    流程 [label = "四個層面"];
    流程1 [label = "設計"];
    流程2 [label = "製造"];
    流程3 [label = "控制"];
    流程4 [label = "管理"];
    流程 -&gt; 流程1;
    流程 -&gt; 流程2;
    流程 -&gt; 流程3;
    流程 -&gt; 流程4;
    //專題
    專題 [label = "機械設計專題", stacked];
    專題 -&gt; 表達;
    專題 -&gt; 流程;
    專題 -&gt; 學門;
}
&lt;/pre&gt;

&lt;p&gt;機械設計專題&lt;a href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-sui-shen-kai-fa-dian-nao.html"&gt;隨身卡片電腦規劃&lt;/a&gt;流程圖的文字敘述:&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
blockdiag {
    default_shape = roundedbox;
    // 內定寬度為 128
    node_width = 140;
    // 內定高度為 40
    node_height = 50;
    default_fontsize = 15;
    default_node_color = "lightyellow";
    edge_layout = flowchart;
    // 表達方式
    表達 [label = "六種表達方式"];
    1 [label = "口語表達(聲音)"];
    2 [label = "文字表達", color="#99ff33"];
    3 [label = "2D表達(靜態影像)"];
    4 [label = "3D表達(動態影像)"];
    5 [label = "理論表達(定量分析)"];
    6 [label = "實體表達", color="#99ff33"];
    表達 -&gt; 1;
    表達 -&gt; 2;
    表達 -&gt; 3;
    表達 -&gt; 4;
    表達 -&gt; 5;
    表達 -&gt; 6;
    // 學門
    學門 [label = "四種技術領域"];
    學門1 [label = "熱流力學"];
    學門2 [label = "固體力學"];
    學門3 [label = "電機電子"];
    學門4 [label = "資訊通信", color="#99ff33"];
    學門 -&gt; 學門1;
    學門 -&gt; 學門2;
    學門 -&gt; 學門3;
    學門 -&gt; 學門4;
    // 流程
    流程 [label = "四個層面"];
    流程1 [label = "設計", color="#99ff33"];
    流程2 [label = "製造"];
    流程3 [label = "控制"];
    流程4 [label = "管理", color="#99ff33"];
    流程 -&gt; 流程1;
    流程 -&gt; 流程2;
    流程 -&gt; 流程3;
    流程 -&gt; 流程4;
    //專題
    //專題 [label = "機械設計專題", stacked];
    專題 [label = "隨身卡片電腦選購", stacked, color="#ff5050"];
    專題 -&gt; 表達;
    專題 -&gt; 流程;
    專題 -&gt; 學門;
}
&lt;/pre&gt;</summary><category term="專題分類"></category></entry><entry><title>yen - 如何建立一好的 Wordpress 網站</title><link href="http://project.mde.tw/blog/yen-ru-he-jian-li-yi-hao-de-wordpress-wang-zhan.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ru-he-jian-li-yi-hao-de-wordpress-wang-zhan.html</id><summary type="html">&lt;p&gt;機械設計專題專用的 Wordpress 必須俱備幾項特點: 能夠輸入數學公式, 能夠放入高亮顯示的程式碼, 能夠內嵌影片, 能夠利用 Gmail 帳號寄信, 能夠納入 Disqus 討論區, 能夠杜絕垃圾註冊.&lt;/p&gt;


&lt;p&gt;當然假如能夠如 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html&lt;/a&gt; 中所言, 可以利用 Leo Editor 的指令按鈕, 讓 Wordpress 網誌內容能與 Pelican 靜態網誌內容保持同步, 或許就能同時擁有改版歷程資料與即時動態維護內容的優點.&lt;/p&gt;
&lt;p&gt;Disqus 的討論區留言首推: &lt;a href="https://wordpress.org/plugins/disqus-comment-system/"&gt;https://wordpress.org/plugins/disqus-comment-system/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嵌入影片專用: &lt;a href="https://wordpress.org/plugins/iframe/"&gt;https://wordpress.org/plugins/iframe/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;程式碼的高亮則建議使用: &lt;a href="https://wordpress.org/plugins/syntaxhighlighter/"&gt;https://wordpress.org/plugins/syntaxhighlighter/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;輸入數學公式: &lt;a href="https://wordpress.org/plugins/wp-latex/"&gt;https://wordpress.org/plugins/wp-latex/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;寄信 plugin: &lt;a href="https://wordpress.org/plugins/wp-latex/"&gt;https://wordpress.org/plugins/wp-latex/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;防止垃圾註冊 plugin: &lt;a href="https://wordpress.org/plugins/wp-recaptcha/"&gt;https://wordpress.org/plugins/wp-recaptcha/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至於, 在 WordPress 網誌中利用 &lt;a href="https://wordpress.org/plugins/wp-mail-smtp/"&gt;https://wordpress.org/plugins/wp-mail-smtp/&lt;/a&gt; Plugin 與 Gmail 帳號寄信的設定, 有兩個關鍵:&lt;/p&gt;
&lt;p&gt;第1項就是設定選項:&lt;/p&gt;
&lt;p&gt;選擇 Send all WordPress emails via SMTP&lt;/p&gt;
&lt;p&gt;選擇 smtp.gmail.com: 465&lt;/p&gt;
&lt;p&gt;選擇 Use SSL encryption&lt;/p&gt;
&lt;p&gt;選擇 Use SMTP authentication&lt;/p&gt;
&lt;p&gt;然後給定對應的 Gmail 帳號 與 Gmail 密碼 之後存檔.&lt;/p&gt;
&lt;p&gt;第2項設定則是必須配合所使用的 Gmail 帳號, 利用 &lt;a href="https://www.google.com/settings/security/lesssecureapps"&gt;https://www.google.com/settings/security/lesssecureapps&lt;/a&gt; 將原定的 Turn off 改為 Turn on, 也就是降低安全設定等級, 接著就可以寄出測試信件, 若成功, 則 WordPress 中的其他模組就可以利用設定寄信.&lt;/p&gt;</summary><category term="Wordpress"></category></entry><entry><title>yen - Solvespace 與 V-rep 結合應用</title><link href="http://project.mde.tw/blog/yen-solvespace-yu-v-rep-jie-he-ying-yong.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-solvespace-yu-v-rep-jie-he-ying-yong.html</id><summary type="html">&lt;p&gt;Solvespace 是一套小型的參數式 3D 繪圖開源套件, 而 V-rep 則是一套允許教育界免費使用的開源動態模擬套件, 結合這兩個套件在機械設計專題應用, 一方面使用者可以在可攜的架構下來進行產品開發與模擬, 更重要的是, 使用者可以透過原始程式碼, 一窺專業人士編寫電腦輔助機械設計與分析工具時, 所應用的理論分析與基本架構.&lt;/p&gt;


&lt;p&gt;Solvespace: &lt;a href="http://solvespace.com/"&gt;http://solvespace.com/&lt;/a&gt; 與 &lt;a href="https://github.com/whitequark/solvespace"&gt;https://github.com/whitequark/solvespace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;V-rep: &lt;a href="http://www.coppeliarobotics.com/"&gt;http://www.coppeliarobotics.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/solvespace_v-rep.png" width="800" /&gt;&lt;/p&gt;</summary><category term="Solvespace"></category><category term="V-rep"></category></entry><entry><title>yen - 機械設計專題學員的隨身 Jupyter hub</title><link href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-xue-yuan-de-sui-shen-jupyter-hub.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ji-jie-she-ji-zhuan-ti-xue-yuan-de-sui-shen-jupyter-hub.html</id><summary type="html">&lt;p&gt;我們知道自從 2013 年底開始, 與 Raspberry Pi 搭配的 Raspbian 操作系統, 就已經免費放入 Mathematica 相關的套件系統, 但是只允許非營利使用, 相較之下, 以 Python3 為主打造的 &lt;a href="http://jupyter.org/"&gt;Jupyter&lt;/a&gt; 就比較自由, 而且全部開源, 因此更值得推廣.&lt;/p&gt;


&lt;p&gt;這裡就以 Raspberry Pi 3 卡片電腦上的 &lt;a href="https://github.com/jupyter/jupyterhub"&gt;Jupyter hub&lt;/a&gt; 安裝與啟動為例, 希望作為機械設計專題學員隨身的網際工程運算系統.&lt;/p&gt;
&lt;p&gt;最新的 Raspbian 操作系統已經內建 Python3 以及 node.js, 因此當基本的操作系統配置完成, 而且啟動 SSH 之後, 就可以透過下列步驟安裝 &lt;a href="https://github.com/jupyter/jupyterhub"&gt;Jupyter hub&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;jupyterhub 安裝&lt;/h2&gt;
&lt;p&gt;sudo apt-get install npm nodejs-legacy&lt;/p&gt;
&lt;p&gt;sudo npm install -g configurable-http-proxy&lt;/p&gt;
&lt;p&gt;sudo pip3 install jupyterhub&lt;/p&gt;
&lt;p&gt;sudo pip3 install IPython&lt;/p&gt;
&lt;p&gt;sudo pip3 install jupyter&lt;/p&gt;
&lt;h2&gt;以 SSL 啟動:&lt;/h2&gt;
&lt;p&gt;先建立 key 與 certificate: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt&lt;/p&gt;
&lt;p&gt;以指定的 IP 啟動:&lt;/p&gt;
&lt;p&gt;jupyterhub --ip 192.168.1.1 --port 443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/p&gt;
&lt;p&gt;或不指定 IP:&lt;/p&gt;
&lt;p&gt;jupyterhub  --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/p&gt;
&lt;p&gt;之後則可以 http://jupyterIP:9443 或 https://jupyterIP:9443 連線 &lt;/p&gt;</summary><category term="Jupyter"></category><category term="Jupyterhub"></category><category term="Python3"></category></entry><entry><title>yen - Raspberry Pi 3 基本設定</title><link href="http://project.mde.tw/blog/yen-raspberry-pi-3-ji-ben-she-ding.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-raspberry-pi-3-ji-ben-she-ding.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/"&gt;Raspberry Pi 3 Model B&lt;/a&gt; 終於在 2016 年 2 月推出了, 這片採用 1.2GHz 64位元四核心 CPU ARMv8 晶片的卡片電腦, 將帶給機械設計專題更多應用的題目.&lt;/p&gt;


&lt;h2&gt;raspbian 安裝&lt;/h2&gt;
&lt;p&gt;首先, 為了簡化新的 Raspberry Pi 3 安裝 &lt;a href="https://www.raspberrypi.org/downloads/noobs/"&gt;https://www.raspberrypi.org/downloads/noobs/&lt;/a&gt; 多重開機系統的過程, &lt;a href="http://cadlab.mde.tw"&gt;http://cadlab.mde.tw&lt;/a&gt; 特別採購一批支援 &lt;a href="https://zh.wikipedia.org/zh-tw/HDMI"&gt;HDMI&lt;/a&gt; 介面的電腦螢幕.&lt;/p&gt;
&lt;p&gt;由於 noobs 內含的 &lt;a href="https://www.raspberrypi.org/downloads/raspbian/"&gt;https://www.raspberrypi.org/downloads/raspbian/&lt;/a&gt; 與 Ubuntu 操作系統都屬於 Debian 系列, 因此未來幾年, 本地端與區域網路上的伺服器, 都將安裝 Ubuntu 16.04 LTS, 而希望學生人手一塊的 Raspberry Pi 3, 就以安裝 noobs 為主.&lt;/p&gt;
&lt;p&gt;完成操作系統安裝後, 必須 enable SSH, 並且參考&lt;a href="http://www.kenming.idv.tw/raspberry-pi_post-installation_and_zh-tw-locale_building"&gt;這裡&lt;/a&gt;的說明, 安裝並設定中文系統.&lt;/p&gt;
&lt;p&gt;基本過程為:&lt;/p&gt;
&lt;p&gt;安裝繁體中文語系:&lt;/p&gt;
&lt;p&gt;$ sudo locale-gen zh_TW.UTF-8&lt;/p&gt;
&lt;p&gt;將 /etc/locale.gen 檔案內 # zh_TW.UTF-8 UTF-8 的註解# 拿掉:&lt;/p&gt;
&lt;p&gt;$ sudo vi /etc/locale.gen&lt;/p&gt;
&lt;p&gt;產生繁體中文語系:&lt;/p&gt;
&lt;p&gt;$ sudo locale-gen&lt;/p&gt;
&lt;p&gt;更改預設語系為 zh_TW.UTF-8:&lt;/p&gt;
&lt;p&gt;$ sudo vi /etc/default/locale
LANG=zh_TW.UTF-8&lt;/p&gt;
&lt;p&gt;安裝繁體中文字型:&lt;/p&gt;
&lt;p&gt;$ sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy&lt;/p&gt;
&lt;p&gt;安裝 scim 注音輸入:&lt;/p&gt;
&lt;p&gt;$ sudo apt-get install scim scim-tables-zh scim-chewing&lt;/p&gt;
&lt;h2&gt;PYQt5 與 Leo Editor 安裝&lt;/h2&gt;
&lt;p&gt;因為 Raspberry Pi 3 在機械設計專題流程中仍以機電控制為主, 而且 raspbian 已經內建 Python3 與 pip3, 因此只要利用 sudo apt-get install python3-pyqt5 安裝 PyQt5 即可.&lt;/p&gt;
&lt;p&gt;只是在實際操作 sudo pip3 install https://github.com/leo-editor/leo-editor/archive/master.zip 時, 發現 Leo Editor 無法正確完成安裝, 最後只好下載 Leo Editor 原始碼, 並且將 leo 模組目錄, 直接放到 /usr/local/lib/python3.4/dist-packages 目錄下, 然後再利用 python3 launchLeo.py 啟動 Leo Editor.&lt;/p&gt;
&lt;p&gt;launchLeo.py 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python

""" Leo launcher script
A minimal script to launch leo.
"""

import leo.core.runLeo
leo.core.runLeo.run()
&lt;/pre&gt;

&lt;h2&gt;Raspberry Pi 無線網路設定&lt;/h2&gt;
&lt;p&gt;利用 sudo vi 編輯 /etc/wpa_supplicant/wpa_supplicant.conf, 並且採用下列格式, 將周遭卡片電腦移動時可能擷取的無線網路, 以並列的方式進行設定登記.&lt;/p&gt;
&lt;p&gt;格式:&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
network={
    ssid="net1"
    psk="net1_wifi_password"
    key_mgmt=WPA-PSK
}

network={
    ssid="net2"
    psk="net2_wifi_password"
    key_mgmt=WPA-PSK
}
&lt;/pre&gt;

&lt;p&gt;相關指令:&lt;/p&gt;
&lt;p&gt;sudo ifdown wlan0 (關閉無線網路)&lt;/p&gt;
&lt;p&gt;sudo ifup wlan0 (啟動無線網路)&lt;/p&gt;
&lt;p&gt;ifconfig (察看網路設定)&lt;/p&gt;
&lt;h2&gt;Webcam 拍照&lt;/h2&gt;
&lt;p&gt;請參考 &lt;a href="https://www.raspberrypi.org/documentation/usage/webcams/"&gt;https://www.raspberrypi.org/documentation/usage/webcams/&lt;/a&gt;, 讓 Raspberry Pi 可以帶著 Webcam, 以 Python3 程式控制拍照流程.&lt;/p&gt;
&lt;p&gt;至於安裝 OpenCV 與 Python3 的過程與 &lt;a href="http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html"&gt;http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html&lt;/a&gt; 中的說明完全相同, 一旦完成, Raspberry Pi 就可以與其他機構結合, 進行基本的影像辨識應用.&lt;/p&gt;</summary><category term="Python3"></category><category term="Raspberry Pi"></category></entry><entry><title>yen - Python 數位運算與較有未來的技術</title><link href="http://project.mde.tw/blog/yen-python-shu-wei-yun-suan-yu-jiao-you-wei-lai-de-ji-shu.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-python-shu-wei-yun-suan-yu-jiao-you-wei-lai-de-ji-shu.html</id><summary type="html">&lt;p&gt;身為一位機械設計工程專長學員, 該如何看待數位運算, 那些技術較有未來?&lt;/p&gt;


&lt;p&gt;機械設計專題是一項資訊密集的動態流程, 資訊之所以密集, 肇因於後續的許多控制、製造與管理, 都以設計的發動起始, 因此機械設計者憑藉著口語, 文字, 2D/3D, 理論與實體, 來紀錄並驗證概念與規格的可行性, 即便產品交付客戶手中, 各種後續服務、回收與處理再利用的相關細節規劃, 所涉及的許多資訊與數據處理, 就產品生命週期的概念而言, 都是設計者該盡力思量的範疇.&lt;/p&gt;
&lt;p&gt;現在對於手握 Python3 作為數位運算的機械設計專題推動者, 有了福音, 因為 &lt;a href="https://software.intel.com/en-us/python-distribution"&gt;https://software.intel.com/en-us/python-distribution&lt;/a&gt; 的推出, 將可讓 Jupyter hub 上的各種機械設計純 Python3 最佳化運算速度提升幾十倍.&lt;/p&gt;
&lt;p&gt;並且, 從 &lt;a href="http://www.infoworld.com/article/3039935/application-development/21-hot-programming-trends-and-21-going-cold.html"&gt;http://www.infoworld.com/article/3039935/application-development/21-hot-programming-trends-and-21-going-cold.html&lt;/a&gt; 的提醒, 也可以讓即將參與機械設計專題的學員了解, 應該如何取捨工具與技術, 畢竟數位運算科技的快速發展, 應該是機械設計者的絕對利多, 假如大家真能妥善發揮這些較有未來科技功能於工作的每一個流程.&lt;/p&gt;</summary><category term="Python3"></category></entry><entry><title>yen - 如何在 Pelican 網誌中加入 Github stl 檢視</title><link href="http://project.mde.tw/blog/yen-ru-he-zai-pelican-wang-zhi-zhong-jia-ru-github-stl-jian-shi.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ru-he-zai-pelican-wang-zhi-zhong-jia-ru-github-stl-jian-shi.html</id><summary type="html">&lt;p&gt;因為這個網誌系統分為本地端與 Github 端的資料搜尋 ,因此一般並不建議直接將要展示的 stl 帶進倉儲, 否則就必須要分別在近端與遠端的 template 目錄中, 各放置一份檔案.&lt;/p&gt;


&lt;p&gt;也就是說, 就這個機械設計專題的協同倉儲網誌來說, 各組員可以分別在自己的個人帳號下建立具有 gh-pages 分支的倉儲, 然後再將 STL 零組件檔案的檢式, 以 Github 特有的標註, 放到文章中, 因為 STL 檔案已經是終端檔案, 比較不會有協同編輯改版的需求, 因此可以放在個人所屬的倉儲中, 只需要透過連結可以檢視即可.&lt;/p&gt;
&lt;p&gt;但是若這些檔案真要放到機械設計專題所屬的倉儲中, 也是可以, 但是就必須在近端的 theme/pelican-bootstrap3_local/static 目錄, 以及&lt;/p&gt;
&lt;p&gt;theme/pelican-bootstrap3/static 目錄中, 各放一份, 例如, 現在已經在這兩個目錄中各放入 files 目錄, 而且其中還有 40323143 目錄, 並將所有的 STL 零組件檔全部放入. 這時若利用 local-pelican 或 gh-pages-pelican 按鈕建立 blog 中的資料, Pelican 就會將前面提到的 files 目錄, 複製到 blog/theme 目錄中, 因此隨後在 gh-pages 的網頁中, 就是到 blog/theme/files/40323143 目錄來擷取這些零組件檔案.&lt;/p&gt;
&lt;p&gt;例如: blog/theme/files/40323143/1long.stl 檔案, 就可以疊上 https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/, 並用 script 標註圈住, 讓使用者可以在瀏覽器中檢視.&lt;/p&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/1long.stl"&gt;&lt;/script&gt;</summary><category term="Github"></category><category term="stl viewer"></category></entry><entry><title>yen - 導入 OpenCV 與 Python3</title><link href="http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-dao-ru-opencv-yu-python3.html</id><summary type="html">&lt;p&gt;OpenCV (Open Source Computer Vision) 是一套實時影像程式庫, 這裡希望利用 Python3 來進行應用程式開發.&lt;/p&gt;


&lt;h2&gt;安裝&lt;/h2&gt;
&lt;h3&gt;Windows&lt;/h3&gt;
&lt;p&gt;可以直接從 &lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt; git clone 可攜系統.&lt;/p&gt;
&lt;p&gt;測試程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((512,512,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.line(img,(0,0),(511,511),(255,0,0),5)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()

'''
# 載入 jpg 圖檔
image = cv2.imread("mario.jpg", flags=cv2.IMREAD_COLOR)

# 然後呈現此影像
cv2.imshow('image',image)
cv2.waitKey(0)
cv2.destroyAllWindows()
'''
&lt;/pre&gt;

&lt;p&gt;在 Windows 環境執行結果:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/opencv_python3_windows.png" width="800" /&gt;&lt;/p&gt;
&lt;h2&gt;Ubuntu 14.04&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 操作系統中 for Python2 與 Python3 的 OpenCV 程式庫編譯流程如下:&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
# apt-get 更新
$ sudo apt-get update
# apt-get 升級
$ sudo apt-get upgrade
# 安裝所需的開發套件
$ sudo apt-get install build-essential cmake git pkg-config
# 安裝編譯過程所需的程式庫
$ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev
# 安裝編譯過程所需的程式庫
$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
# 安裝編譯過程所需的程式庫
$ sudo apt-get install libgtk2.0-dev
# 安裝編譯過程所需的 fortran 編譯器
$ sudo apt-get install libatlas-base-dev gfortran
# 安裝編譯過程所需的原始碼
$ sudo apt-get install python3.4-dev
# 本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy  模組
$ pip3 install numpy
# 希望在帳號目錄下的 tmp 進行編譯工作
$ cd
# 更換目錄到 tmp
$ cd tmp
# 利用 git clone 取得原始碼
$ git clone https://github.com/Itseez/opencv.git
# 準備進入倉儲切換分支
$ cd opencv
# 採用 3.1.0 版
$ git checkout 3.1.0
# 回到用戶目錄
$ cd ..
# 再利用 git clone 下載原始碼
$ git clone https://github.com/Itseez/opencv_contrib.git
# 準備進入倉儲切換分支
$ cd opencv_contrib
# 與 opencv 配合, 採用 3.1.0 版
$ git checkout 3.1.0

$ cd ..
# 準備開始建立程式庫
$ cd opencv

$ mkdir build

$ cd build

# 這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案
$ cmake -D CMAKE_BUILD_TYPE=RELEASE \
    -D CMAKE_INSTALL_PREFIX=/usr/local \
    -D INSTALL_C_EXAMPLES=OFF \
    -D INSTALL_PYTHON_EXAMPLES=ON \
    -D PYTHON_EXECUTABLE=$(which python3) \
    -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \
    -D BUILD_EXAMPLES=ON ..

$ make -j4

$ sudo make install

$ sudo ldconfig
&lt;/pre&gt;

&lt;p&gt;完成安裝後, 執行上一個測試程式結果:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/opencv_python3_ubuntu.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下則為人臉變識程式:&lt;a href="https://github.com/shantnu/FaceDetect/"&gt;https://github.com/shantnu/FaceDetect/&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;執行需要取得 &lt;a href="http://coursemdetw.github.io/project_site_files/files/2016spring/haarcascade_frontalface_default.xml"&gt;haarcascade_frontalface_default.xml&lt;/a&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import cv2
import sys

cascPath = "haarcascade_frontalface_default.xml"
faceCascade = cv2.CascadeClassifier(cascPath)

video_capture = cv2.VideoCapture(0)

while True:
    # 逐一以影格取像
    ret, frame = video_capture.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    faces = faceCascade.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5,
        minSize=(30, 30),
        flags=cv2.CASCADE_SCALE_IMAGE
    )

    # 在辨識的臉形外圍畫一個矩形
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # 呈現影像
    cv2.imshow('Video', frame)

    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# 停止執行
video_capture.release()
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;人臉辨識程式執行結果:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/opencv_python3_face_detect1.png" width="800" /&gt;&lt;/p&gt;</summary><category term="OpenCV"></category><category term="Python3"></category></entry><entry><title>yen - 編譯 Solvespace</title><link href="http://project.mde.tw/blog/yen-bian-yi-solvespace.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-bian-yi-solvespace.html</id><summary type="html">&lt;p&gt;我們有沒有能力在機械設計專題中, 自行編譯 Solvespace, 並且了解其中的原理後, 新增自己需要的零件設計功能?&lt;/p&gt;


&lt;p&gt;&lt;a href="https://github.com/whitequark/solvespace"&gt;https://github.com/whitequark/solvespace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://solvespace.com"&gt;http://solvespace.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自行編譯 solvespace:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;從 &lt;a href="http://www.activestate.com/activeperl/downloads"&gt;http://www.activestate.com/activeperl/downloads&lt;/a&gt; 下載 ActivePerl, 並完成安裝.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下載並安裝 Visual Studio Express.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;從 Visual Studio Express 表單中啟動 Dos Command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進入 Solvespace Makefile 所在目錄, 執行 nmake.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以完成 Solvespace.exe 的編譯.&lt;/p&gt;</summary><category term="Solvespace"></category><category term="MCAD"></category></entry><entry><title>yen - 機械設計專題倉儲</title><link href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-cang-chu.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ji-jie-she-ji-zhuan-ti-cang-chu.html</id><summary type="html">&lt;p&gt;機械設計工程師在面對四種主要的學門領域, 六種表達方式, 以及四種開發流程階段的交互串聯下, 能否在分散式版次管理系統的協助中, 勇往直前?&lt;/p&gt;


&lt;p&gt;四種主要的學門領域: 熱流、固力、電子電機、資通.&lt;/p&gt;
&lt;p&gt;六種表達方式: 口語、文字、2D、3D、理論分析、實體&lt;/p&gt;
&lt;p&gt;四種流程階段: 設計、製造、控制、管理&lt;/p&gt;
&lt;p&gt;機械設計專題倉儲: &lt;a href="https://github.com/2015fallproject"&gt;https://github.com/2015fallproject&lt;/a&gt;&lt;/p&gt;</summary><category term="2016g1"></category><category term="2016g2"></category><category term="2016g3"></category></entry><entry><title>yen - 機械設計專題隨身開發電腦</title><link href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-sui-shen-kai-fa-dian-nao.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ji-jie-she-ji-zhuan-ti-sui-shen-kai-fa-dian-nao.html</id><summary type="html">&lt;p&gt;此項測試目的在利用樹莓派卡片電腦, 以無線網路取得區域網路 IP, 然後從電腦教室中的 Windows 10, 以 X-Windows Server 連線到 Raspberry Pi 電腦系統, 嘗試讓機械設計工程學員評估, 能否在 Windows 10 與隨身的 Ubuntu 電腦系統間, 搭建合用的協同產品開發環境.&lt;/p&gt;


&lt;p&gt;Windows 10 環境中擬採用的 X-Windows Server: &lt;a href="https://sourceforge.net/projects/xming/"&gt;https://sourceforge.net/projects/xming/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raspberry Pi 擬安裝操作系統: Ubuntu Server + sudo apt-get install ubuntu-desktop&lt;/p&gt;
&lt;p&gt;樹莓派採購清單: &lt;br /&gt;&lt;br /&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/raspberry_pi_3_64bit.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;操作步驟:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成清單中的樹莓派硬體採購&lt;/li&gt;
&lt;li&gt;在樹莓派中安裝即將推出的 Ubuntu 16.04 LTS Server 版本, 加上 ubuntu-desktop.&lt;/li&gt;
&lt;li&gt;測試如何在 &lt;a href="http://cadlab.mde.tw"&gt;http://cadlab.mde.tw&lt;/a&gt; 電腦輔助設計室中利用樹莓派的內建 Wifi 取得固定 IP&lt;/li&gt;
&lt;li&gt;測試如何在樹莓派系統中以 IPV6 環境上網, 或在樹莓派系統中植入 IPV6 與 IPV4 雙支援, 並安裝 squid Proxy Server, 測試樹莓派在純 IPV6 環境中, 擔任區域網路代理伺服器的效能.&lt;/li&gt;
&lt;li&gt;利用本地端的 Windows 10 Professional, 啟動 xming 伺服器後, 以 putty 加上 X11 forwarding 設定, 從 Windows 10 連線到樹莓派, 然後在 Ubuntu 中安裝 Leo Editor, Jupyter, Flask 與 Weppy 等相關機械設計專題工具, 並利用 Firefox 連線到 Onshape, 測試各項工具的使用效能.&lt;/li&gt;
&lt;li&gt;完成上述各項任務後, 將流程與心得留在各組對應的機械設計專題倉儲中, 若過程中有些資料不適合在第1時間公開, 則另在 bitbucket 建 private 倉儲, 以五名協同者的編制進行管理.&lt;/li&gt;
&lt;li&gt;上述流程中, 各學員同時考量該如何將心得整理為論文或專題報告 pdf 發表格式.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 KMOL 知識地圖中的屬性:&lt;/p&gt;
&lt;p&gt;四種主要的學門領域: &lt;strike&gt;熱流、固力、電子電機&lt;/strike&gt;、資通.&lt;/p&gt;
&lt;p&gt;六種表達方式: &lt;strike&gt;口語&lt;/strike&gt;、文字、&lt;strike&gt;2D、3D、理論分析&lt;/strike&gt;、實體&lt;/p&gt;
&lt;p&gt;四種流程階段: 設計、&lt;strike&gt;製造、控制&lt;/strike&gt;、管理&lt;/p&gt;
&lt;p&gt;機械設計專題倉儲: &lt;a href="https://github.com/2015fallproject"&gt;https://github.com/2015fallproject&lt;/a&gt;&lt;/p&gt;</summary><category term="Raspberry Pi"></category><category term="可攜電腦"></category></entry><entry><title>yen - Pelican 靜態網頁與 Wordpress 的整合</title><link href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he.html</id><summary type="html">&lt;p&gt;許多網路上的文章都只說明如何從動態的網誌系統轉到靜態網誌架構, 但當我們認定動靜之間各有優劣時, 能否兩者整合並存?&lt;/p&gt;


&lt;p&gt;Worpress 是一套全世界最廣為使用的動態網誌系統, 採用 PHP 編寫, 一般使用 MySQL 資料庫存放資料, 由於 Wordpress 的安裝與使用都非常直覺, 從許多角度來看, 是一套接近完美的動態網誌系統.&lt;/p&gt;
&lt;p&gt;但是, PHP 加上 MySQL 的架構仍然需要在伺服器中運行全球資訊網加上 PHP 解譯器, 同時還要 MySQL 資料庫的支援才能啟動運作, 假如管理者沒有跟上 Wordpress 程式碼或 plugin 的漏洞更新, 或者 MySQL 資料庫未能正常提供資料, 這個用 Wordpress 架構的網誌就會出現危機或者無法使用.&lt;/p&gt;
&lt;p&gt;雖然 Wordpress 網誌中的動態程式與資料庫具有潛在缺點, 但是動態性也同時展現優點, 因為使用者一般可以透過瀏覽器, 隨時更改網誌系統的設定, 可以即時更新所有內容.&lt;/p&gt;
&lt;p&gt;至於 Pellican 靜態網誌系統, 則針對 Wordpress 動態的問題, 將網誌的編寫格式定調在資料提供者能夠閱讀的 Markdown 或其他類似格式, 然後在近端用各種編輯器完成初步 Markdown 文章的存檔後, 再執行 Pelican 的轉檔指令, 讓 Python 程式將一堆設定與一堆 Markdown 資料中, 轉換成一整套所有內容之間互相串連的 html 檔案, 之後再將這批純 html 格式的文檔加上一些 css 與 Javascript 檔案, 送到全球資訊網伺服器中運行.&lt;/p&gt;
&lt;p&gt;Pelican 的網誌內容, 因為不需要動態的程式編譯執行, 而只在全球資訊網伺服器中存有 html 與 Javascript, 因此沒有動態程式碼漏洞更新的問題, 也不會有線上的網誌管理系統被入侵的問題, 唯一會產生問題的只有全球資訊網伺服器, 運作或不運作, Javascript 有沒有正確存取的問題, 相較於 Wordpress 的動態程式與資料庫互動, 性質單純許多.&lt;/p&gt;
&lt;p&gt;但是 Pelican 的靜態性也同時存在問題, 因為大多數的用戶通常採用文字編輯器來準備或管理 Markdown 檔案, 而且是採用命令列的方式來執行 Pelican 轉檔指令, 因此對於電腦程式操作較不熟悉的使用者來說, 導入 Pelican 靜態網誌的距離仍然遙遠, 況且靜態網誌也有不夠動態與直覺的問題, 許多在 Wordpress 線上能夠直接預覽的功能, 在 Pellican 就沒有那麼方便, 而且有很多的 html 與 css 的特定格式, Pelican 的 Markdown 語法根本就不支援.&lt;/p&gt;
&lt;p&gt;可是 Pelican 純文本的 Markdown 與 html, 還有一個最大的好處, 就是可以透過 Github Pages 的網頁架構系統, 讓每一個版本的靜態網誌都以分散式版本系統管理, 這是 Wordpress 現存的版次管理 Plugin 所無法做到的功能, 因此一份內容, 同時呈現在 Wordpress 與 Pelican 網誌是最理想的情況, 但是該如何完成?&lt;/p&gt;
&lt;p&gt;由於要整合 Pelican 靜態網誌與 Wordpress 動態網誌, 需要透過程式方法來進行, 這裡只先提供可行的初步技術, 驗證魚與熊掌可以兼得, 我們所採用的管理系統為 Leo Editor: &lt;a href="https://github.com/leo-editor/leo-editor"&gt;https://github.com/leo-editor/leo-editor&lt;/a&gt;, 所有的資料處理流程都是依靠 Python3 程式完成.&lt;/p&gt;
&lt;p&gt;首先, 看看 Leo Editor 如何透過 Python3 的程式方法與 Wordpress 網誌互動, 這裡所使用的是 XMLRPC 協定 &lt;a href="https://en.wikipedia.org/wiki/XML-RPC"&gt;https://en.wikipedia.org/wiki/XML-RPC&lt;/a&gt;, 基本上, 從 Leo Editor 節點, 將新資料送到 Wordpress 系統的按鈕程式.&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
# new_to_wp 按鍵
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    data_list = data.split("\n")
    # 只有一項資料的 category 型別為字串
    category = data_list[0]
    # 只有一項資料的 tags 型別為字串
    tags = data_list[1]
    # 有多項資料的 content 型別為數列
    # 再將第3行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[2:])
    return category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
# Open a file, 這裡將存取 Wordpress 網誌的對應帳號與密碼, 存在操作系統中
# 路徑則從資料節點上層根節點的 body 內文取得
fo = open(p.parent().b, "r+")
data = []
for line in fo.readlines():
    data.append(line)
    #print(line)
#print(data[0])

# Close opend file
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+p.parent().h+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

title = p.h
#content = p.b
category_str, tags_str, content = get_cat_tag_content(p.b)
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 (因為伺服主機與操作端時差而定)
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
#categories = ["Uncategorized"]
#tags = ["python", "測試"]
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()    
to_save_post_id.b = post_id
to_save_post_id.h = "文章 id"
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")
'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;至於在 Leo Editor 系統中, 用來編輯既有的 Wordpress 文章的按鈕節點程式碼, 則為:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#edit_to_wp
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    data_list = data.split("\n")
    # 只有一項資料的 category 型別為字串
    category = data_list[0]
    # 只有一項資料的 tags 型別為字串
    tags = data_list[1]
    # 有多項資料的 content 型別為數列
    # 再將第3行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[2:])
    return category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
# Open a file
fo = open(p.parent().b, "r+")
data = []
for line in fo.readlines():
    data.append(line)
    #print(line)
#print(data[0])

# Close opend file
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+p.parent().h+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

title = p.h
#content = p.b
category_str, tags_str, content = get_cat_tag_content(p.b)
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 (因為伺服主機與操作端時差而定)
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
#categories = ["Uncategorized"]
#tags = ["python", "測試"]
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
post_id = origin_post.b
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;最後若要經由 Leo Editor 的節點按鈕, 取回既有的 Wordpress 網誌文章, 則可以使用 get_from_wp 按鈕節點:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#get_from_wp
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html

#################################
# Open a file
fo = open(p.parent().b, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+p.parent().h+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.b
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost (post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 索取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
p.b = "categories:"+categories_str+"\ntags:"+mt_keywords+"\n"+post_content
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;好了, 上面的3個 Leo Editor 的按鈕節點程式, 只是從操作系統的特定路徑取出能夠管理遠端 Wordpress 網誌系統的帳號密碼, 然後再透過 XML-RPC 協定, 進行 Wordpress 網誌文章的新增、編輯與取回, 表示使用者可以在一個 Leo Editor 專案檔中完成這些事, 接下來則需要讓 Pelican 轉出的 html 檔案, 能夠同步送到對應的 Wordpress 動態網誌系統, 並且可以做到即時的內容同步, 既可保有靜態網誌的版次管理與單純伺服架構, 而且又可以將 Wordpress 視為 Pelican 的另外一個出口 (意思就是說, Wordpress 中只有特定的內容由 Pelican 端提供, 其他的使用者則仍然透過瀏覽器的方法對 Wordpress 網誌提供內容), 至於後續的處理與可行性驗證, 將在隨後的文章中進行討論.&lt;/p&gt;</summary><category term="Pelican"></category><category term="Wordpress"></category></entry><entry><title>yen - Pelican 靜態網頁與 Wordpress 的整合方案</title><link href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html</id><summary type="html">&lt;p&gt;利用 Leo Editor 的節點資料程式方法, 可以讓 Pelican 靜態網誌的內容與 Wordpress 動態網誌保持同步.&lt;/p&gt;


&lt;p&gt;因為 Pelican 靜態網頁結合 Github Pages 網站, 可以完整保留各版本的所有差異資料 ,而 Wordpress 的動態特性也具有即時更新的優點, 因此本機械設計專題網站, 就利用 Leo Editor 建立了3個按鈕, 可以在靜態與動態網誌之間雙向交換內容.&lt;/p&gt;
&lt;p&gt;首先是先編寫 Pelican 網誌的文章, 然後再經由下列 Leo Editor 的按鈕, 以 XML-RPC 協定, 將文章送到對應的 Wordpress 網誌.&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
＃new-to-wp button
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/your/wordpress/username/and/passwrod.txt"
wordpress = "your.wordpress.site.domain"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;其中 filepath 是存放 Wordpress 網誌管理帳號與密碼的存文字檔案路徑 (例如: "/home/user/file.txt"), 而 wordpress 則宣告希望對應連結的網址 (例如: "www.yoursite.blog").&lt;/p&gt;
&lt;p&gt;當 Wordpress 的網誌文章新增後, 若 Pelican 端的文章改版, 則可以透過下列 edit-to-wp 按鈕進行更新:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
# edit-to-wp
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/your/wordpress/username/and/passwrod.txt"
wordpress = "your.wordpress.site.domain"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;最後, 假如使用者透過 Wordpress 的瀏覽器介面新增文章, Pelican 端也可以準備一個空白節點, 並將文章的 id 號碼作為該空白節點的子節點, 且將該子節點的 header, 設為文章的 id 數, 接下來再用滑鼠停在父空白節點上, 然後以滑鼠點按下列的 get-from-wp 按鈕, 就可以將 Wordpress 端的文章取回, 且節點標題會被填入該文章的標題, 之後 Pelican 端的使用者再依據規劃, 以 @clean 存檔的標題命名該節點.&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
# get-from-wp
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html

#################################
filepath = "/your/wordpress/username/and/passwrod.txt"
wordpress = "your.wordpress.site.domain"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&lt;!--more--&gt;', '\n&lt;!-- PELICAN_END_SUMMARY --&gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</summary><category term="Pelican"></category><category term="Wordpress"></category></entry><entry><title>yen - 如何參與 project.mde.tw 的協同編輯</title><link href="http://project.mde.tw/blog/yen-ru-he-can-yu-projectmdetw-de-xie-tong-bian-ji.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ru-he-can-yu-projectmdetw-de-xie-tong-bian-ji.html</id><summary type="html">&lt;p&gt;只要是 KMOL 機械設計專題的成員, 就可以依照特定程序, 管理 project.mde.tw 網站上的資料&lt;/p&gt;


&lt;p&gt;首先, 你必須是 &lt;a href="https://github.com/coursemdetw/project_site/watchers"&gt;https://github.com/coursemdetw/project_site/watchers&lt;/a&gt; 名單上的成員, 否則就必須透過 Pull Request 的方式來參與 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 網誌內容的協同管理.&lt;/p&gt;
&lt;p&gt;接下來, 利用 git clone 的方式, 將 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 的倉儲資料複製到近端, 並且將分支切換到 gh-pages, 就可以利用 Leo Editor 開啟或建立, 位於 users 目錄中的 user_template.leo, 然後轉存為"學號.leo" 檔案, 透過這個 Leo Editor 的專案檔, 就可以新增文章, 修改其他人的文章, 甚至修改本網誌系統中的任何設定.&lt;/p&gt;
&lt;p&gt;將 user_template.leo 轉存為 "學號.leo" 後, 第1件重要的事就是修改 @edit user_20160301.md 中的 user_20160301.md 的存檔檔名, 改為 學號_當天日期.md, 然後修改此一 md 檔案的文章標題: Title: user - 使用者的範例網誌文章標題, 因為這個網誌系統根據 Title: 之後的名稱來轉換 html, 若有兩個 .md 檔案的 Title: 資料完全一樣, Pelican 將無法轉檔, 並且會在轉檔的命令列中出現錯誤訊息.&lt;/p&gt;
&lt;p&gt;其他的 .md 檔案中, Category: 為文章的類別, 可以參考現有的"2016g1, Misc 與 Tutorial" 等3個類別, 可以是組別或是文章的屬性類別.
Tags: 則是文章的內容標籤,可以就文章的內容關鍵字加以界定, 至於 Author: 則是用戶的名稱.&lt;/p&gt;
&lt;p&gt;在每一個 .md 檔案中, 出現在 "PELICAN_END_SUMMARY" 超文件註解標註之前的內容, Pelican 會視為文章的摘要, 當各文章並列時, 文章只會列出標題與摘要.&lt;/p&gt;
&lt;p&gt;"PELICAN_END_SUMMARY" 超文件註解標註之後的內容就是文章的主要內容.&lt;/p&gt;
&lt;p&gt;文章中的程式可以利用:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
for i in range(5):
    print(i, ":hello")
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;來加以標示.&lt;/p&gt;
&lt;p&gt;圖檔則可以利用 img 標註引用:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/chiamingyen/kmolab/gh-pages/logo/kmol_1172x340_color_3yrs.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;影片引用則可以直接使用 Vimeo 或 Youtube 的 embedded 語法.&lt;/p&gt;
&lt;p&gt;因為本網誌能夠在近端與遠端等兩個不同環境下運作, 而兩端的關鍵字搜尋流程與格式不同, 因此轉檔的按鈕也分為 local-pelican 與 gh-pages-pelican 等兩個, 要在近端測試時, 必須滑鼠停在 local-pelican 轉檔按鈕的對應節點上, 然後按下 local-pelican, 經過瀏覽器檢查近端文章轉檔與內容無誤後, 必須將滑鼠停在 gh-pages-pelican 轉檔按鈕的對應節點上, 然後按下 gh-pages-pelican 按鈕, 之後若無任何問題, 就可以將資料提交推送到遠端倉儲的 gh-pages 分支中, 指令如下:&lt;/p&gt;
&lt;p&gt;git add -A&lt;/p&gt;
&lt;p&gt;git commit -m "提交說明訊息"&lt;/p&gt;
&lt;p&gt;git push origin gh-pages&lt;/p&gt;
&lt;p&gt;最後, 與 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 網站維護有關的訊息溝通或註記, 請透過 &lt;a href="https://github.com/coursemdetw/project_site/wiki/%E6%A9%9F%E6%A2%B0%E8%A8%AD%E8%A8%88%E5%B0%88%E9%A1%8C%E5%8D%94%E5%90%8C%E7%B6%B2%E7%AB%99%E8%A8%98%E4%BA%8B"&gt;倉儲 Wiki&lt;/a&gt; 進行.&lt;/p&gt;</summary><category term="Pelican"></category><category term="Leo Editor"></category></entry><entry><title>yen - 網際 Flask 程式架構</title><link href="http://project.mde.tw/blog/yen-wang-ji-flask-cheng-shi-jia-gou.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-wang-ji-flask-cheng-shi-jia-gou.html</id><summary type="html">&lt;p&gt;Flask 是一套支援 Python3 的全球資訊網程式框架, 這裡希望用它來開發網際輔助機械設計程式.&lt;/p&gt;


&lt;p&gt;&lt;a href="http://flask.pocoo.org/"&gt;http://flask.pocoo.org/&lt;/a&gt; 是一套簡潔的 Python3 網際程式框架, 在這一系列的導引資料中, 將利用 &lt;a href="https://github.com/2015fallhw/simpleflask"&gt;https://github.com/2015fallhw/simpleflask&lt;/a&gt; 倉儲來存放資料, 並將資料同步推送到 &lt;a href="http://simpleflask-2014openshift.rhcloud.com/"&gt;http://simpleflask-2014openshift.rhcloud.com/&lt;/a&gt; 執行.&lt;/p&gt;
&lt;h2&gt;程式環境&lt;/h2&gt;
&lt;p&gt;假如在 Windows 環境中, 使用可攜套件: &lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;, 則已經內建 Flask 模組, 假如沒有, 可以利用&lt;/p&gt;
&lt;p&gt;pip install Flask 安裝.&lt;/p&gt;
&lt;p&gt;假如是在 Ubuntu, 可以要用 pip3 install Flask 安裝, 至於在 OpenShift 的 Python3 應用程式, 則是透過 setup.py 安裝.&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#setup.py 檔案
from setuptools import setup

setup(name='KMOL 2016 project',
      version='1.0',
      description='OpenShift App',
      author='KMOL',
      author_email='course@mde.tw',
      url='https://www.python.org/community/sigs/current/distutils-sig',
      install_requires=['Flask&gt;=0.10.1'],
     )
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;由於這裡所開發的 Flask 程式, 需要在近端與 OpenShift 都能運作, 因此 wsgi.py 的內容設計為:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#!/usr/bin/python
# 導入 os 模組, 主要用來判斷是否在 OpenShift 上執行
import os
# 導入同目錄下的 myflaskapp.py
import myflaskapp

# 以下開始判斷在 OpenShift 或近端執行
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示程式在雲端執行
    application = myflaskapp.app
else:
    # 表示在近端執行, 以 python3 wsgi.py 執行,  若採 uwsgi 則與 Openshift 運作模式相同
    myflaskapp.app.run(debug=True)
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;也就是說, wsgi.py  會透過os.environ.keys() 的值來判定執行的環境, 若是在 uwsgi 的環境執行時, 則必須使用與 OpenShift 環境相同的啟動模式.&lt;/p&gt;
&lt;p&gt;而 wsgi.py 中所導入的 myflaskapp.py 內容則為:&lt;/p&gt;
&lt;pre class="brush: python; html-script: false"&gt;
# coding: utf-8
from flask import Flask, send_from_directory, request, redirect, render_template, session, make_response
import random

app = Flask(__name__)

# 使用 session 必須要設定 secret_key
# In order to use sessions you have to set a secret key
# set the secret key.  keep this really secret:
app.secret_key = 'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T'

@app.route("/")
def index():
    #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零
    # 將標準答案存入 answer session 對應區
    theanswer = random.randint(1, 100)
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    session['answer'] = theanswer
    session['count'] = thecount

    return render_template("index.html", answer=theanswer, count=thecount)

@app.route('/user/&lt;name&gt;')
# 為了避免 syntaxhighlighter 自動加上 &lt;/name&gt;, 在這裡先行用註解補上, 之後再找解決方案
def user(name):
    return render_template("user.html", name=name)
@app.route('/red')
def red():
    # 重新導向 google
    return redirect("http://www.google.com")
@app.route('/guessform')
def guessform():
    session["count"] += 1
    guess = session.get("guess")
    theanswer = session.get("answer")
    count = session.get("count")
    return render_template("guessform.html", guess=guess, answer=theanswer, count=count)
@app.route('/docheck', methods=['POST'])
def docheck():
    # session[] 存資料
    # session.get() 取 session 資料
    # 利用 request.form[] 取得表單欄位資料, 然後送到 template
    guess = request.form["guess"]
    session["guess"] = guess
    # 假如使用者直接執行 doCheck, 則設法轉回根方法
    if guess is None:
        redirect("/")
    # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況
    try:
        theanswer = int(session.get('answer'))
    except:
        redirect("/")
    # 經由表單所取得的 guess 資料型別為 string
    try:
        theguess = int(guess)
    except:
        return redirect("/guessform")
    # 每執行 doCheck 一次,次數增量一次
    session["count"] += 1
    count = session.get("count")
    # 答案與所猜數字進行比對
    if theanswer &lt; theguess:
        return render_template("toobig.html", guess=guess, answer=theanswer, count=count)
    elif theanswer &gt; theguess:
        return render_template("toosmall.html", guess=guess, answer=theanswer, count=count)
    else:
        # 已經猜對, 從 session 取出累計猜測次數
        thecount = session.get('count')
        return "猜了 "+str(thecount)+" 次, 終於猜對了, 正確答案為 "+str(theanswer)+": &lt;a href='/'&gt;再猜&lt;/a&gt;"
    return render_template("docheck.html", guess=guess)

@app.route('/option', methods=["GET", "POST"])
def option():
    option_list1 = ["1", "2", "3", "4"]
    option_list2 = ["a", "b"]

    return render_template('option.html', option_list1=option_list1, option_list2=option_list2)
@app.route('/optionaction', methods=['POST'])
def optionaction():
    # 這裡將根據使用者所選擇的選項值, 來進行後續的設計運算
    return request.form["option1"] + ":" + request.form["option2"]
    # 等運算或資料處理結束後, 再將相關值送到對應的 template 進行資料的展示
    #return render_template('optionaction.html', option_list1=option_list1, option_list2=option_list2)


if __name__ == "__main__":
    app.run()
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;此外, 因為 Flask 內定靜態目錄名稱為 static, 且 template 名稱為 templates, 因此在最基本的 Flask 程式架構中, 也需要自行建立這兩個目錄, 然後將靜態文件放入 static 目錄中, 而對應的  template 文件檔案, 則放入 templates 目錄中.&lt;/p&gt;</summary><category term="OpenShift"></category><category term="Flask"></category></entry><entry><title>yen - 2016 年專題啟動</title><link href="http://project.mde.tw/blog/yen-2016-nian-zhuan-ti-qi-dong.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-2016-nian-zhuan-ti-qi-dong.html</id><summary type="html">&lt;p&gt;利用 Github Pages 與 Pelican 建立協同專題製作網誌&lt;/p&gt;


&lt;h2&gt;機械設計工程網誌啟動&lt;/h2&gt;
&lt;p&gt;本網誌自 2016 Spring 開始啟動, 相關建置步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以 &lt;a href="https://github.com/coursemdetw"&gt;https://github.com/coursemdetw&lt;/a&gt; 帳號建立 Gihub 倉儲 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;將倉儲資料 git clone 到近端&lt;/li&gt;
&lt;li&gt;利用 git branch 指令, 建立 gh-pages 分支&lt;/li&gt;
&lt;li&gt;利用 git checkout 指令, 切換至 gh-pages 分支&lt;/li&gt;
&lt;li&gt;開始建立 Pelican 網誌所需的協同架構資料&lt;/li&gt;
&lt;li&gt;安排 users 目錄, 將分別存放各協同組員的 .leo 檔案&lt;/li&gt;
&lt;li&gt;確定 gh-pages 分支中的網誌 &lt;a href="http://coursemdetw.github.io/project_site/"&gt;http://coursemdetw.github.io/project_site/&lt;/a&gt; 可以正常運作&lt;/li&gt;
&lt;li&gt;根據 Github pages 專用網域設定說明 &lt;a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/"&gt;https://help.github.com/articles/using-a-custom-domain-with-github-pages/&lt;/a&gt;, 建立 CNAME, 納入 project.mde.tw&lt;/li&gt;
&lt;li&gt;將 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 倉儲的 Default Branch 設為 gh-pages 分支&lt;/li&gt;
&lt;li&gt;在 mde.tw 網域的 DNS 代管設定中, 加入 project.mde.tw 與 coursemdetw.github.io 之間的 CNAME 別名設定&lt;/li&gt;
&lt;li&gt;等待 CNAME 別名生效後, &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 即可正常連結使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Pelican 網誌設定&lt;/h2&gt;
&lt;p&gt;由於本網誌將 Pelican &lt;a href="https://github.com/getpelican/pelican"&gt;https://github.com/getpelican/pelican&lt;/a&gt; 設定相關的所有資料都留在 Gihub 倉儲 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 中, 目的在讓其他人可以參考本網誌的所有細節內容. 一般在實際應用, 只需將 blog 目錄 &lt;a href="https://github.com/coursemdetw/project_site/tree/gh-pages/blog"&gt;https://github.com/coursemdetw/project_site/tree/gh-pages/blog&lt;/a&gt; 中的資料送到全球資訊網伺服器即可.&lt;/p&gt;
&lt;p&gt;本專題製作採用 &lt;a href="http://leoeditor.com/"&gt;http://leoeditor.com/&lt;/a&gt; 管理所有資料, 但各參與協同的人員各自在 users 目錄下擁有一個 .leo 檔案, 可以分別控管本網誌的所有設定, 並且以協同方式維護網誌內容.&lt;/p&gt;
&lt;p&gt;本網誌分為近端與 Github Pages 端的資料管理配置, 關鍵字搜尋採用 &lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/tipue_search"&gt;https://github.com/getpelican/pelican-plugins/tree/master/tipue_search&lt;/a&gt;, 近端的設定檔案為 local_publishconf.py, 而 Github Pages 端的特有設定為 publishconf.py, 且為了區隔兩端的資料連結差異, 近端的 Pelican 轉檔按鈕為 @button local pelican, 而 Github Pages 端的轉檔按鈕為 @button gh-pages pelican.&lt;/p&gt;
&lt;p&gt;最後, 為了有效區隔各組員所寫的網誌文章, content 目錄內的各 .md 檔案, 除了要求必須冠上組員帳號外, 也希望在文章標題前面加上組員帳號標示, 以避免組員間因為使用相同的文章標題名稱而無法正確完成 Pelican 網誌的轉檔 (本系統採用自動文章標題轉換為 html 檔名的設定).&lt;/p&gt;
&lt;h2&gt;組員參與協同&lt;/h2&gt;
&lt;p&gt;所有專題製作成員均為 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 倉儲的協同者, git clone 資料後, 即可將分支固定在 gh-pages 後進行各項資料協同管理的工作.&lt;/p&gt;
&lt;p&gt;參與協同的步驟:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git clone 倉儲資料.&lt;/li&gt;
&lt;li&gt;確定在近端已經切換分支到 gh-pages, 利用  Leo Editor 開啟 users 目錄下的 user_template.leo 檔案.&lt;/li&gt;
&lt;li&gt;修改 @edit user_20160301.md 的標題與內容, 例如, 將 @edit user_20160301.md 改為 @edit 學號_20160301.md, 且將 "Title: user - 使用者的範例網誌文章標題" 改為 "Title: 學號 - 使用者的範例網誌文章標題", "Author: user" 改為 "Author: 學號" 之後, 記得將已經修改過的 user_template.leo 存為 學號.leo 檔案.&lt;/li&gt;
&lt;li&gt;在學號.leo 專案檔案中, 將滑鼠停在 @button local pelican 節點上, 再點擊 local-pelican 按鈕進行轉檔, 最後利用瀏覽器開啟 project_site 目錄中的 index.html, 檢查是否在近端可以正確轉檔.&lt;/li&gt;
&lt;li&gt;若近端的 Pelican 網誌可以正確納入所新增的文章內容, 改將滑鼠停在 @button gh-pages pelican 節點上, 再點擊 gh-pages-pelican 按鈕, 進行 Github Pages 端所需要的內容轉檔.&lt;/li&gt;
&lt;li&gt;利用 git add -A, git commit -m "訊息", git push origin gh-pages 等3個步驟, 將 gh-pages 分支資料,  提交並推送到 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;網誌資料儲存規劃&lt;/h2&gt;
&lt;p&gt;一個靜態網站的內容除了文字檔案外, 還包括 Javascript 檔案, Brython 檔案, 圖檔, 影片檔案, 以及其他各種非 html 的文件檔, 為了保有本網誌專案倉儲的簡潔, 除了必要的設定與文字檔案外, 其他資料均存放在倉儲以外的相關資源位置, 其規劃如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Javascript 與 Brython 程式檔案, 除了儘量使用各 CDN 所提供的最新版本外, 目前以 &lt;a href="https://github.com/2015fallhw/cptocadp/tree/master/static"&gt;https://github.com/2015fallhw/cptocadp/tree/master/static&lt;/a&gt; 對應的 OpenShift 網站存放, 例如, Cango-8v03.js 位於 &lt;a href="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一般圖檔與非 html 文件檔案, 建議以 Github Pages 的網頁架構儲存在獨立的倉儲中, 且該倉儲僅存放檔案, 而無文字檔案, 例如:
&lt;a href="http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png"&gt;http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png&lt;/a&gt; 即為其中的一個圖檔.&lt;/li&gt;
&lt;li&gt;影片檔案則分別存在 &lt;a href="https://vimeo.com/"&gt;https://vimeo.com/&lt;/a&gt; 與 &lt;a href="https://www.youtube.com/"&gt;https://www.youtube.com/&lt;/a&gt; (相同檔案各存一份).&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;圖檔引用&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png" width="600" /&gt;&lt;/p&gt;
&lt;h2&gt;影片檔引用&lt;/h2&gt;
&lt;iframe src="https://player.vimeo.com/video/147991541" width="600" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/147991541"&gt;Gocycle_disassemble&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;特別提醒&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;本網誌為了同時支援近端與遠端的資料內容使用, 資料轉檔分為近端按鈕與遠端按鈕, 協同成員在推送資料到遠端之前, 必須確定資料為遠端 Github Pages 格式.&lt;/li&gt;
&lt;li&gt;鼓勵各成員深入研究本網誌的細節架構, 勇於提出問題, 解決問題, 打造出最適合機械設計工程團隊使用的網際協同架構、模式與系統工具.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="教學導引"></category><category term="網誌設定"></category></entry><entry><title>yen - Github Pages 網頁資料更新問題</title><link href="http://project.mde.tw/blog/yen-github-pages-wang-ye-zi-liao-geng-xin-wen-ti.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-github-pages-wang-ye-zi-liao-geng-xin-wen-ti.html</id><summary type="html">&lt;p&gt;突然間, Github Pages 的網頁轉換機制不再更新&lt;/p&gt;


&lt;p&gt;使用 Github Pages 建立網頁最大的問題就是, 在完全沒有任何錯誤訊息提醒的情況下, 送到 Github Pages 對應分支倉儲的資料不再成功轉為網頁資料.&lt;/p&gt;
&lt;p&gt;因應之道, 只能刪除原先不再更新的倉儲, 另外再建立一個對應的 Github Pages 倉儲, 重新進行各項設定.&lt;/p&gt;</summary><category term="Github Pages"></category></entry><entry><title>yen - 機械設計專題分類</title><link href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-fen-lei.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ji-jie-she-ji-zhuan-ti-fen-lei.html</id><summary type="html">&lt;p&gt;機械設計專題題目的分類, 一般就學門領域的組合, 可視為熱流體力學, 固體力學, 電子電機與資訊科技的綜合體.&lt;/p&gt;


&lt;p&gt;雖然機械設計專題, 以設計流程為主, 但是通常離不開製造、控制與管理的範疇. 也就是說, 機械設計流程必須納入製造、控制與管理的層面, 才能得到更大的價值.&lt;/p&gt;
&lt;p&gt;機械指的是機巧的配置, 而配置的內容, 來自熱流體力學, 固體力學, 電子電機與資訊科技的內涵, 其中更因不同的設計、製造、控制與管理流程, 而產生不同的功用.&lt;/p&gt;
&lt;p&gt;至於設計則隱含內容的表達與驗證, 其表達的方式通常指口語表達, 文字表達, 2D 圖形表達, 3D 影像表達, 理論分析表達與實體原型的表達等六大類.&lt;/p&gt;
&lt;p&gt;因此機械設計專題, 就可以從熱流體力學, 固體力學, 電子電機與資訊科技的組合搭配中, 納入各種設計、製造、控制與管理工具的運用, 最後用表達方式加以呈現的差異, 進行分類.&lt;/p&gt;
&lt;p&gt;換言之, 機械設計專題的題目與施行內容的分類, 可以從3個大軸向切入:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所包含的學門領域軸向, 也就是熱流體力學, 固體力學, 電子電機與資訊科技等.&lt;/li&gt;
&lt;li&gt;所牽涉的流程層面, 也就是設計、製造、控制與管理流程等.&lt;/li&gt;
&lt;li&gt;所使用的表達方式, 也就是口語表達, 文字表達, 2D 圖形表達, 3D 影像表達, 理論分析表達與實體原型的表達等.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中隸屬於設計的工程設計面, 又可細分為:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;選用設計, 也就是從現有的零件或配件群中選用的設計.&lt;/li&gt;
&lt;li&gt;配置設計, 也就是根據所選擇的零配件加以組合, 以決定設計的組合順序或組合方式.&lt;/li&gt;
&lt;li&gt;參數設計, 也就是決定內容所需的數據或尺寸.&lt;/li&gt;
&lt;li&gt;原創設計, 也就是前所未見的配置參數設計或前所未見的整體設計.&lt;/li&gt;
&lt;li&gt;重新設計, 也就是根據的新的需求、新的材料與元件發明, 所進行的設計.&lt;/li&gt;
&lt;li&gt;客製化設計, 又稱為多選項設計, 也就是設計中的每一個功能, 都提供客戶不同等級的元件選擇所牽涉的設計.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;總之, 這裡針對機械設計專題題目分類的目的, 在讓選擇專題題目與製作內容的成員能有些初步概念, 儘管機械設計的範圍很廣, 能夠採用的方式與納入的內容也很多, 但是只要關注機械設計所牽涉的領域、流程與表達方法, 使專題題目具有代表性與功能性, 就能讓最後交付的內容更具價值.&lt;/p&gt;</summary><category term="專題"></category><category term="機械設計"></category></entry><entry><title>yen - 協同產品設計課程 Task0 延伸練習</title><link href="http://project.mde.tw/blog/yen-xie-tong-chan-pin-she-ji-ke-cheng-task0-yan-shen-lian-xi.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-xie-tong-chan-pin-she-ji-ke-cheng-task0-yan-shen-lian-xi.html</id><summary type="html">&lt;p&gt;如何將電腦教室分組, 比序與排座位的流程網際自動化&lt;/p&gt;


&lt;p&gt;在 &lt;a href="http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html"&gt;http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html&lt;/a&gt; 中, 說明了一個實際的電腦教室排座位的流程, 其中使用了網際即時試算表 &lt;a href="https://ethercalc.tw/"&gt;https://ethercalc.tw/&lt;/a&gt;, 以及幾個 Python3 的資料處理程式, 最後可以根據電腦教室的配置, 完成各組員的座位編排.&lt;/p&gt;
&lt;p&gt;座位編排流程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;讓所有學員自行分組&lt;/li&gt;
&lt;li&gt;分組確定後, 根據學號比序, 產生各組組長&lt;/li&gt;
&lt;li&gt;再根據各組組長學號, 再進行組長學號比序, 以決定各組的組序&lt;/li&gt;
&lt;li&gt;完成各組序與各組內的組員順序後, 再根據座位編排規定, 最後列出學員座位表, 讓學員依序入座&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本機械設計專題製作練習, 希望能夠利用網際程式方法, 以  &lt;a href="https://github.com/mitsuhiko/flask"&gt;https://github.com/mitsuhiko/flask&lt;/a&gt;, &lt;a href="https://www.sqlite.org/"&gt;https://www.sqlite.org/&lt;/a&gt; 將流程自動化, 當操作者從網際即時試算表中取得各組分組資料後, 可以輸入本練習所完成的網站表單中, 然後操作者可以根據頁面中的選項, 選擇各組選出組長的方式, 依據學號增量排序, 學號最小者為組長, 或遞減排序, 學號大者為組長, 或者亂數排序後, 排序第一組為組長等三種選擇.&lt;/p&gt;
&lt;p&gt;接著操作者可以在頁面選擇組序排列的選項, 也是學號遞增排序, 學號遞減排序或學號亂數排序, 以便訂出各組的組序.&lt;/p&gt;
&lt;p&gt;當操作者決定各組內與組外的排序選項後, 按下"排電腦教室座位" (也可加入排座位的選項, 列先排, 行先排或者全部按亂數排.&lt;/p&gt;
&lt;p&gt;完成座位安排後, 必須將各組組員名單與分組名單分別存入資料庫, 以便後續讓使用者查詢各組座位與分組資訊, 並且在隨後
加入各組員回報電腦使用情形與各組員自評登錄成績之應用.&lt;/p&gt;
&lt;p&gt;原始倉儲資料: &lt;a href="https://github.com/2015fallhw/2016springcd/tree/gh-pages"&gt;https://github.com/2015fallhw/2016springcd/tree/gh-pages&lt;/a&gt;&lt;/p&gt;</summary><category term="Flask"></category><category term="Brython"></category><category term="Python"></category><category term="練習"></category><category term="流程自動化"></category></entry><entry><title>user - 使用者的範例網誌文章標題</title><link href="http://project.mde.tw/blog/user-shi-yong-zhe-de-fan-li-wang-zhi-wen-zhang-biao-ti.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>user</name></author><id>tag:project.mde.tw,2016-07-01:blog/user-shi-yong-zhe-de-fan-li-wang-zhi-wen-zhang-biao-ti.html</id><summary type="html">&lt;p&gt;這裡放入 user 所寫的文章摘要&lt;/p&gt;


&lt;p&gt;這裡為 user 所寫的文章主要內容&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323250日誌 - 105/06/28</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050628.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323250ri-zhi-1050628.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;


&lt;h3&gt;目前組合進度&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/D2k3uqk.gif"&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的狀況&lt;/h3&gt;
&lt;h4&gt;我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/W3N5pkC.png"&gt;
&lt;/br&gt;
&lt;h4&gt;滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/29</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050629.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323250ri-zhi-1050629.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;


&lt;h3&gt;進度&lt;/h3&gt;

&lt;h4&gt;目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖:&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/OCcfYur.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/64Qlmfm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是v-rep拆解後的截圖&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;簡易版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/1C9EKl2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;完整版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/I7q77aX.png"&gt;
&lt;/br&gt;
&lt;h3&gt;明天應該就可以開始測試模擬了。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>Summer Plan</title><link href="http://project.mde.tw/blog/summer-plan.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-01:blog/summer-plan.html</id><summary type="html">&lt;p&gt;Summer project&lt;/p&gt;


&lt;p&gt;1.畫3D Printer (V-rep ,Onshape)&lt;/p&gt;

&lt;p&gt;2.實驗室網站介面&lt;/p&gt;

&lt;p&gt;3.Octopi ,機械手臂&lt;/p&gt;

&lt;p&gt;4.OpenCV &lt;/p&gt;

&lt;p&gt;5.RGA演算&lt;/p&gt;

&lt;p&gt;6.認證主機(Virtual Box)&lt;/p&gt;

&lt;p&gt;7.Proxy&lt;/p&gt;

&lt;p&gt;8.報告(拍照 ,內容整理)&lt;/p&gt;

&lt;p&gt;9.找碩班教授&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;暑期人數 : &lt;/p&gt;
&lt;p&gt;七月:第一組3人 ,第二組4人&lt;/p&gt;
&lt;p&gt;八月:第一組3人 ,第二組4人 ,第三組1人&lt;/p&gt;
&lt;p&gt;&lt;font size="5" face="Arial"&gt;&lt;marquee border="0" scrollamount="50" behavior="alternate"&gt;You can't see me&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323143 - 日誌 105年6月28日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-28ri.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323143-ri-zhi-105nian-6yue-28ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將所有機械手臂零件全部合進零件庫，並用零件庫的零件再組合出一個組圖。今天沒有設定新的變數，未來將會新增有關手臂長度的零件參數，並由實際使用需求及感測器尺寸調整參數。&lt;/p&gt;
&lt;p&gt;備註:&lt;/p&gt;
&lt;p&gt;1.夾頭動力傳輸由原先畫的6齒圓齒輪改成25齒的正齒輪&lt;/p&gt;
&lt;p&gt;6/28零件庫&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wrPCKrc.png"&gt;&lt;/p&gt;
&lt;p&gt;組合圖&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GrrtDHo.png"&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>OpenCv範例執行</title><link href="http://project.mde.tw/blog/opencvfan-li-zhi-xing.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-01:blog/opencvfan-li-zhi-xing.html</id><summary type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;


&lt;h3&gt;實作系統Ubuntu 14.04 以及 老師整合的檔案&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image"&gt;範例網址1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/picture/messi.jpg"&gt;使用到的圖片&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
img = cv2.imread('messi.jpg',0)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv2.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv2.imwrite('messigray.png',img)
    cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/tI55TDf.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html#display-video"&gt;範例網址2.&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)
while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break&lt;/p&gt;
&lt;h1&gt;When everything done, release the capture&lt;/h1&gt;
&lt;p&gt;cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/MOL03LL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;範例網址3.(同上)&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)&lt;/p&gt;
&lt;h1&gt;Define the codec and create VideoWriter object&lt;/h1&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        # write the flipped frame
        out.write(frame)
        cv2.imshow('frame',frame)
        if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
            break
    else:
        break&lt;/p&gt;
&lt;h1&gt;Release everything if job is finished&lt;/h1&gt;
&lt;p&gt;cap.release()
out.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;h4&gt;得到檔案名稱為output的avi影片檔&lt;/h4&gt;&lt;/p&gt;</summary><category term="OpenCv"></category></entry><entry><title>40323143 - 3D printer 列印完下料後的倉儲機構設計理念及繪圖</title><link href="http://project.mde.tw/blog/40323143-3d-printer-lie-yin-wan-xia-liao-hou-de-cang-chu-ji-gou-she-ji-li-nian-ji-hui-tu.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323143-3d-printer-lie-yin-wan-xia-liao-hou-de-cang-chu-ji-gou-she-ji-li-nian-ji-hui-tu.html</id><summary type="html">&lt;p&gt;只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容&lt;/p&gt;


&lt;p&gt;這裡為 40323130 所寫的文章主要內容&lt;/p&gt;
&lt;p&gt;這是設計構想的全圖&lt;/p&gt;
&lt;p&gt;&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/asm0001.stl"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;我的想法是讓3D printer 在一個輸送帶上的平面列印，在輸送帶後方因為曲率不同使成品自然脫落，然後用一個盛盤接住成品一動到固定位置，使成盤傾斜讓成品掉落我們想要放置的位置。&lt;/p&gt;
&lt;p&gt;我使用一個由上而往看下呈一個工字型的機構，因為我認為這種機構機構簡單、組裝容易、運動路徑明確，控制上應該比較方便，可以節省很多製造、控制上的麻煩。&lt;/p&gt;
&lt;p&gt;動力方面想使用馬達接上摩擦輪驅動另外兩個摩擦輪，原本想用齒輪作為動力傳輸，但考慮到組原想要自己製造出來的想法，齒輪對我們來說製造難度太高，所以改用摩擦輪。&lt;/p&gt;
&lt;p&gt;組裝上也是盡量用簡單方便的方法組裝，例如摩擦輪就只是挖一個槽用重力固定，馬達安裝是用夾板鎖螺栓固定，其餘都是鎖螺栓夾緊，在組裝上應該不會有困難。&lt;/p&gt;
&lt;p&gt;零件圖:&lt;/p&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/1long.stl"&gt;&lt;/script&gt;

&lt;p&gt;&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/2long.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/3.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/3long.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/4-02.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/4-46.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/5.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/6.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/6-3.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/46-2.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/a.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/b.stl"&gt;&lt;/script&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 日誌 105年6月27日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-27ri.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323143-ri-zhi-105nian-6yue-27ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將個人Onshape上的機械手臂部分零件合進零件庫，設定六個參數，分別是motor_fixhole , motor_x , motor_y , motor_z , suan_pan , degore 六個參數，motor_fixhole為設定馬達固定孔大小，motor_x , motor_y , motor_z為設定馬達的長寬高， suan_pan為設定旋盤的大小，大小為motor_y的1.7倍，degore為設定底座的直徑，大小為3倍的suan_pan。&lt;/p&gt;
&lt;p&gt;合進零件庫的零件&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VoMTC8g.png"&gt;&lt;/p&gt;
&lt;p&gt;參數設定&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AsRWjtd.png"&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323130 - 說明如何參與協同機械設計專題網誌編寫</title><link href="http://project.mde.tw/blog/40323130-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323130</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323130-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html</id><summary type="html">&lt;p&gt;只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容&lt;/p&gt;


&lt;p&gt;這裡為 40323130 所寫的文章主要內容&lt;/p&gt;
&lt;p&gt;本機械設計專題網誌的架構包含近端與遠端的資料檢視設計, 專案資料以 Leo Editor 進行管理.&lt;/p&gt;
&lt;p&gt;以下教學影片示範從 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 機械設計專題網誌中取得倉儲的網址後, 可以利用 git clone 複製倉儲資料, 之後:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 git checkout gh-pages 將工作目錄指到 Github pages 的對應分支內容&lt;/li&gt;
&lt;li&gt;以 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案&lt;/li&gt;
&lt;li&gt;根據自己的帳號, 修改 .md 檔案存檔的名稱, 目的在透過加入帳號與時間註記, 避免 content 目錄中的檔案彼此複寫&lt;/li&gt;
&lt;li&gt;在 .md 的 Title 標題中, 冠上自己的帳號, 主要也是避免 Pelican 將 .md 根據標題轉成 html 時, 產生檔案複寫&lt;/li&gt;
&lt;li&gt;本系統的 Pelican 分為近端與遠端轉檔按鈕, 因此若要在近端檢查時, 與要推送到 Github 時採用不同轉檔按鈕&lt;/li&gt;
&lt;li&gt;為了簡化 git 指令的 add, commit 與 push, 加入 ungit, 只要啟動隨身系統候, 再利用 start_ungit.bat 開啟, 就可以在瀏覽器中簡化改版過程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vimeo:&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/157247703" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/157247703"&gt;2016project_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Youtube:&lt;/p&gt;
&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/hQR1wxALifU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="範例"></category></entry><entry><title>40323131日誌 105/06/28</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050628.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323131ri-zhi-1050628.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;研讀Octopi的設定檔&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;設定檔位置位在  /Octoprint/src/octoprint/setting.py&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/YJvnK0t.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定檔位置位在  /Octoprint/src/octoprint/static/less/octoprint.less&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/OfsVzCx.png"&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;目前遇到的問題&lt;/h3&gt;

&lt;h4&gt;host位置顯示在0.0.0.0:5000  可是網頁開起來無法顯示&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/9sqNCk1.png"&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323131日誌 105/06/30</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050630.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323131ri-zhi-1050630.html</id><summary type="html">&lt;p&gt;安裝wxpython 與 將control_3dprinter 從原本python2語法 修改成python3語法
&lt;/p&gt;
&lt;h3&gt;python2語法 修改成python3語法&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;原本圖片的紅框處為 except IOError, x:為python2語法，將它修改成能在python3上執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/yONrOlL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;原來python2 為Queue 將它修改成queue 因為python3裡頭更改成queue了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/sbLTZIj.png"&gt;
&lt;/br&gt;
&lt;h3&gt;還有要加上括號，因為python2上執行可以不需要括號起來，但是在python3上執行要加上小括號，目前找到這些語法問題
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;目前遇到的問題&lt;/h3&gt;

&lt;h4&gt;在下圖執行的時候跑出name 'reload' is not define &lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/FjZQHVW.png"&gt;
&lt;/br&gt;
&lt;h4&gt;上網google一下，找到了有可能是沒有reload到，所以多 import imp &lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/HhP42Gs.png"&gt;
&lt;/br&gt;
&lt;h4&gt;可是又遇到了下圖的問題，好像是python2默認的使用的是ascii，要將它更改成utf-8，不過看起來沒有成功&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/KZJt1YS.png"&gt;
&lt;/br&gt;
&lt;h4&gt;想要執行一下，來確認一下是否更改成功，不過不知道為什麼又跑出name 'reload' is not define&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/UmwpPJd.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;目前卡在這邊，無法想通為什麼會變成這樣&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323143 - 說明如何參與協同機械設計專題網誌編寫</title><link href="http://project.mde.tw/blog/40323143-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323143-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html</id><summary type="html">&lt;p&gt;只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容&lt;/p&gt;


&lt;p&gt;這裡為 40323130 所寫的文章主要內容&lt;/p&gt;
&lt;p&gt;本機械設計專題網誌的架構包含近端與遠端的資料檢視設計, 專案資料以 Leo Editor 進行管理.&lt;/p&gt;
&lt;p&gt;以下教學影片示範從 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 機械設計專題網誌中取得倉儲的網址後, 可以利用 git clone 複製倉儲資料, 之後:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 git checkout gh-pages 將工作目錄指到 Github pages 的對應分支內容&lt;/li&gt;
&lt;li&gt;以 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案&lt;/li&gt;
&lt;li&gt;根據自己的帳號, 修改 .md 檔案存檔的名稱, 目的在透過加入帳號與時間註記, 避免 content 目錄中的檔案彼此複寫&lt;/li&gt;
&lt;li&gt;在 .md 的 Title 標題中, 冠上自己的帳號, 主要也是避免 Pelican 將 .md 根據標題轉成 html 時, 產生檔案複寫&lt;/li&gt;
&lt;li&gt;本系統的 Pelican 分為近端與遠端轉檔按鈕, 因此若要在近端檢查時, 與要推送到 Github 時採用不同轉檔按鈕&lt;/li&gt;
&lt;li&gt;為了簡化 git 指令的 add, commit 與 push, 加入 ungit, 只要啟動隨身系統候, 再利用 start_ungit.bat 開啟, 就可以在瀏覽器中簡化改版過程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vimeo:&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/157247703" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/157247703"&gt;2016project_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Youtube:&lt;/p&gt;
&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/hQR1wxALifU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="範例"></category></entry><entry><title>Octopi測試與實作</title><link href="http://project.mde.tw/blog/octopice-shi-yu-shi-zuo.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/octopice-shi-yu-shi-zuo.html</id><summary type="html">&lt;p&gt;設定使用octopi與實作&lt;/p&gt;


&lt;p&gt;octopi走乙太網路線進行控制以及連線&lt;/p&gt;
&lt;p&gt;實際測試的照片以及需要用到的方法&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Umf1J3w.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zMUAcXs.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Sqh1bWP.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PzFmXoH.jpg"&gt;&lt;/p&gt;</summary><category term="Octopi"></category></entry><entry><title>PySerial</title><link href="http://project.mde.tw/blog/pyserial.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/pyserial.html</id><summary type="html">&lt;p&gt;更新資料Wxpython for python3&lt;/p&gt;


&lt;p&gt;安裝方法
https://www.youtube.com/watch?v=_djD5EHfNCw&lt;/p&gt;
&lt;pre class="brush: python"&gt;

#先檢查網路
#確定python版本為python3.4

pip install -U --trusted-host wxpython.org --pre -f https://wxpython.org/Phoenix/snapshot-builds/ wxPython_Phoenix

#記得打開terimal 檢查import wx
#看有沒有成功

#因為要做串列傳輸Serial
#要下指令安裝pyserial
pip install pyserial


&lt;/pre&gt;

&lt;h3&gt;接下來先用範例程式測試串列傳輸&lt;/h3&gt;

&lt;p&gt;&lt;html&gt;https://github.com/pyserial/pyserial/tree/master/examples&lt;/html&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;

#
#!/usr/bin/env python
#
# A simple terminal application with wxPython.
#
# (C) 2001-2015 Chris Liechti &lt;cliechti@gmx.net&gt;
#
# SPDX-License-Identifier:    BSD-3-Clause

import codecs
import serial
import threading
import wx
import wxSerialConfigDialog


SERIALRX = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0)


class SerialRxEvent(wx.PyCommandEvent):
    eventType = SERIALRX

    def __init__(self, windowID, data):
        wx.PyCommandEvent.__init__(self, self.eventType, windowID)
        self.data = data

    def Clone(self):
        self.__class__(self.GetId(), self.data)

# ----------------------------------------------------------------------

ID_CLEAR = wx.NewId()
ID_SAVEAS = wx.NewId()
ID_SETTINGS = wx.NewId()
ID_TERM = wx.NewId()
ID_EXIT = wx.NewId()
ID_RTS = wx.NewId()
ID_DTR = wx.NewId()

NEWLINE_CR = 0
NEWLINE_LF = 1
NEWLINE_CRLF = 2


class TerminalSetup:
    """
    Placeholder for various terminal settings. Used to pass the
    options to the TerminalSettingsDialog.
    """
    def __init__(self):
        self.echo = False
        self.unprintable = False
        self.newline = NEWLINE_CRLF


class TerminalSettingsDialog(wx.Dialog):
    """Simple dialog with common terminal settings like echo, newline mode."""

    def __init__(self, *args, **kwds):
        self.settings = kwds['settings']
        del kwds['settings']
        # begin wxGlade: TerminalSettingsDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.checkbox_echo = wx.CheckBox(self, -1, "Local Echo")
        self.checkbox_unprintable = wx.CheckBox(self, -1, "Show unprintable characters")
        self.radio_box_newline = wx.RadioBox(self, -1, "Newline Handling", choices=["CR only", "LF only", "CR+LF"], majorDimension=0, style=wx.RA_SPECIFY_ROWS)
        self.sizer_4_staticbox = wx.StaticBox(self, -1, "Input/Output")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.__attach_events()
        self.checkbox_echo.SetValue(self.settings.echo)
        self.checkbox_unprintable.SetValue(self.settings.unprintable)
        self.radio_box_newline.SetSelection(self.settings.newline)

    def __set_properties(self):
        # begin wxGlade: TerminalSettingsDialog.__set_properties
        self.SetTitle("Terminal Settings")
        self.radio_box_newline.SetSelection(0)
        self.button_ok.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalSettingsDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_4_staticbox.Lower()
        sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL)
        sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4)
        sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4)
        sizer_4.Add(self.radio_box_newline, 0, 0, 0)
        sizer_2.Add(sizer_4, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId())

    def OnOK(self, events):
        """Update data wil new values and close dialog."""
        self.settings.echo = self.checkbox_echo.GetValue()
        self.settings.unprintable = self.checkbox_unprintable.GetValue()
        self.settings.newline = self.radio_box_newline.GetSelection()
        self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        """Do not update data but close dialog."""
        self.EndModal(wx.ID_CANCEL)

# end of class TerminalSettingsDialog


class TerminalFrame(wx.Frame):
    """Simple terminal program for wxPython"""

    def __init__(self, *args, **kwds):
        self.serial = serial.Serial()
        self.serial.timeout = 0.5   # make sure that the alive event can be checked from time to time
        self.settings = TerminalSetup()  # placeholder for the settings
        self.thread = None
        self.alive = threading.Event()
        # begin wxGlade: TerminalFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        # Menu Bar
        self.frame_terminal_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_CLEAR, "&amp;Clear", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(ID_SAVEAS, "&amp;Save Text As...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_TERM, "&amp;Terminal Settings...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_EXIT, "&amp;Exit", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "&amp;File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_RTS, "RTS", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_DTR, "&amp;DTR", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_SETTINGS, "&amp;Port Settings...", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "Serial Port")
        self.SetMenuBar(self.frame_terminal_menubar)
        # Menu Bar end
        self.text_ctrl_output = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE | wx.TE_READONLY)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS)
        self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        # end wxGlade
        self.__attach_events()          # register events
        self.OnPortSettings(None)       # call setup dialog on startup, opens port
        if not self.alive.isSet():
            self.Close()

    def StartThread(self):
        """Start the receiver thread"""
        self.thread = threading.Thread(target=self.ComPortThread)
        self.thread.setDaemon(1)
        self.alive.set()
        self.thread.start()
        self.serial.rts = True
        self.serial.dtr = True
        self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts)
        self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr)

    def StopThread(self):
        """Stop the receiver thread, wait until it's finished."""
        if self.thread is not None:
            self.alive.clear()          # clear alive event for thread
            self.thread.join()          # wait until thread has finished
            self.thread = None

    def __set_properties(self):
        # begin wxGlade: TerminalFrame.__set_properties
        self.SetTitle("Serial Terminal")
        self.SetSize((546, 383))
        self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, ""))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        # register events at the controls
        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey)
        self.Bind(EVT_SERIALRX, self.OnSerialRead)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnExit(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Menu point Exit"""
        self.Close()

    def OnClose(self, event):
        """Called on application shutdown."""
        self.StopThread()               # stop reader thread
        self.serial.close()             # cleanup
        self.Destroy()                  # close windows, exit app

    def OnSaveAs(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Save contents of output window."""
        with wx.FileDialog(
                None,
                "Save Text As...",
                ".",
                "",
                "Text File|*.txt|All Files|*",
                wx.SAVE) as dlg:
            if dlg.ShowModal() == wx.ID_OK:
                filename = dlg.GetPath()
                with codecs.open(filename, 'w', encoding='utf-8') as f:
                    text = self.text_ctrl_output.GetValue().encode("utf-8")
                    f.write(text)

    def OnClear(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Clear contents of output window."""
        self.text_ctrl_output.Clear()

    def OnPortSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """
        Show the port settings dialog. The reader thread is stopped for the
        settings change.
        """
        if event is not None:           # will be none when called on startup
            self.StopThread()
            self.serial.close()
        ok = False
        while not ok:
            with wxSerialConfigDialog.SerialConfigDialog(
                    self,
                    -1,
                    "",
                    show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW,
                    serial=self.serial) as dialog_serial_cfg:
                dialog_serial_cfg.CenterOnParent()
                result = dialog_serial_cfg.ShowModal()
            # open port if not called on startup, open it on startup and OK too
            if result == wx.ID_OK or event is not None:
                try:
                    self.serial.open()
                except serial.SerialException as e:
                    with wx.MessageDialog(self, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)as dlg:
                        dlg.ShowModal()
                else:
                    self.StartThread()
                    self.SetTitle("Serial Terminal on {} [{},{},{},{}{}{}]".format(
                        self.serial.portstr,
                        self.serial.baudrate,
                        self.serial.bytesize,
                        self.serial.parity,
                        self.serial.stopbits,
                        ' RTS/CTS' if self.serial.rtscts else '',
                        ' Xon/Xoff' if self.serial.xonxoff else '',
                        ))
                    ok = True
            else:
                # on startup, dialog aborted
                self.alive.clear()
                ok = True

    def OnTermSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """\
        Menu point Terminal Settings. Show the settings dialog
        with the current terminal settings.
        """
        with TerminalSettingsDialog(self, -1, "", settings=self.settings) as dialog:
            dialog.CenterOnParent()
            dialog.ShowModal()

    def OnKey(self, event):
        """\
        Key event handler. If the key is in the ASCII range, write it to the
        serial port. Newline handling and local echo is also done here.
        """
        code = event.GetUnicodeKey()
        if code &lt; 256:   # XXX bug in some versions of wx returning only capital letters
            code = event.GetKeyCode()
        if code == 13:                      # is it a newline? (check for CR which is the RETURN key)
            if self.settings.echo:          # do echo if needed
                self.text_ctrl_output.AppendText('\n')
            if self.settings.newline == NEWLINE_CR:
                self.serial.write(b'\r')     # send CR
            elif self.settings.newline == NEWLINE_LF:
                self.serial.write(b'\n')     # send LF
            elif self.settings.newline == NEWLINE_CRLF:
                self.serial.write(b'\r\n')   # send CR+LF
        else:
            char = unichr(code)
            if self.settings.echo:          # do echo if needed
                self.WriteText(char)
            self.serial.write(char.encode('UTF-8', 'replace'))         # send the character

    def WriteText(self, text):
        if self.settings.unprintable:
            text = ''.join([c if (c &gt;= ' ' and c != '\x7f') else unichr(0x2400 + ord(c)) for c in text])
        self.text_ctrl_output.AppendText(text)

    def OnSerialRead(self, event):
        """Handle input from the serial port."""
        self.WriteText(event.data.decode('UTF-8', 'replace'))

    def ComPortThread(self):
        """\
        Thread that handles the incoming traffic. Does the basic input
        transformation (newlines) and generates an SerialRxEvent
        """
        while self.alive.isSet():
            b = self.serial.read(self.serial.in_waiting or 1)
            if b:
                # newline transformation
                if self.settings.newline == NEWLINE_CR:
                    b = b.replace(b'\r', b'\n')
                elif self.settings.newline == NEWLINE_LF:
                    pass
                elif self.settings.newline == NEWLINE_CRLF:
                    b = b.replace(b'\r\n', b'\n')
                event = SerialRxEvent(self.GetId(), b)
                self.GetEventHandler().AddPendingEvent(event)

    def OnRTS(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.rts = event.IsChecked()

    def OnDTR(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.dtr = event.Checked()

# end of class TerminalFrame


class MyApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_terminal = TerminalFrame(None, -1, "")
        self.SetTopWindow(frame_terminal)
        frame_terminal.Show(True)
        return 1

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;

&lt;h3&gt;wxSerialConfigDialog.py&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

#!/usr/bin/env python
#
# A serial port configuration dialog for wxPython. A number of flags can
# be used to configure the fields that are displayed.
#
# (C) 2001-2015 Chris Liechti &lt;cliechti@gmx.net&gt;
#
# SPDX-License-Identifier:    BSD-3-Clause

import wx
import serial
import serial.tools.list_ports

SHOW_BAUDRATE = 1 &lt;&lt; 0
SHOW_FORMAT = 1 &lt;&lt; 1
SHOW_FLOW = 1 &lt;&lt; 2
SHOW_TIMEOUT = 1 &lt;&lt; 3
SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT


class SerialConfigDialog(wx.Dialog):
    """\
    Serial Port configuration dialog, to be used with pySerial 2.0+
    When instantiating a class of this dialog, then the "serial" keyword
    argument is mandatory. It is a reference to a serial.Serial instance.
    the optional "show" keyword argument can be used to show/hide different
    settings. The default is SHOW_ALL which corresponds to
    SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be
    found in this module (not the class).
    """

    def __init__(self, *args, **kwds):
        # grab the serial keyword and remove it from the dict
        self.serial = kwds['serial']
        del kwds['serial']
        self.show = SHOW_ALL
        if 'show' in kwds:
            self.show = kwds.pop('show')
        # begin wxGlade: SerialConfigDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_2 = wx.StaticText(self, -1, "Port")
        self.choice_port = wx.Choice(self, -1, choices=[])
        self.label_1 = wx.StaticText(self, -1, "Baudrate")
        self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN)
        self.sizer_1_staticbox = wx.StaticBox(self, -1, "Basics")
        self.panel_format = wx.Panel(self, -1)
        self.label_3 = wx.StaticText(self.panel_format, -1, "Data Bits")
        self.choice_databits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_4 = wx.StaticText(self.panel_format, -1, "Stop Bits")
        self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_5 = wx.StaticText(self.panel_format, -1, "Parity")
        self.choice_parity = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, "Data Format")
        self.panel_timeout = wx.Panel(self, -1)
        self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, "Use Timeout")
        self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, "")
        self.label_6 = wx.StaticText(self.panel_timeout, -1, "seconds")
        self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, "Timeout")
        self.panel_flow = wx.Panel(self, -1)
        self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, "RTS/CTS")
        self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, "Xon/Xoff")
        self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, "Flow Control")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        # attach the event handlers
        self.__attach_events()

    def __set_properties(self):
        # begin wxGlade: SerialConfigDialog.__set_properties
        self.SetTitle("Serial Port Configuration")
        self.choice_databits.SetSelection(0)
        self.choice_stopbits.SetSelection(0)
        self.choice_parity.SetSelection(0)
        self.text_ctrl_timeout.Enable(False)
        self.button_ok.SetDefault()
        # end wxGlade
        self.SetTitle("Serial Port Configuration")
        if self.show &amp; SHOW_TIMEOUT:
            self.text_ctrl_timeout.Enable(0)
        self.button_ok.SetDefault()

        if not self.show &amp; SHOW_BAUDRATE:
            self.label_1.Hide()
            self.combo_box_baudrate.Hide()
        if not self.show &amp; SHOW_FORMAT:
            self.panel_format.Hide()
        if not self.show &amp; SHOW_TIMEOUT:
            self.panel_timeout.Hide()
        if not self.show &amp; SHOW_FLOW:
            self.panel_flow.Hide()

        # fill in ports and select current setting
        preferred_index = 0
        self.choice_port.Clear()
        self.ports = []
        for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())):
            self.choice_port.Append(u'{} - {}'.format(portname, desc))
            self.ports.append(portname)
            if self.serial.name == portname:
                preferred_index = n
        self.choice_port.SetSelection(preferred_index)
        if self.show &amp; SHOW_BAUDRATE:
            preferred_index = None
            # fill in baud rates and select current setting
            self.combo_box_baudrate.Clear()
            for n, baudrate in enumerate(self.serial.BAUDRATES):
                self.combo_box_baudrate.Append(str(baudrate))
                if self.serial.baudrate == baudrate:
                    preferred_index = n
            if preferred_index is not None:
                self.combo_box_baudrate.SetSelection(preferred_index)
            else:
                self.combo_box_baudrate.SetValue(u'{}'.format(self.serial.baudrate))
        if self.show &amp; SHOW_FORMAT:
            # fill in data bits and select current setting
            self.choice_databits.Clear()
            for n, bytesize in enumerate(self.serial.BYTESIZES):
                self.choice_databits.Append(str(bytesize))
                if self.serial.bytesize == bytesize:
                    index = n
            self.choice_databits.SetSelection(index)
            # fill in stop bits and select current setting
            self.choice_stopbits.Clear()
            for n, stopbits in enumerate(self.serial.STOPBITS):
                self.choice_stopbits.Append(str(stopbits))
                if self.serial.stopbits == stopbits:
                    index = n
            self.choice_stopbits.SetSelection(index)
            # fill in parities and select current setting
            self.choice_parity.Clear()
            for n, parity in enumerate(self.serial.PARITIES):
                self.choice_parity.Append(str(serial.PARITY_NAMES[parity]))
                if self.serial.parity == parity:
                    index = n
            self.choice_parity.SetSelection(index)
        if self.show &amp; SHOW_TIMEOUT:
            # set the timeout mode and value
            if self.serial.timeout is None:
                self.checkbox_timeout.SetValue(False)
                self.text_ctrl_timeout.Enable(False)
            else:
                self.checkbox_timeout.SetValue(True)
                self.text_ctrl_timeout.Enable(True)
                self.text_ctrl_timeout.SetValue(str(self.serial.timeout))
        if self.show &amp; SHOW_FLOW:
            # set the rtscts mode
            self.checkbox_rtscts.SetValue(self.serial.rtscts)
            # set the rtscts mode
            self.checkbox_xonxoff.SetValue(self.serial.xonxoff)

    def __do_layout(self):
        # begin wxGlade: SerialConfigDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_flow_staticbox.Lower()
        sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL)
        self.sizer_timeout_staticbox.Lower()
        sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL)
        self.sizer_format_staticbox.Lower()
        sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL)
        grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0)
        self.sizer_1_staticbox.Lower()
        sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL)
        sizer_basics = wx.FlexGridSizer(3, 2, 0, 0)
        sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0)
        sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0)
        sizer_basics.AddGrowableCol(1)
        sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0)
        sizer_2.Add(sizer_1, 0, wx.EXPAND, 0)
        grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        self.panel_format.SetSizer(sizer_format)
        sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0)
        sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0)
        sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        self.panel_timeout.SetSizer(sizer_timeout)
        sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0)
        sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add((10, 10), 1, wx.EXPAND, 0)
        self.panel_flow.SetSizer(sizer_flow)
        sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK)
        wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel)
        if self.show &amp; SHOW_TIMEOUT:
            wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout)

    def OnOK(self, events):
        success = True
        self.serial.port = self.ports[self.choice_port.GetSelection()]
        if self.show &amp; SHOW_BAUDRATE:
            try:
                b = int(self.combo_box_baudrate.GetValue())
            except ValueError:
                with wx.MessageDialog(
                        self,
                        'Baudrate must be a numeric value',
                        'Value Error',
                        wx.OK | wx.ICON_ERROR) as dlg:
                    dlg.ShowModal()
                success = False
            else:
                self.serial.baudrate = b
        if self.show &amp; SHOW_FORMAT:
            self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()]
            self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()]
            self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()]
        if self.show &amp; SHOW_FLOW:
            self.serial.rtscts = self.checkbox_rtscts.GetValue()
            self.serial.xonxoff = self.checkbox_xonxoff.GetValue()
        if self.show &amp; SHOW_TIMEOUT:
            if self.checkbox_timeout.GetValue():
                try:
                    self.serial.timeout = float(self.text_ctrl_timeout.GetValue())
                except ValueError:
                    with wx.MessageDialog(
                            self,
                            'Timeout must be a numeric value',
                            'Value Error',
                            wx.OK | wx.ICON_ERROR) as dlg:
                        dlg.ShowModal()
                    success = False
            else:
                self.serial.timeout = None
        if success:
            self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        self.EndModal(wx.ID_CANCEL)

    def OnTimeout(self, events):
        if self.checkbox_timeout.GetValue():
            self.text_ctrl_timeout.Enable(True)
        else:
            self.text_ctrl_timeout.Enable(False)

# end of class SerialConfigDialog


class MyApp(wx.App):
    """Test code"""
    def OnInit(self):
        wx.InitAllImageHandlers()

        ser = serial.Serial()
        print(ser)
        # loop until cancel is pressed, old values are used as start for the next run
        # show the different views, one after the other
        # value are kept.
        for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL):
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser, show=flags)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        # the user can play around with the values, CANCEL aborts the loop
        while True:
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        return 0

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/ciQDIeh.png"&gt;&lt;/p&gt;</summary><category term="wxpython"></category></entry><entry><title>樹梅派指令表和使用</title><link href="http://project.mde.tw/blog/shu-mei-pai-zhi-ling-biao-he-shi-yong.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/shu-mei-pai-zhi-ling-biao-he-shi-yong.html</id><summary type="html">&lt;p&gt;找到的些許文章和探討&lt;/p&gt;


&lt;p&gt;在Octoprint底下有個資料夾&lt;/p&gt;
&lt;p&gt;底層有些方法包括模組以及設定檔&lt;/p&gt;
&lt;p&gt;linux指令:&lt;/p&gt;
&lt;p&gt;cp&lt;/p&gt;
&lt;p&gt;mv&lt;/p&gt;
&lt;p&gt;指令再raspberry pi 要熟悉，因為在搬移檔案以及設定檔案，會常使用到，以及設定需要的檔案，像是網路的方法，以及未來可能要用到的USB掛載傳輸資料或者使用&lt;/p&gt;
&lt;pre class="brush: python"&gt;

#先檢查自己找到的usb數量
$ sudo fdisk -l
#...省略....
#Device         Boot  Start      End  Sectors  Size Id Type
#/dev/mmcblk0p1        8192   137215   129024   63M  c W95 FAT32 (LBA)
#/dev/mmcblk0p2      137216 31116287 30979072 14.8G 83 Linux

$ sudo mkdir /media/usbstick
$ sudo chown pi:pi /media/usbstick 

#手動掛載
$ sudo mount -t vfat -o uid=pi,gid=pi /dev/sda1 /media/usbstick
#就可以進行存取

#要拔除時要下指令
$ sudo umount /media/usbstick

&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/kkeiJv2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DeYzBNo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在這些設定檔中使用到的可以更改圖片或者是把程式碼拿出來理解目前解讀進度:&lt;/p&gt;
&lt;p&gt;1.再octoprint中有將各模組拆開來，近日把python的設定看完，可能會接近5%的進度&lt;/p&gt;
&lt;p&gt;2.圖片用到的部分，可能要從新Make(command)才可以用&lt;/p&gt;
&lt;p&gt;待完成部分:&lt;/p&gt;
&lt;p&gt;1.javascript&lt;/p&gt;
&lt;p&gt;2.往後寫出一套for our flask.py&lt;/p&gt;
&lt;p&gt;3.plugin部分&lt;/p&gt;</summary><category term="octopi"></category></entry><entry><title>ubuntu IPV4 IPV6 使用教學</title><link href="http://project.mde.tw/blog/ubuntu-ipv4-ipv6-shi-yong-jiao-xue.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/ubuntu-ipv4-ipv6-shi-yong-jiao-xue.html</id><summary type="html">&lt;p&gt;關於IPV4  IPV6設定&lt;/p&gt;


&lt;pre class="brush: python"&gt;

#先檢查網路
$ ifconfig
#修改/etc/network/interface的檔案
# interfaces(5) file used by ifup(8) and ifdown(8)
auto lo
iface lo inet loopback

sudo eth0
iface eth0 inet static
address 140.130.17.105
netmask 255.255.255.0
network 140.130.17.0
broadcast 140.130.17.255
gateway 140.130.17.254
# dns-* options are implemented by the resolvconf package, if $
dns-nameservers 140.130.1.2 140.130.17.3 168.95.1.1
dns-search mde.nfu.edu.tw

#老師的地址3004

#從新啟動

可以到IPV6的網站測試是否可以連線

&lt;/pre&gt;

&lt;p&gt;試用ubuntu系統改成IPV6和IPV4使用，並測試速度的使用上的問題，主要是在沒有IPV6的網站沒辦法連上去，這部份可能需要依靠proxy進行代理伺服器&lt;/p&gt;</summary><category term="ubuntu 網路設定"></category></entry><entry><title>40323123 - 專題參考資料</title><link href="http://project.mde.tw/blog/40323123-zhuan-ti-can-kao-zi-liao.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323123-zhuan-ti-can-kao-zi-liao.html</id><summary type="html">&lt;p&gt;raspberry pi  connect 3d printer to control the 3d printer &lt;/p&gt;


&lt;p&gt;1.回報目前專題進度:
事項一:目前題目定義 製作一台3D printer跟atom同樣款式的
事項二:因為有三組的成員，目前分配如下所示&lt;/p&gt;
&lt;p&gt;40323123 這組:利用octopi來進行遠端控制，以及自動下料等的問題，自動下料的機構利用GA進行運算&lt;/p&gt;
&lt;p&gt;40323250 這組:進行組裝，設計，Onshape組裝，V-Rep(組裝設計模擬)&lt;/p&gt;
&lt;p&gt;黃婉菁這組:先利用opencv來產生3d module並轉換成stl進行列印(主要目的影像建模出3Dstl)&lt;/p&gt;
&lt;p&gt;參考資料:
1.octopi
&lt;a href="http://plugins.octoprint.org/"&gt;octopi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.octoprintDocs
&lt;a href="http://docs.octoprint.org/en/master/"&gt;octoprint Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.octopi_github
&lt;a href="https://github.com/foosel/OctoPrint/wiki"&gt;octoprint WIKI&lt;/a&gt;
&lt;a href="https://github.com/foosel/OctoPrint/wiki/FAQ"&gt;FAQ&lt;/a&gt;
&lt;a href="https://github.com/guysoft/OctoPi"&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.flux 3d printer中的底板樣式以及掃描方式
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/l9ZISxSo2X0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;5.OpenCv 3d nodule
&lt;a href="http://www.opencv.org.cn/"&gt;OpenCv可參考&lt;/a&gt;&lt;/p&gt;</summary><category term="3d printer"></category></entry><entry><title>保養3D列印機</title><link href="http://project.mde.tw/blog/bao-yang-3dlie-yin-ji.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/bao-yang-3dlie-yin-ji.html</id><summary type="html">&lt;p&gt;Control 3D printer and some Question&lt;/p&gt;


&lt;p&gt;1.第一步清理平台&lt;/p&gt;
&lt;p&gt;2.幫滑軌上專用潤滑油&lt;/p&gt;
&lt;p&gt;3.加熱後將線材退出&lt;/p&gt;
&lt;p&gt;4.清理機台外觀&lt;/p&gt;
&lt;p&gt;5.確保滑軌滑動順利&lt;/p&gt;
&lt;p&gt;約兩個禮拜做一次，自動校正，不要太長使用，會導致買新的噴頭。
詳細注意事項，在另行公告&lt;/p&gt;</summary><category term="3d printer"></category></entry><entry><title>OpenCv實作</title><link href="http://project.mde.tw/blog/opencvshi-zuo.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/opencvshi-zuo.html</id><summary type="html">&lt;p&gt;OpenCv in python and use&lt;/p&gt;


&lt;p&gt;實作系統Ubuntu 14.04&lt;/p&gt;
&lt;p&gt;剛開始必須要先安裝依些相關的compiler以及設定黨
步驟如同老師所下載的順序
&lt;pre class="brush: python"&gt;&lt;/p&gt;
&lt;h1&gt;apt-get 更新&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get update&lt;/p&gt;
&lt;h1&gt;apt-get 升級&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get upgrade&lt;/p&gt;
&lt;h1&gt;安裝所需的開發套件&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install build-essential cmake git pkg-config&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的程式庫&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的程式庫&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的程式庫&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libgtk2.0-dev&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的 fortran 編譯器&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libatlas-base-dev gfortran&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的原始碼&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install python3.4-dev&lt;/p&gt;
&lt;h1&gt;本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy  模組&lt;/h1&gt;
&lt;p&gt;$ sudo pip3 install numpy&lt;/p&gt;
&lt;h1&gt;希望在帳號目錄下的 tmp 進行編譯工作&lt;/h1&gt;
&lt;p&gt;$ cd&lt;/p&gt;
&lt;h1&gt;new folder&lt;/h1&gt;
&lt;p&gt;$ mkdir tmp&lt;/p&gt;
&lt;h1&gt;更換目錄到 tmp&lt;/h1&gt;
&lt;p&gt;$ cd tmp&lt;/p&gt;
&lt;h1&gt;利用 git clone 取得原始碼&lt;/h1&gt;
&lt;p&gt;$ git clone https://github.com/Itseez/opencv.git&lt;/p&gt;
&lt;h1&gt;準備進入倉儲切換分支&lt;/h1&gt;
&lt;p&gt;$ cd opencv&lt;/p&gt;
&lt;h1&gt;採用 3.1.0 版&lt;/h1&gt;
&lt;p&gt;$ git checkout 3.1.0&lt;/p&gt;
&lt;h1&gt;回到用戶目錄&lt;/h1&gt;
&lt;p&gt;$ cd ..&lt;/p&gt;
&lt;h1&gt;再利用 git clone 下載原始碼&lt;/h1&gt;
&lt;p&gt;$ git clone https://github.com/Itseez/opencv_contrib.git&lt;/p&gt;
&lt;h1&gt;準備進入倉儲切換分支&lt;/h1&gt;
&lt;p&gt;$ cd opencv_contrib&lt;/p&gt;
&lt;h1&gt;與 opencv 配合, 採用 3.1.0 版&lt;/h1&gt;
&lt;p&gt;$ git checkout 3.1.0&lt;/p&gt;
&lt;p&gt;$ cd ..&lt;/p&gt;
&lt;h1&gt;準備開始建立程式庫&lt;/h1&gt;
&lt;p&gt;$ cd opencv&lt;/p&gt;
&lt;p&gt;$ mkdir build&lt;/p&gt;
&lt;p&gt;$ cd build&lt;/p&gt;
&lt;h1&gt;這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案&lt;/h1&gt;
&lt;p&gt;$ cmake -D CMAKE_BUILD_TYPE=RELEASE \
    -D CMAKE_INSTALL_PREFIX=/usr/local \
    -D INSTALL_C_EXAMPLES=OFF \
    -D INSTALL_PYTHON_EXAMPLES=ON \
    -D PYTHON_EXECUTABLE=$(which python3) \
    -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \
    -D BUILD_EXAMPLES=ON ..&lt;/p&gt;
&lt;p&gt;$ make -j4&lt;/p&gt;
&lt;p&gt;$ sudo make install&lt;/p&gt;
&lt;p&gt;$ sudo ldconfig&lt;/p&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/opencv_python3_windows.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;有做些許更改同樣也可以達到使用上的設定&lt;/p&gt;
&lt;p&gt;windows中
只需要開起2016spring中把py檔
用cmd line 來執行
下python3 你的程式碼的名子
只要有攝影機就可以執行
請注意
必須要裝好攝影機的驅動才可以執行cvcapture(0)
否則無法執行
0是預設的第1台攝影機
1是第2台
以此類推&lt;/p&gt;</summary><category term="OpenCv"></category></entry><entry><title>R2C2的資料</title><link href="http://project.mde.tw/blog/r2c2de-zi-liao.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/r2c2de-zi-liao.html</id><summary type="html">&lt;p&gt;新的R2C2資料&lt;/p&gt;


&lt;p&gt;中間有新的資料for raspberrypi
是使用node.js啟動server
client端可以看到的
https://github.com/nneves/Raspberrypi_NodeJS&lt;/p&gt;
&lt;p&gt;&lt;a href = "https://github.com/nneves/R2C2_WebInterface/blob/master/README.md"&gt;RaspberryPi R2C2&lt;/a&gt;&lt;/p&gt;</summary><category term="client control"></category></entry><entry><title>40323123 - 3d printer</title><link href="http://project.mde.tw/blog/40323123-3d-printer.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323123-3d-printer.html</id><summary type="html">&lt;p&gt;raspberry pi  connect 3d printer to control the 3d printer &lt;/p&gt;


&lt;p&gt;遠端控制3D列印
這邊使用的遠端列印是使用web client控制&lt;/p&gt;
&lt;p&gt;目前有兩套在觀望的系統~
一個是
&lt;a href="http://octoprint.org/download/"&gt;octopi&lt;/a&gt;
另一個是
&lt;a href="https://www.astroprint.com/downloads"&gt;Astropromt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者是我們自己寫一套
兩套皆使用樹梅派當為控制電腦及server
使用心得:在之前已經有安裝過octopi，使用狀況是不錯，但是gui介面有些許的問題，使用上是沒什麼大礙，在3D printer的控制板，做動方式，像是一般CNC一樣，接收
G指令
&lt;a href="http://reprap.org/wiki/G-code"&gt;Gcoce 大全&lt;/a&gt;
&lt;a href="http://www.slideshare.net/roboard/3d-printer-marlin"&gt;控制系統的code解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這兩套系統，都有開放原始碼，不過因為解析程式有巨大的阻礙，因為對python和樹梅派不熟悉，導致只會安裝不會自己編譯。&lt;/p&gt;</summary><category term="3d printer"></category></entry><entry><title>40323123 - 專題組員的範例文章標題</title><link href="http://project.mde.tw/blog/40323123-zhuan-ti-zu-yuan-de-fan-li-wen-zhang-biao-ti.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-01:blog/40323123-zhuan-ti-zu-yuan-de-fan-li-wen-zhang-biao-ti.html</id><summary type="html">&lt;p&gt;這裡放入 40323123 所寫的文章摘要&lt;/p&gt;


&lt;p&gt;這裡為 40323123 所寫的文章主要內容&lt;/p&gt;</summary><category term="範例"></category></entry></feed>