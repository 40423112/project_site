<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/tutorial.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-07-01T12:10:06+08:00</updated><entry><title>yen - RGA 基因演算法</title><link href="http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-rga-ji-yin-yan-suan-fa.html</id><summary type="html">&lt;p&gt;RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算.&lt;/p&gt;


&lt;pre class="brush: python"&gt;
# https://github.com/flukeskywalker/PyRGA
# 原始程式為 Python2 修改為 Python3 格式
# 除了原先的最大化適應值外, 增加最小化方法設定
import numpy as np
import random
from math import *

# 請注意各代族群數必須為 4 的倍數
class GA: # popsize must be multiple of 4
    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
        self.EPSILON = 10e-6
        self.INFINITY = 10e6
        self.pop = []
        self.fits = []
        self.obj = obj
        self.dim = dim
        self.popsize = popsize
        self.ngen = ngen
        self.pc = pc
        self.pm = pm
        self.etac = etac
        self.etam = etam
        # min = 1 表最小化, min = -1 表最大化
        self.min = min
        self.RIGID = 0
        self.lowb = -self.INFINITY*np.ones(self.dim)
        self.highb = self.INFINITY*np.ones(self.dim)
        self.tourneylist = range(0, self.popsize)
        self.tourneysize = 2 # works for 2 for now
        self.bestmemyet = np.zeros(self.dim)
        # 若是求最大值
        if self.min == -1:
            self.bestfityet = -np.inf
        else:
        # 若是求最小值
            self.bestfityet = np.inf
        self.pop_init()

    def pop_init(self):
        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
        for member in self.pop:
            for i in range(self.dim):
                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
        self.fits = [self.obj(member) for member in self.pop]
        #self.pop_print()
        return

    def setbounds(self, lows, highs):
        for i in range(self.dim):
            self.lowb[i] = lows[i]
            self.highb[i] = highs[i]
        self.pop_init()
        return

    def run(self):
        for gen in range(self.ngen):
            print("Generation ", gen)
            self.pop = self.getnewpop()
            self.eval_pop()
            #self.pop_print()
        return [self.bestmemyet, self.bestfityet]

    def getnewpop(self):
        newpop = []
        #self.tourneylist = range(0, self.popsize)
        random.shuffle(list(self.tourneylist))
        self.tourneypos = 0
        for i in range(0, self.popsize, 2):
            [p1, p2] = self.getparents() #return parents, not just indices
            [c1, c2] = self.xover(p1, p2) #return children, not just indices
            c1 = self.mutate(c1)
            c2 = self.mutate(c2)
            newpop.append(c1)
            newpop.append(c2)
        return newpop

    def getparents(self):
        if (self.popsize - self.tourneypos) &lt; self.tourneysize:
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize

        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
        return [p1, p2]

    def xover(self, p1, p2): # Here p1 and p2 are pop members
        c1 = np.zeros_like(p1)
        c2 = np.zeros_like(p2)
        if random.random()&lt;=self.pc: # do crossover
            for i in range(p1.size):
                if random.random()&lt;0.5: # 50% variables crossover
                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                else:
                    [c1[i], c2[i]] = [p1[i], p2[i]]
        else:
            c1 = p1
            c2 = p2
        return [c1, c2]

    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
        if p1&gt;p2:
            p1, p2 = p2, p1 # p1 must be smaller
        mean = (p1+p2)*0.5
        diff = (p2-p1)
        dist = max(min(p1-low, high-p2), 0)
        if (self.RIGID and diff &gt; self.EPSILON):
            alpha = 1.0 + (2.0*dist/diff)
            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
            seed = umax*random.random()
        else:
            seed = random.random()
        beta = self.getbeta(seed)
        if (abs(diff*beta) &gt; self.INFINITY):
            beta = self.INFINITY/diff
        c2 = mean + beta*0.5*diff
        c1 = mean - beta*0.5*diff
        c1 = max(low, min(c1, high))
        c2 = max(low, min(c2, high))
        return [c1, c2]

    def getbeta(self, seed):
        if (1 - seed) &lt; self.EPSILON:
            seed = 1 - self.EPSILON
        seed = max(0.0, seed)
        if seed &lt; 0.5:
            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
        else:
            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
        return beta

    def getdelta(self, seed, delta_low, delta_high):
        if seed &gt;= 1.0 - (self.EPSILON/1e3):
            return delta_high
        if seed &lt;= (self.EPSILON/1e3):
            return delta_low
        if seed &lt;= 0.5:
            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
        else:
            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
        return delta

    def mutate(self, member):
        mut_member = np.zeros_like(member)
        for i in range(member.size):
            low = self.lowb[i]
            high = self.highb[i]
            if random.random() &lt;= self.pm: # pm is simply the prob of a variable to mutate
                if self.RIGID:
                    value = member[i]
                    delta_low = max((low-value)/(high-low), -1.0)
                    delta_high = min((high-value)/(high-low), 1.0)
                    if abs(delta_low)&lt;abs(delta_high):
                        delta_high = -delta_low
                    else:
                        delta_low = -delta_high
                else:
                    delta_low = -1.0
                    delta_high = 1.0
                seed = random.random()
                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                mut_member[i] = max(low, min(member[i] + delta, high))
            else:
                mut_member[i] = member[i]
        return mut_member

    def eval_pop(self):
        self.fits = [self.obj(member) for member in self.pop]
        # 若是最大化適應值題目者
        if self.min == -1:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmax(self.fits)
        else:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmin(self.fits)
        bestmember = self.pop[bestindex]
        bestfitness = self.fits[bestindex]
        # self.min = -1 for maximization, self.min = 1 for minimization
        if self.min == -1:
            # 若是在族群中的最佳適應值大於目前為止最佳的適應值
            if bestfitness &gt; self.bestfityet:
                # 則將此最大適應值指為目前為止最佳適應值
                self.bestfityet = bestfitness
                # 並且將最佳族群成員指向目前最佳成員
                self.bestmemyet = bestmember
        else:
            if bestfitness &lt; self.bestfityet:
                self.bestfityet = bestfitness
                self.bestmemyet = bestmember
        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)

    def pop_print(self):
        for i in range(self.popsize):
            print(self.pop[i], self.fits[i])
        return

# 若單獨存在則需導入 GA 所有方法
#import GA
#from GA import *
import numpy as np

def square(x):
    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
    term3 = term1+term2
    return term3

# 最大化體積題目
def volume(x):
    surface = 80.0
    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
    volume = x[0]*x[1]*z
    return volume


def miniex1(x):
    '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    term1 = 1.5 - x[0] + x[0]*x[1]
    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
    return term1*term1 + term2*term2 + term3*term3

def miniex2(x):
    '''Schaffer function #2. Minimium at (0,0), equal to 0
    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    return 0.5 + (pow(sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)

''' 開始四連桿運算
'''
class Point(object):
    '''Creates a point on a coordinate plane with values x and y.'''
    def __init__(self, x, y):
        '''Defines x and y variables'''
        self.x = x
        self.y = y

def triangletip_coord(x0, y0, R0, R1, x1, y1, localt):
    mech_loop = -1
    tip_coord = Point(0,0)
    if (localt &gt;= 0 and localt &lt; pi):
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    else:
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    return tip_coord

def distance(x0, y0, x1, y1):
    return sqrt(pow((x1-x0),2) + pow((y1-y0),2))

def rr(L1, dd, theta):
    return sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta))

# input_angles  = [] 也就是必須為 list 且各樹為 NUM_OF_POINTS
def mechanism(x0, y0, x1, y1, L1, L2, L3, L5, L6, input_angles):
    '''
    mechanism(0,0,10,0,5,20,10,10,10,input_angles)
    x0 = 0.0;
    y0 = 0.0;
    x1 = 10.0;
    y1 = 0.0;
    L1 = 5.0;
    L2 = 10;
    L3 = 10;
    L5 = 10;
    L6 = 10;
    '''
    link1_tip = Point(0,0)
    link2_tip = Point(0,0)
    output_points = list()
    degree = pi/180.
    NUM_OF_POINTS = 5
    dd_length = distance(x0, y0, x1, y1)
    # 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式
    angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));
    for i in range(NUM_OF_POINTS):
        angle = input_angles[i]*degree
        rr_length = rr(L1, dd_length, angle)
        # 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle)
        #print(angle, rr_length, link1_tip.x, link1_tip.y)
        # 第二次三角形疊代
        # 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length))
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2)
        # 第三次三角形疊代 (改為以 finaltip_coord() 取值, 而非第三次疊代
        '''
        triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        '''
        # 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points.append(finaltip_coord(link1_tip, link2_tip, L5, L6))
    return output_points

def finaltip_coord(tip1_coord, tip2_coord, r1, r2):
    tip3_coord = Point(0,0)
    length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2))
    length4 = sqrt(pow(r1,2) + pow(r2,2))
    theta3 = acos((tip2_coord.x - tip1_coord.x) / length3)
    theta4 = acos(r1/length4)
    tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4)
    tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4)
    return tip3_coord

# 誤差函式
def error_function(output_points, target_points):
    NUM_OF_POINTS = 5
    error = 0
    for i in range(NUM_OF_POINTS):
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y))
    return error

# 組成機構的變數個樹 9 + 通過點數所對應的角度值, 若通過 5 點則共有 14 個變數
#   mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);
def fourbar(x):
    PENALITY = 1000
    NUM_OF_POINTS = 10

    # x0 與 x1 點位於 -50 與 50 中間, 0, 1, 2, 3
    for i in range(4):
        if(x[i] &lt; -50 or x[i] &gt; 50):
            return PENALITY
    # 三個連桿值, 一定要為正, 4, 5, 6,
    for i in range(4, 7):
        if(x[i] &lt; 0 or x[i] &gt;50):
            return PENALITY

    # L5 L6 可以為 0 或負值, 7, 8 
    for i in range(7, 9):
        if(x[i] &lt; -50 or x[i] &gt; 50):
            return PENALITY

    # 角度值一定要大於 0
    for i in range(NUM_OF_POINTS):
        if(x[9+i] &lt; 0):
            return PENALITY

    result = 0
    target_points = list()
    output_points = list()
    input_angles = list()
    # 定義四連桿關鍵點所要通過的點
    p1 = Point(1, 1)
    p2 = Point(2, 2)
    p3 = Point(3, 3)
    p4 = Point(4, 4)
    p5 = Point(5, 5)
    p6 = Point(6, 6)
    p7 = Point(7, 7)
    p8 = Point(8, 8)
    p9 = Point(9, 9)
    p10 = Point(10, 10)
    target_points = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]
    for i in range(9, 9+NUM_OF_POINTS):
        input_angles.append(x[i])
    # 這裡要加入查驗各參數是否符合四連桿組成條件
    try:
        output_points = mechanism(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],input_angles)
    except:
        return PENALITY
    result = error_function(output_points, target_points)
    return result

#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
#ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# 請注意 popsize 必須為 4 的倍數
#ga=GA(miniex1, dim=2, popsize=12, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
ga=GA(fourbar, dim=19, popsize=120000, ngen=10000, pc=0.9, pm=0.5, etac=2, etam=100, min=1)
#ga.setbounds(np.zeros(10), 10*np.ones(10))
#ga.setbounds(-10*np.ones(10), 10*np.ones(10))
ga.setbounds(-50*np.ones(20), 50*np.ones(20))
#ga.pop_init()
print(ga.run())
&lt;/pre&gt;

&lt;p&gt;利用 C 與 Differential Evolution 解上述相同問題的原始碼:&lt;/p&gt;
&lt;pre class="brush: c"&gt;
    // 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散??

    /***************************************************************
    **                                                            **
    **        D I F F E R E N T I A L     E V O L U T I O N       **
    **                                                            **
    ** Program: de.c                                              **
    ** Version: 3.6                                               **
    **                                                            **
    ** Authors: Dr. Rainer Storn                                  **
    **          c/o ICSI, 1947 Center Street, Suite 600           **
    **          Berkeley, CA 94707                                **
    **          Tel.:   510-642-4274 (extension 192)              **
    **          Fax.:   510-643-7684                              **
    **          E-mail: storn@icsi.berkeley.edu                   **
    **          WWW: http://http.icsi.berkeley.edu/~storn/        **
    **          on leave from                                     **
    **          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
    **          D-81739 Muenchen, Germany                         **
    **          Tel:    636-40502                                 **
    **          Fax:    636-44577                                 **
    **          E-mail: rainer.storn@zfe.siemens.de               **
    **                                                            **
    **          Kenneth Price                                     **
    **          836 Owl Circle                                    **
    **          Vacaville, CA 95687                               **
    **          E-mail: kprice@solano.community.net               ** 
    **                                                            **
    ** This program implements some variants of Differential      **
    ** Evolution (DE) as described in part in the techreport      **
    ** tr-95-012.ps of ICSI. You can get this report either via   **
    ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
    ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
    ** A more extended version of tr-95-012.ps is submitted for   **
    ** publication in the Journal Evolutionary Computation.       ** 
    **                                                            **
    ** You may use this program for any purpose, give it to any   **
    ** person or change it according to your needs as long as you **
    ** are referring to Rainer Storn and Ken Price as the origi-  **
    ** nators of the the DE idea.                                 **
    ** If you have questions concerning DE feel free to contact   **
    ** us. We also will be happy to know about your experiences   **
    ** with DE and your suggestions of improvement.               **
    **                                                            **
    ***************************************************************/
    /**H*O*C**************************************************************
    **                                                                  **
    ** No.!Version! Date ! Request !    Modification           ! Author **
    ** ---+-------+------+---------+---------------------------+------- **
    **  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
    **    +      +       +         + included                  +        **
    **  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
    **  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
    **  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
    **  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
    **  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
    **    +      +       +         + initialization            +        **
    **  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
    **  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
    **  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
    **  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
    **  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
    **  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
    **  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
    **  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
    **                                                                  **
    ***H*O*C*E***********************************************************/

    #include "stdio.h"
    #include "stdlib.h"
    #include "math.h"
    #include "memory.h"
    #include &amp;lt;time.h&amp;gt;

    // 最大族群數, NP
    #define MAXPOP  5000
    // 最大向量維度, D
    #define MAXDIM  35
    #define MAXIMAPROBLEM 0
    #define PENALITY 1000

    /*------Constants for rnd_uni()--------------------------------------------*/

    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)

    // 與機構合成相關的常數定義
    #define PI 3.1415926
    #define degree PI/180.0
    #define mech_loop -1
    #define NUM_OF_POINTS 10

    /*------------------------Macros----------------------------------------*/

    /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                               /* works only for small  */
                                                               /* arrays, but is faster.*/

    /*------------------------Globals---------------------------------------*/

    long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
    double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
    double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];

    /*---------Function declarations----------------------------------------*/

    void  assignd(int D, double a[], double b[]);
    double rnd_uni(long *idum);    /* uniform pseudo random number generator */
    double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */

    // 與機構合成相關的函式宣告
    double distance(double x0, double y0, double x1, double y1);
    double rr(double L1, double dd, double theta);
    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt);
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);

    /*---------Function definitions-----------------------------------------*/
    // 指定向量 b 為 a
    void  assignd(int D, double a[], double b[])
    /**C*F****************************************************************
    **                                                                  **
    ** Assigns D-dimensional vector b to vector a.                      **
    ** You might encounter problems with the macro ASSIGND on some      **
    ** machines. If yes, better use this function although it's slower. **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
       int j;
       for (j=0; j&amp;lt;D; j++)
       {
          a[j] = b[j];
       }
    }

    // 產生 0 ~ 1 間的亂數
    double rnd_uni(long *idum)
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :rnd_uni()                                        **
    ** LONG_NAME      :random_uniform                                   **
    ** AUTHOR         :(see below)                                      **
    **                                                                  **
    ** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
    **                 dom number in the interval [0,1]. For further    **
    **                 reference see Press, W.H. et alii, Numerical     **
    **                 Recipes in C, Cambridge University Press, 1992.  **
    **                                                                  **
    ** FUNCTIONS      :none                                             **
    **                                                                  **
    ** GLOBALS        :none                                             **
    **                                                                  **
    ** PARAMETERS     :*idum    serves as a seed value                  **
    **                                                                  **
    ** PRECONDITIONS  :*idum must be negative on the first call.        **
    **                                                                  **
    ** POSTCONDITIONS :*idum will be changed                            **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
      long j;
      long k;
      static long idum2=123456789;
      static long iy=0;
      static long iv[NTAB];
      double temp;

      if (*idum &amp;lt;= 0)
      {
        if (-(*idum) &amp;lt; 1) *idum=1;
        else *idum = -(*idum);
        idum2=(*idum);
        for (j=NTAB+7;j&amp;gt;=0;j--)
        {
          k=(*idum)/IQ1;
          *idum=IA1*(*idum-k*IQ1)-k*IR1;
          if (*idum &amp;lt; 0) *idum += IM1;
          if (j &amp;lt; NTAB) iv[j] = *idum;
        }
        iy=iv[0];
      }
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &amp;lt; 0) *idum += IM1;
      k=idum2/IQ2;
      idum2=IA2*(idum2-k*IQ2)-k*IR2;
      if (idum2 &amp;lt; 0) idum2 += IM2;
      j=iy/NDIV;
      iy=iv[j]-idum2;
      iv[j] = *idum;
      if (iy &amp;lt; 1) iy += IMM1;
      if ((temp=AM*iy) &amp;gt; RNMX) return RNMX;
      else return temp;

    }/*------End of rnd_uni()--------------------------*/

    // 將上下限轉為全域變數
    double inibound_h;      /* upper parameter bound              */
    double inibound_l;      /* lower parameter bound              */
    // 與機構合成相關的全域變數
    // 宣告一個座標結構
    struct Coord {
        double x;
        double y;
      // 這裡保留 double z;
    };

    main(int argc, char *argv[])
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :main()                                           **
    ** LONG_NAME      :main program                                     **
    ** AUTHOR         :Rainer Storn, Kenneth Price                      **
    **                                                                  **
    ** DESCRIPTION    :driver program for differential evolution.       **
    **                                                                  **
    ** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
    **                 fopen(), fclose(), fscanf().                     **
    **                                                                  **
    ** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
    **                                                                  **
    ** PARAMETERS     :argc            #arguments = 3                   **
    **                 argv            pointer to argument strings      **
    **                                                                  **
    ** PRECONDITIONS  :main must be called with three parameters        **
    **                 e.g. like de1 &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;, if     **
    **                 the executable file is called de1.               **
    **                 The input file must contain valid inputs accor-  **
    **                 ding to the fscanf() section of main().          **
    **                                                                  **
    ** POSTCONDITIONS :main() produces consecutive console outputs and  **
    **                 writes the final results in an output file if    **
    **                 the program terminates without an error.         **
    **                                                                  **
    ***C*F*E*************************************************************/

    {
       char  chr;             /* y/n choice variable                */
       char  *strat[] =       /* strategy-indicator                 */
       {
                "",
                "DE/best/1/exp",
                "DE/rand/1/exp",
                "DE/rand-to-best/1/exp",
                "DE/best/2/exp",
                "DE/rand/2/exp",
                "DE/best/1/bin",
                "DE/rand/1/bin",
                "DE/rand-to-best/1/bin",
                "DE/best/2/bin",
                "DE/rand/2/bin"
       };

       int   i, j, L, n;      /* counting variables                 */
       int   r1, r2, r3, r4;  /* placeholders for random indexes    */
       int   r5;              /* placeholders for random indexes    */
       int   D;               /* Dimension of parameter vector      */
       int   NP;              /* number of population members       */
       int   imin;            /* index to member with lowest energy */
       int   refresh;         /* refresh rate of screen output      */
       int   strategy;        /* choice parameter for screen output */
       int   gen, genmax, seed;   

       long  nfeval;          /* number of function evaluations     */

       double trial_cost;      /* buffer variable                    */
       // 將上下限轉為全域變數, 可能要根據各變數加以設定
       //double inibound_h;      /* upper parameter bound              */
       //double inibound_l;      /* lower parameter bound              */
       double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
       double cost[MAXPOP];    /* obj. funct. values                 */
       double cvar;            /* computes the cost variance         */
       double cmean;           /* mean cost                          */
       double F,CR;            /* control variables of DE            */
       double cmin;            /* help variables                     */

       FILE  *fpin_ptr;
       FILE  *fpout_ptr;

    // 計算執行過程所需時間起點, 需要導入 time.h
      clock_t start = clock();

    /*------Initializations----------------------------*/

     //if (argc != 3)                                 /* number of arguments */
     //{
        //printf("\nUsage : de &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;\n");
        //exit(1);
     //}

    // 將結果寫入 out.dat
     fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                              /* to see whether it already exists */
     /*
     if ( fpout_ptr != NULL )
     {
        printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
        printf("want to overwrite it, \nanything else if you want to exit.\n");
        chr = (char)getchar();
        if ((chr != 'y') &amp;amp;&amp;amp; (chr != 'Y'))
        {
          exit(1);
        }
        fclose(fpout_ptr);
     }
    */

    /*-----Read input data------------------------------------------------*/

     //fpin_ptr   = fopen(argv[1],"r");
    /*
     if (fpin_ptr == NULL)
     {
        printf("\nCannot open input file\n");
        exit(1);
     }*/

     //fscanf(fpin_ptr,"%d",&amp;amp;strategy);       /*---choice of strategy-----------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;genmax);         /*---maximum number of generations------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;refresh);        /*---output refresh cycle---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;D);              /*---number of parameters---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;NP);             /*---population size.-------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_h);    /*---upper parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_l);    /*---lower parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;F);             /*---weight factor----------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;CR);            /*---crossing over factor---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;seed);           /*---random seed------------------------*/
    // 目前已經採用 strategy 3 可以得到最佳結果
      strategy = 3;
      genmax = 2000;
      refresh = 100;
      // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
      D = 19;
      NP = 200;
      inibound_h = 50.;
      inibound_l = 0.;
    /*得到最佳解
      F = 0.85;
    CR 必須介於 0 to 1. 之間
      CR = 1.;
    */
      F = 0.85;
      CR = 1.;
      seed = 3;

     //fclose(fpin_ptr);

    /*-----Checking input variables for proper range----------------------------*/

      if (D &amp;gt; MAXDIM)
      {
         printf("\nError! D=%d &amp;gt; MAXDIM=%d\n",D,MAXDIM);
         exit(1);
      }
      if (D &amp;lt;= 0)
      {
         printf("\nError! D=%d, should be &amp;gt; 0\n",D);
         exit(1);
      }
      if (NP &amp;gt; MAXPOP)
      {
         printf("\nError! NP=%d &amp;gt; MAXPOP=%d\n",NP,MAXPOP);
         exit(1);
      }
      if (NP &amp;lt;= 0)
      {
         printf("\nError! NP=%d, should be &amp;gt; 0\n",NP);
         exit(1);
      }
      if ((CR &amp;lt; 0) || (CR &amp;gt; 1.0))
      {
         printf("\nError! CR=%f, should be ex [0,1]\n",CR);
         exit(1);
      }
      if (seed &amp;lt;= 0)
      {
         printf("\nError! seed=%d, should be &amp;gt; 0\n",seed);
         exit(1);
      }
      if (refresh &amp;lt;= 0)
      {
         printf("\nError! refresh=%d, should be &amp;gt; 0\n",refresh);
         exit(1);
      }
      if (genmax &amp;lt;= 0)
      {
         printf("\nError! genmax=%d, should be &amp;gt; 0\n",genmax);
         exit(1);
      }
      if ((strategy &amp;lt; 0) || (strategy &amp;gt; 10))
      {
         printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
         exit(1);
      }
      if (inibound_h &amp;lt; inibound_l)
      {
         printf("\nError! inibound_h=%f &amp;lt; inibound_l=%f\n",inibound_h, inibound_l);
         exit(1);
      }


    /*-----Open output file-----------------------------------------------*/

       //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */

       //if (fpout_ptr == NULL)
       //{
          //printf("\nCannot open output file\n");
          //exit(1);
       //}


    /*-----Initialize random number generator-----------------------------*/

     rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
     nfeval       =  0;  /* reset number of function evaluations */



    /*------Initialization------------------------------------------------*/
    /*------Right now this part is kept fairly simple and just generates--*/
    /*------random numbers in the range [-initfac, +initfac]. You might---*/
    /*------want to extend the init part such that you can initialize-----*/
    /*------each parameter separately.------------------------------------*/

       for (i=0; i&amp;lt;NP; i++)
       {
          for (j=0; j&amp;lt;D; j++) /* spread initial population members */
          {
            c[i][j] = inibound_l + rnd_uni(&amp;amp;rnd_uni_init)*(inibound_h - inibound_l);
          }
          cost[i] = evaluate(D,c[i],&amp;amp;nfeval); /* obj. funct. value */
       }
       cmin = cost[0];
       imin = 0;
       for (i=1; i&amp;lt;NP; i++)
       {
         if(MAXIMAPROBLEM == 1)
         {
           // 改為最大化
            if (cost[i]&amp;gt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
          else
          {
            // 最小化問題
            if (cost[i]&amp;lt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
       }

       assignd(D,best,c[imin]);            /* save best member ever          */
       assignd(D,bestit,c[imin]);          /* save best member of generation */

       pold = &amp;amp;c; /* old population (generation G)   */
       pnew = &amp;amp;d; /* new population (generation G+1) */

    /*=======================================================================*/
    /*=========Iteration loop================================================*/
    /*=======================================================================*/

       gen = 0;                          /* generation counter reset */
       while ((gen &amp;lt; genmax) /*&amp;amp;&amp;amp; (kbhit() == 0)*/) /* remove comments if conio.h */
       {                                            /* is accepted by compiler    */
          gen++;
          imin = 0;

          for (i=0; i&amp;lt;NP; i++)         /* Start of loop through ensemble  */
          {
         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 2 !!!     */
           r1 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while(r1==i);            

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 3 !!!     */
           r2 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r2==i) || (r2==r1));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 4 !!!     */
           r3 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r3==i) || (r3==r1) || (r3==r2));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 5 !!!     */
           r4 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 6 !!!     */
           r5 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));


    /*=======Choice of strategy===============================================================*/
    /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
    /*=======DE :  stands for Differential Evolution==========================================*/
    /*=======x  :  a string which denotes the vector to be perturbed==========================*/
    /*=======y  :  number of difference vectors taken for perturbation of x===================*/
    /*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
    /*                                                                                        */
    /*=======There are some simple rules which are worth following:===========================*/
    /*=======1)  F is usually between 0.5 and 1 (in rare cases &amp;gt; 1)===========================*/
    /*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
    /*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
    /*           happens.                                                                     */
    /*=======4)  If you increase NP, F usually has to be decreased============================*/
    /*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/


    /*=======EXPONENTIAL CROSSOVER============================================================*/

    /*-------DE/best/1/exp--------------------------------------------------------------------*/
    /*-------Our oldest strategy but still not bad. However, we have found several------------*/
    /*-------optimization problems where misconvergence occurs.-------------------------------*/
         if (strategy == 1) /* strategy DE0 (not in our paper) */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/1/exp-------------------------------------------------------------------*/
    /*-------This is one of my favourite strategies. It works especially well when the-------*/
    /*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
    /*-------as a first guess.---------------------------------------------------------------*/
         else if (strategy == 2) /* strategy DE1 in the techreport */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
    /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
    /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
    /*-------should play around with all three control variables.----------------------------*/
         else if (strategy == 3) /* similiar to DE2 but generally better */
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                       
             tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
         else if (strategy == 4)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
         else if (strategy == 5)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }

    /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/

    /*-------DE/best/1/bin--------------------------------------------------------------------*/
         else if (strategy == 6) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/1/bin-------------------------------------------------------------------*/
         else if (strategy == 7) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
         else if (strategy == 8) 
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/best/2/bin--------------------------------------------------------------------*/
         else if (strategy == 9)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/2/bin--------------------------------------------------------------------*/
         else
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }


    /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/

         trial_cost = evaluate(D,tmp,&amp;amp;nfeval);  /* Evaluate new vector in tmp[] */
       if(MAXIMAPROBLEM == 1)
       {
        // 改為最大化
           if (trial_cost &amp;gt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;gt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }
        else
        {
              // 最小化問題
           if (trial_cost &amp;lt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;lt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }

          }   /* End mutation loop through pop. */

          assignd(D,bestit,best);  /* Save best population member of current iteration */

          /* swap population arrays. New generation becomes old one */

          pswap = pold;
          pold  = pnew;
          pnew  = pswap;

    /*----Compute the energy variance (just for monitoring purposes)-----------*/

          cmean = 0.;          /* compute the mean value first */
          for (j=0; j&amp;lt;NP; j++)
          {
             cmean += cost[j];
          }
          cmean = cmean/NP;

          cvar = 0.;           /* now the variance              */
          for (j=0; j&amp;lt;NP; j++)
          {
             cvar += (cost[j] - cmean)*(cost[j] - cmean);
          }
          cvar = cvar/(NP-1);


    /*----Output part----------------------------------------------------------*/

          if (gen%refresh==1)   /* display after every refresh generations */
          { /* ABORT works only if conio.h is accepted by your compiler */
        printf("\n\n                         PRESS ANY KEY TO ABORT"); 
        printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);

        for (j=0;j&amp;lt;D;j++)
        {
          printf("\n best[%d]=%-15.10g",j,best[j]);
        }
        printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
        printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
                   NP,F,CR,cvar);
          }

          fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
       }
    /*=======================================================================*/
    /*=========End of iteration loop=========================================*/
    /*=======================================================================*/

    /*-------Final output in file-------------------------------------------*/


       fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);

       for (j=0;j&amp;lt;D;j++)
       {
         fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
       }
       fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
       fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
               NP,F,CR,cvar); 

      fclose(fpout_ptr);

      /* Code you want timed here */
      printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
       return(0);
    }

    /*-----------End of main()------------------------------------------*/

    // 適應函式 fittness function (cost function)
    double evaluate(int D, double tmp[], long *nfeval)
    {
      // 先處理通過 5 個點的四連桿問題
      // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
      // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
      // L1 為第一桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[4]
      // L2 為第二桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[5]
      // L3 為第三桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[6]
      // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
      // L5, L6 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
      // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
      // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
      // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
      // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
      /* void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
      struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
      double input_angles[NUM_OF_POINTS], result;
      int i;

      (*nfeval)++;

      target_points[0].x = 1.0;
      target_points[0].y = 1.0;

      target_points[1].x = 2.0;
      target_points[1].y = 2.0;

      target_points[2].x = 3.0;
      target_points[2].y = 3.0;

      target_points[3].x = 4.0;
      target_points[3].y = 4.0;

      target_points[4].x = 5.0;
      target_points[4].y = 5.0;

      target_points[5].x = 6.0;
      target_points[5].y = 6.0;

      target_points[6].x = 7.0;
      target_points[6].y = 7.0;

      target_points[7].x = 8.0;
      target_points[7].y = 8.0;

      target_points[8].x = 9.0;
      target_points[8].y = 9.0;

      target_points[9].x = 10.0;
      target_points[9].y = 10.0;

      // 輸入角度值與 tmp[] 的設定
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        input_angles[i] = tmp[i + 9];
      }
      // 呼叫 mechanism() 以便計算 output_points[]
      mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);

      // for debug
      /*
      if(*nfeval%3000 == 0)
      {
        for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
        {
          printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
        }
        printf("#####################################\n");
      }
      */
      // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
      result = error_function(output_points, target_points);
      // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result

      // x0 與 x1 點位於 -500 與 500 中間
        for(i = 0; i &amp;lt; 4; i++)
      {
        if(tmp[i] &amp;lt; -50 || tmp[i] &amp;gt; 50){
          return PENALITY;
        }
      }

      // 三個連桿值, 一定要為正
        for(i = 4; i &amp;lt; 7; i++)
      {
        if(tmp[i] &amp;lt; 0 || tmp[i] &amp;gt; 50){
          return PENALITY;
        }
      }

        // L5 L6 可以為 0 或負值
        for(i = 7; i &amp;lt; 9; i++)
      {
        if(tmp[i] &amp;lt; -50 || tmp[i] &amp;gt; 50){
          return PENALITY;
        }
      }

      // 角度值一定要大於 0

      for(i = 1; i &amp;lt;= NUM_OF_POINTS; i++)
      {
        if((tmp[D-i] &amp;lt; 0)){
          return PENALITY;
        }
      }

      return result;

      /*
       double result=0, surface = 80.0, z, volume, penality;
       (*nfeval)++;
       z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
       volume = tmp[0]*tmp[1]*z;

      if(volume &amp;lt;= 0){
        return PENALITY;
      }

      if((tmp[0] &amp;lt;= inibound_l)|| (tmp[0] &amp;gt;inibound_h)){
        return PENALITY;
      }

      if((tmp[1] &amp;lt;= inibound_l) || (tmp[1] &amp;gt;inibound_h)){
        return PENALITY;
      }
      // volume must &amp;gt;0 and max volume
      // 目前為最小化問題
       return 1+1/(volume*volume);
       */
    }

    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
    {
        struct Coord tip_coord;

        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
        }
        else
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
        pow(x1-x0,2))/2)+x0;
        }

    // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    // 利用 sqrtt 居中進行代換所得到的式子
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;

        }
        else
        {
            tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
        }

      return tip_coord;
    }

    double distance(double x0, double y0, double x1, double y1)
    {
        double distance_value;
        distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
        return distance_value;
    }

    double rr(double L1, double dd, double theta)
    {
        double rr_value;
        rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta));
        return rr_value;
    }

    // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
    {
      // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
      // 以下為可能的處理變數宣告
      // 這裡希望能夠定義一個 struct 來處理座標點
      double rr_length, dd_length, angle;
      struct Coord link1_tip, link2_tip, triangle_tip;
        double angle2, angle3;
      int i;

      // 開始進行三角形頂點座標的計算
      // 以下變數由每一個體向量提供
      /*
        x0 = 0.0;
        y0 = 0.0;
        x1 = 10.0;
        y1 = 0.0;
        L1 = 5.0;
        L2 = 20;
        L3 = 10;
        L5 = 10;
        L6 = 10;
      */
      dd_length = distance(x0, y0, x1, y1);
      /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
      angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));

      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        // 先建立第一點座標, 即 i=0 者
        // i=0;
        // angle = i*degree;
        /*
        // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
        if(i &amp;gt; 0)
        {
          input_angles[i] = input_angles[i] + input_angles[i-1];
        }
        */
        angle = input_angles[i]*degree;
        rr_length = rr(L1, dd_length, angle);
        // 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
        // 第二次三角形疊代
        /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
        // 第三次三角形疊代
        //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
      }
    }

    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
    {
      double error = 0.0;
      int i;
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
      }
      return error;
    }

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
    {
      struct Coord tip3_coord;
      double theta3, theta4, length3, length4;
      length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
      length4 = sqrt(pow(r1,2) + pow(r2,2));  
      theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
      theta4 = acos(r1 / length4);
      tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
      tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);

      return tip3_coord;
    }
&lt;/pre&gt;

&lt;p&gt;為了要讓 C 程式碼可以在 Pelican 網誌 Markdown 格式編輯模式下能夠與 highlight 套件結合, 首先程式碼中的所有大於與小於符號必須轉為 html special charactor 之外, 還要全部內縮, 否則內容將會在 Pelican 轉換過程中被視為 html 而自動加入錯誤的標註符號.&lt;/p&gt;
&lt;p&gt;以下則為 de 25 點四連桿尺寸合成參考程式:&lt;/p&gt;
&lt;pre class="brush: c"&gt;
    /***************************************************************
    **                                                            **
    **        D I F F E R E N T I A L     E V O L U T I O N       **
    **                                                            **
    ** Program: de.c                                              **
    ** Version: 3.6                                               **
    **                                                            **
    ** Authors: Dr. Rainer Storn                                  **
    **          c/o ICSI, 1947 Center Street, Suite 600           **
    **          Berkeley, CA 94707                                **
    **          Tel.:   510-642-4274 (extension 192)              **
    **          Fax.:   510-643-7684                              **
    **          E-mail: storn@icsi.berkeley.edu                   **
    **          WWW: http://http.icsi.berkeley.edu/~storn/        **
    **          on leave from                                     **
    **          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
    **          D-81739 Muenchen, Germany                         **
    **          Tel:    636-40502                                 **
    **          Fax:    636-44577                                 **
    **          E-mail: rainer.storn@zfe.siemens.de               **
    **                                                            **
    **          Kenneth Price                                     **
    **          836 Owl Circle                                    **
    **          Vacaville, CA 95687                               **
    **          E-mail: kprice@solano.community.net               ** 
    **                                                            **
    ** This program implements some variants of Differential      **
    ** Evolution (DE) as described in part in the techreport      **
    ** tr-95-012.ps of ICSI. You can get this report either via   **
    ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
    ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
    ** A more extended version of tr-95-012.ps is submitted for   **
    ** publication in the Journal Evolutionary Computation.       ** 
    **                                                            **
    ** You may use this program for any purpose, give it to any   **
    ** person or change it according to your needs as long as you **
    ** are referring to Rainer Storn and Ken Price as the origi-  **
    ** nators of the the DE idea.                                 **
    ** If you have questions concerning DE feel free to contact   **
    ** us. We also will be happy to know about your experiences   **
    ** with DE and your suggestions of improvement.               **
    **                                                            **
    ***************************************************************/
    /**H*O*C**************************************************************
    **                                                                  **
    ** No.!Version! Date ! Request !    Modification           ! Author **
    ** ---+-------+------+---------+---------------------------+------- **
    **  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
    **    +      +       +         + included                  +        **
    **  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
    **  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
    **  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
    **  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
    **  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
    **    +      +       +         + initialization            +        **
    **  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
    **  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
    **  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
    **  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
    **  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
    **  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
    **  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
    **  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
    **                                                                  **
    ***H*O*C*E***********************************************************/

    #include "stdio.h"
    #include "stdlib.h"
    #include "math.h"
    #include "memory.h"
    #include &amp;lt;time.h&amp;gt;

    // 最大族群數, NP
    #define MAXPOP  5000
    // 最大向量維度, D
    #define MAXDIM  60
    // 1 為最大化問題, 0 為最小化問題
    #define MAXIMAPROBLEM 0
    // 可能要配合最大或最小化進行變號
    #define PENALITY 1.0E20

    /*------Constants for rnd_uni()--------------------------------------------*/

    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)

    // 與機構合成相關的常數定義
    #define PI 3.1415926
    #define degree PI/180.0
    #define mech_loop -1
    #define NUM_OF_POINTS 25

    /*------------------------Macros----------------------------------------*/

    /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                               /* works only for small  */
                                                               /* arrays, but is faster.*/

    /*------------------------Globals---------------------------------------*/

    long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
    double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
    double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];

    /*---------Function declarations----------------------------------------*/

    void  assignd(int D, double a[], double b[]);
    double rnd_uni(long *idum);    /* uniform pseudo random number generator */
    double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */

    // 與機構合成相關的函式宣告
    double distance(double x0, double y0, double x1, double y1);
    double rr(double L1, double dd, double theta);
    struct Coord triangletip_coord(double x0, double y0, double R0, double R1, double x1, double y1, double localt);
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);
    // 用來利用 tip1 與 tip2 的座標, 以及 r1, r2 求最後的三角形頂點座標
    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);

    /*---------Function definitions-----------------------------------------*/
    // 指定向量 b 為 a
    void  assignd(int D, double a[], double b[])
    /**C*F****************************************************************
    **                                                                  **
    ** Assigns D-dimensional vector b to vector a.                      **
    ** You might encounter problems with the macro ASSIGND on some      **
    ** machines. If yes, better use this function although it's slower. **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
       int j;
       for (j=0; j&amp;lt;D; j++)
       {
          a[j] = b[j];
       }
    }

    // 產生 0 ~ 1 間的亂數
    double rnd_uni(long *idum)
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :rnd_uni()                                        **
    ** LONG_NAME      :random_uniform                                   **
    ** AUTHOR         :(see below)                                      **
    **                                                                  **
    ** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
    **                 dom number in the interval [0,1]. For further    **
    **                 reference see Press, W.H. et alii, Numerical     **
    **                 Recipes in C, Cambridge University Press, 1992.  **
    **                                                                  **
    ** FUNCTIONS      :none                                             **
    **                                                                  **
    ** GLOBALS        :none                                             **
    **                                                                  **
    ** PARAMETERS     :*idum    serves as a seed value                  **
    **                                                                  **
    ** PRECONDITIONS  :*idum must be negative on the first call.        **
    **                                                                  **
    ** POSTCONDITIONS :*idum will be changed                            **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
      long j;
      long k;
      static long idum2=123456789;
      static long iy=0;
      static long iv[NTAB];
      double temp;

      if (*idum &amp;lt;= 0)
      {
        if (-(*idum) &amp;lt; 1) *idum=1;
        else *idum = -(*idum);
        idum2=(*idum);
        for (j=NTAB+7;j&amp;gt;=0;j--)
        {
          k=(*idum)/IQ1;
          *idum=IA1*(*idum-k*IQ1)-k*IR1;
          if (*idum &amp;lt; 0) *idum += IM1;
          if (j &amp;lt; NTAB) iv[j] = *idum;
        }
        iy=iv[0];
      }
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &amp;lt; 0) *idum += IM1;
      k=idum2/IQ2;
      idum2=IA2*(idum2-k*IQ2)-k*IR2;
      if (idum2 &amp;lt; 0) idum2 += IM2;
      j=iy/NDIV;
      iy=iv[j]-idum2;
      iv[j] = *idum;
      if (iy &amp;lt; 1) iy += IMM1;
      if ((temp=AM*iy) &amp;gt; RNMX) return RNMX;
      else return temp;

    }/*------End of rnd_uni()--------------------------*/

    // 將上下限轉為全域變數
    double inibound_h;      /* upper parameter bound              */
    double inibound_l;      /* lower parameter bound              */
    // 與機構合成相關的全域變數
    // 宣告一個座標結構
    struct Coord {
        double x;
        double y;
      // 這裡保留 double z;
    };

    int main(int argc, char *argv[])
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :main()                                           **
    ** LONG_NAME      :main program                                     **
    ** AUTHOR         :Rainer Storn, Kenneth Price                      **
    **                                                                  **
    ** DESCRIPTION    :driver program for differential evolution.       **
    **                                                                  **
    ** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
    **                 fopen(), fclose(), fscanf().                     **
    **                                                                  **
    ** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
    **                                                                  **
    ** PARAMETERS     :argc            #arguments = 3                   **
    **                 argv            pointer to argument strings      **
    **                                                                  **
    ** PRECONDITIONS  :main must be called with three parameters        **
    **                 e.g. like de1 &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;, if     **
    **                 the executable file is called de1.               **
    **                 The input file must contain valid inputs accor-  **
    **                 ding to the fscanf() section of main().          **
    **                                                                  **
    ** POSTCONDITIONS :main() produces consecutive console outputs and  **
    **                 writes the final results in an output file if    **
    **                 the program terminates without an error.         **
    **                                                                  **
    ***C*F*E*************************************************************/

    {
       char  chr;             /* y/n choice variable                */
       char  *strat[] =       /* strategy-indicator                 */
       {
                "",
                "DE/best/1/exp",
                "DE/rand/1/exp",
                "DE/rand-to-best/1/exp",
                "DE/best/2/exp",
                "DE/rand/2/exp",
                "DE/best/1/bin",
                "DE/rand/1/bin",
                "DE/rand-to-best/1/bin",
                "DE/best/2/bin",
                "DE/rand/2/bin"
       };

       int   i, j, L, n;      /* counting variables                 */
       int   r1, r2, r3, r4;  /* placeholders for random indexes    */
       int   r5;              /* placeholders for random indexes    */
       int   D;               /* Dimension of parameter vector      */
       int   NP;              /* number of population members       */
       int   imin;            /* index to member with lowest energy */
       int   refresh;         /* refresh rate of screen output      */
       int   strategy;        /* choice parameter for screen output */
       int   gen, genmax, seed;   

       long  nfeval;          /* number of function evaluations     */

       double trial_cost;      /* buffer variable   */

       // 將上下限轉為全域變數, 可能要根據各變數加以設定
       //double inibound_h;      /* upper parameter bound              */
       //double inibound_l;      /* lower parameter bound              */
       double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
       double cost[MAXPOP];    /* obj. funct. values                 */
       double cvar;            /* computes the cost variance         */
       double cmean;           /* mean cost                          */
       double F,CR;            /* control variables of DE            */
       double cmin;            /* help variables                     */

       FILE  *fpin_ptr;
       FILE  *fpout_ptr;

    // 計算執行過程所需時間起點, 需要導入 time.h
      clock_t start = clock();

    /*------Initializations----------------------------*/

     //if (argc != 3)                                 /* number of arguments */
     //{
        //printf("\nUsage : de &amp;lt;input-file&amp;gt; &amp;lt;output-file&amp;gt;\n");
        //exit(1);
     //}

    // 將結果寫入 out.dat
     fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                              /* to see whether it already exists */
     /*
     if ( fpout_ptr != NULL )
     {
        printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
        printf("want to overwrite it, \nanything else if you want to exit.\n");
        chr = (char)getchar();
        if ((chr != 'y') &amp;amp;&amp;amp; (chr != 'Y'))
        {
          exit(1);
        }
        fclose(fpout_ptr);
     }
    */

    /*-----Read input data------------------------------------------------*/

     //fpin_ptr   = fopen(argv[1],"r");
    /*
     if (fpin_ptr == NULL)
     {
        printf("\nCannot open input file\n");
        exit(1);
     }*/

     //fscanf(fpin_ptr,"%d",&amp;amp;strategy);       /*---choice of strategy-----------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;genmax);         /*---maximum number of generations------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;refresh);        /*---output refresh cycle---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;D);              /*---number of parameters---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;NP);             /*---population size.-------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_h);    /*---upper parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;inibound_l);    /*---lower parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;F);             /*---weight factor----------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;amp;CR);            /*---crossing over factor---------------*/
     //fscanf(fpin_ptr,"%d",&amp;amp;seed);           /*---random seed------------------------*/
      strategy = 3;
      genmax = 200000;
      // refresh 為每幾筆運算後進行資料列印
      refresh = 100;
      // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 25 (NUM_OF_POINTS) 個通過點角度值
      // tmp[0~8] 為機構尺寸, tmp[9~33] 為通過點角度值
      D = 9 + NUM_OF_POINTS;
      NP = 200;
      // 機構變數值上限
      inibound_h = 50.;
      // 機構變數值下限
      inibound_l = 0.;
      // for strategy 1, F=0.9, CR = 1.
      // for strategy 2 F=0.7, CR=0.5
      // 一個小時得到 9.7 的誤差
      // 25 點的題目, 若 penality 只取 1000 則 F = 0.7 似乎為 最大 bound for strategy 1, CR = 1.
      F = 0.85;
      CR = 0.7;
      seed = 3;

     //fclose(fpin_ptr);

    /*-----Checking input variables for proper range----------------------------*/

      if (D &amp;gt; MAXDIM)
      {
         printf("\nError! D=%d &amp;gt; MAXDIM=%d\n",D,MAXDIM);
         exit(1);
      }
      if (D &amp;lt;= 0)
      {
         printf("\nError! D=%d, should be &amp;gt; 0\n",D);
         exit(1);
      }
      if (NP &amp;gt; MAXPOP)
      {
         printf("\nError! NP=%d &amp;gt; MAXPOP=%d\n",NP,MAXPOP);
         exit(1);
      }
      if (NP &amp;lt;= 0)
      {
         printf("\nError! NP=%d, should be &amp;gt; 0\n",NP);
         exit(1);
      }
      if ((CR &amp;lt; 0) || (CR &amp;gt; 1.0))
      {
         printf("\nError! CR=%f, should be ex [0,1]\n",CR);
         exit(1);
      }
      if (seed &amp;lt;= 0)
      {
         printf("\nError! seed=%d, should be &amp;gt; 0\n",seed);
         exit(1);
      }
      if (refresh &amp;lt;= 0)
      {
         printf("\nError! refresh=%d, should be &amp;gt; 0\n",refresh);
         exit(1);
      }
      if (genmax &amp;lt;= 0)
      {
         printf("\nError! genmax=%d, should be &amp;gt; 0\n",genmax);
         exit(1);
      }
      if ((strategy &amp;lt; 0) || (strategy &amp;gt; 10))
      {
         printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
         exit(1);
      }
      if (inibound_h &amp;lt; inibound_l)
      {
         printf("\nError! inibound_h=%f &amp;lt; inibound_l=%f\n",inibound_h, inibound_l);
         exit(1);
      }


    /*-----Open output file-----------------------------------------------*/

       //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */

       //if (fpout_ptr == NULL)
       //{
          //printf("\nCannot open output file\n");
          //exit(1);
       //}


    /*-----Initialize random number generator-----------------------------*/

     rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
     nfeval       =  0;  /* reset number of function evaluations */



    /*------Initialization------------------------------------------------*/
    /*------Right now this part is kept fairly simple and just generates--*/
    /*------random numbers in the range [-initfac, +initfac]. You might---*/
    /*------want to extend the init part such that you can initialize-----*/
    /*------each parameter separately.------------------------------------*/

       for (i=0; i&amp;lt;NP; i++)
       {
          for (j=0; j&amp;lt;D; j++) /* spread initial population members */
          {
            c[i][j] = inibound_l + rnd_uni(&amp;amp;rnd_uni_init)*(inibound_h - inibound_l);
          }
          cost[i] = evaluate(D,c[i],&amp;amp;nfeval); /* obj. funct. value */
       }
       cmin = cost[0];
       imin = 0;
       for (i=1; i&amp;lt;NP; i++)
       {
         if(MAXIMAPROBLEM == 1)
         {
           // 最大化問題
            if (cost[i]&amp;gt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
          else
          {
            // 最小化問題
            if (cost[i]&amp;lt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
       }

       assignd(D,best,c[imin]);            /* save best member ever          */
       assignd(D,bestit,c[imin]);          /* save best member of generation */

       pold = &amp;amp;c; /* old population (generation G)   */
       pnew = &amp;amp;d; /* new population (generation G+1) */

    /*=======================================================================*/
    /*=========Iteration loop================================================*/
    /*=======================================================================*/

       gen = 0;                          /* generation counter reset */
       while ((gen &amp;lt; genmax) /*&amp;amp;&amp;amp; (kbhit() == 0)*/) /* remove comments if conio.h */
       {                                            /* is accepted by compiler    */
          gen++;
          imin = 0;

          for (i=0; i&amp;lt;NP; i++)         /* Start of loop through ensemble  */
          {
         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 2 !!!     */
           r1 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while(r1==i);            

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 3 !!!     */
           r2 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r2==i) || (r2==r1));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 4 !!!     */
           r3 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r3==i) || (r3==r1) || (r3==r2));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 5 !!!     */
           r4 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &amp;lt; 6 !!!     */
           r5 = (int)(rnd_uni(&amp;amp;rnd_uni_init)*NP);
         }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));


    /*=======Choice of strategy===============================================================*/
    /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
    /*=======DE :  stands for Differential Evolution==========================================*/
    /*=======x  :  a string which denotes the vector to be perturbed==========================*/
    /*=======y  :  number of difference vectors taken for perturbation of x===================*/
    /*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
    /*                                                                                        */
    /*=======There are some simple rules which are worth following:===========================*/
    /*=======1)  F is usually between 0.5 and 1 (in rare cases &amp;gt; 1)===========================*/
    /*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
    /*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
    /*           happens.                                                                     */
    /*=======4)  If you increase NP, F usually has to be decreased============================*/
    /*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/


    /*=======EXPONENTIAL CROSSOVER============================================================*/

    /*-------DE/best/1/exp--------------------------------------------------------------------*/
    /*-------Our oldest strategy but still not bad. However, we have found several------------*/
    /*-------optimization problems where misconvergence occurs.-------------------------------*/
    // 1 為最原始的解題邏輯方法
         if (strategy == 1) /* strategy DE0 (not in our paper) */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/1/exp-------------------------------------------------------------------*/
    /*-------This is one of my favourite strategies. It works especially well when the-------*/
    /*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
    /*-------as a first guess.---------------------------------------------------------------*/
      // 配合邏輯方法 2 選用 R=0.7, CR=0.5
       else if (strategy == 2) /* strategy DE1 in the techreport */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
    /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
    /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
    /*-------should play around with all three control variables.----------------------------*/
         // 方法 3 建議 F=0.85 CR=1.
       else if (strategy == 3) /* similiar to DE2 but generally better */
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                       
             tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
         else if (strategy == 4)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }
    /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
         else if (strategy == 5)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) &amp;amp;&amp;amp; (L &amp;lt; D));
         }

    /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/

    /*-------DE/best/1/bin--------------------------------------------------------------------*/
         else if (strategy == 6) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/1/bin-------------------------------------------------------------------*/
         else if (strategy == 7) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
         else if (strategy == 8) 
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/best/2/bin--------------------------------------------------------------------*/
         else if (strategy == 9)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/2/bin--------------------------------------------------------------------*/
         else
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;amp;rnd_uni_init)*D); 
               for (L=0; L&amp;lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;amp;rnd_uni_init) &amp;lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }


    /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
         trial_cost = evaluate(D,tmp,&amp;amp;nfeval);  /* Evaluate new vector in tmp[] */
       if(MAXIMAPROBLEM == 1)
       {
        // 改為最大化
           if (trial_cost &amp;gt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;gt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }
        else
        {
              // 最小化問題
           if (trial_cost &amp;lt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&amp;lt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }

          }   /* End mutation loop through pop. */

          assignd(D,bestit,best);  /* Save best population member of current iteration */

          /* swap population arrays. New generation becomes old one */

          pswap = pold;
          pold  = pnew;
          pnew  = pswap;

    /*----Compute the energy variance (just for monitoring purposes)-----------*/

          cmean = 0.;          /* compute the mean value first */
          for (j=0; j&amp;lt;NP; j++)
          {
             cmean += cost[j];
          }
          cmean = cmean/NP;

          cvar = 0.;           /* now the variance              */
          for (j=0; j&amp;lt;NP; j++)
          {
             cvar += (cost[j] - cmean)*(cost[j] - cmean);
          }
          cvar = cvar/(NP-1);


    /*----Output part----------------------------------------------------------*/

          if (gen%refresh==1)   /* display after every refresh generations */
          { /* ABORT works only if conio.h is accepted by your compiler */
        printf("\n\n                         PRESS ANY KEY TO ABORT"); 
        printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);

        for (j=0;j&amp;lt;D;j++)
        {
          printf("\n best[%d]=%-15.10g",j,best[j]);
        }
        printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
        printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
                   NP,F,CR,cvar);
          }

          fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
       }
    /*=======================================================================*/
    /*=========End of iteration loop=========================================*/
    /*=======================================================================*/

    /*-------Final output in file-------------------------------------------*/


       fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);

       for (j=0;j&amp;lt;D;j++)
       {
         fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
       }
       fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
       fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
               NP,F,CR,cvar); 

      fclose(fpout_ptr);

      /* Code you want timed here */
      printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
      return(0);
    }

    /*-----------End of main()------------------------------------------*/

    // 適應函式 fittness function (cost function)
    double evaluate(int D, double tmp[], long *nfeval)
    {
      // 先處理通過 5 個點的四連桿問題
      // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
      // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
      // L1 為第一桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[4]
      // L2 為第二桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[5]
      // L3 為第三桿件的長度, 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[6]
      // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
      // L5, L6 必須 &amp;gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
      // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
      // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
      // 這裡的輸入角度值, 將採用以第一角度&amp;gt;0 作為起點, 隨後則為角度增量, 也都必須大於零
      // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
      // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
      /* void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
      struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
      double input_angles[NUM_OF_POINTS], result, total_angle;
      int i;

      (*nfeval)++;

      target_points[0].x = 4.5;
      target_points[0].y = 6.75;

      target_points[1].x = 5.07;
      target_points[1].y = 6.85;

      target_points[2].x = 5.45;
      target_points[2].y = 6.84;

      target_points[3].x = 5.89;
      target_points[3].y = 6.83;

      target_points[4].x = 6.41;
      target_points[4].y = 6.8;

      target_points[5].x = 6.92;
      target_points[5].y = 6.58;

      target_points[6].x = 7.03;
      target_points[6].y = 5.99;

      target_points[7].x = 6.95;
      target_points[7].y = 5.45;

      target_points[8].x = 6.77;
      target_points[8].y = 5.03;

      target_points[9].x = 6.4;
      target_points[9].y = 4.6;

      target_points[10].x = 5.91;
      target_points[10].y = 4.03;

      target_points[11].x = 5.43;
      target_points[11].y = 3.56;

      target_points[12].x = 4.93;
      target_points[12].y = 2.94;

      target_points[13].x = 4.67;
      target_points[13].y = 2.6;

      target_points[14].x = 4.38;
      target_points[14].y = 2.2;

      target_points[15].x = 4.04;
      target_points[15].y = 1.67;

      target_points[16].x = 3.76;
      target_points[16].y = 1.22;

      target_points[17].x = 3.76;
      target_points[17].y = 1.97;

      target_points[18].x = 3.76;
      target_points[18].y = 2.78;

      target_points[19].x = 3.76;
      target_points[19].y = 3.56;

      target_points[20].x = 3.76;
      target_points[20].y = 4.34;

      target_points[21].x = 3.76;
      target_points[21].y = 4.91;

      target_points[22].x = 3.76;
      target_points[22].y = 5.47;

      target_points[23].x = 3.8;
      target_points[23].y = 5.98;

      target_points[24].x = 4.07;
      target_points[24].y = 6.4;


      // 輸入角度值與 tmp[] 的設定
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        input_angles[i] = tmp[i + 9];
      }

      // 呼叫 mechanism() 以便計算 output_points[]
      mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);

      // for debug
      /*
      if(*nfeval%5000 == 0)
      {
        for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
        {
          printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
        }
        printf("#####################################\n");
      }
    */
      // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
      result = error_function(output_points, target_points);
      // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result

     // x0 與 x1 點位於 -50 與 50 中間
        for(i = 0; i &amp;lt; 4; i++)
      {
        if(tmp[i] &amp;lt; -100 || tmp[i] &amp;gt; 100){
          return PENALITY;
        }
      }

      // 三個連桿值, 一定要為正
        for(i = 4; i &amp;lt; 7; i++)
      {
        if(tmp[i] &amp;lt; 0 || tmp[i] &amp;gt; 100){
          return PENALITY;
        }
      }

        // L5 L6 可以為 0 或負值
        for(i = 7; i &amp;lt; 9; i++)
      {
        if(tmp[i] &amp;lt; -100 || tmp[i] &amp;gt; 100){
          return PENALITY;
        }
      }

      // 角度值不可以小於 0

      for(i = 1; i &amp;lt;= NUM_OF_POINTS; i++)
      {
        if(tmp[D-i] &amp;lt; 0){
          return PENALITY;
        }
      }


      /*
      for(i = 0; i &amp;lt; D - NUM_OF_POINTS; i++)
      {
          if((tmp[i] &amp;lt;= inibound_l)|| (tmp[i] &amp;gt;inibound_h)){
          return PENALITY;
        }
      }

      for(i = 1; i &amp;lt;= NUM_OF_POINTS; i++)
      {
        if(tmp[D-i] &amp;lt; 0){
          return PENALITY;
        }
      }
      */
      return result;

      /*
       double result=0, surface = 80.0, z, volume, penality;
       (*nfeval)++;
       z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
       volume = tmp[0]*tmp[1]*z;

      if(volume &amp;lt;= 0){
        return PENALITY;
      }

      if((tmp[0] &amp;lt;= inibound_l)|| (tmp[0] &amp;gt;inibound_h)){
        return PENALITY;
      }

      if((tmp[1] &amp;lt;= inibound_l) || (tmp[1] &amp;gt;inibound_h)){
        return PENALITY;
      }
      // volume must &amp;gt;0 and max volume
      // 目前為最小化問題
       return 1+1/(volume*volume);
       */
    }

    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
    {
        struct Coord tip_coord;

        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
        }
        else
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
        pow(x1-x0,2))/2)+x0;
        }

    // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
        if (localt&amp;gt;=0 &amp;amp;&amp;amp; localt &amp;lt;PI)
        {
            tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    // 利用 sqrtt 居中進行代換所得到的式子
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;

        }
        else
        {
            tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
        }

      return tip_coord;
    }

    double distance(double x0, double y0, double x1, double y1)
    {
        double distance_value;
        distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
        return distance_value;
    }

    double rr(double L1, double dd, double theta)
    {
        double rr_value;
        rr_value = sqrt(L1*L1+dd*dd - 2*L1*dd*cos(theta));
        return rr_value;
    }

    // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
    {
      // 這裡的輸入角度, 改採第一角度為起始角, 隨後的角度值則為增量值
      // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
      // 以下為可能的處理變數宣告
      // 這裡希望能夠定義一個 struct 來處理座標點
      double rr_length, dd_length, angle;
      struct Coord link1_tip, link2_tip, triangle_tip;
        double angle2, angle3;
      int i;

      // 開始進行三角形頂點座標的計算
      // 以下變數由每一個體向量提供
      /*
        x0 = 0.0;
        y0 = 0.0;
        x1 = 10.0;
        y1 = 0.0;
        L1 = 5.0;
        L2 = 20;
        L3 = 10;
        L5 = 10;
        L6 = 10;
      */
      dd_length = distance(x0, y0, x1, y1);
      /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
      // 假如採用 finaltip_coord, 則不需要 angle3
      angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));

      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        // 先建立第一點座標, 即 i=0 者
        // i=0;
        // angle = i*degree;

        /*
        // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
        if(i &amp;gt; 0)
        {
          input_angles[i] = input_angles[i] + input_angles[i-1];
        }
        */
        angle = input_angles[i]*degree;
        rr_length = rr(L1, dd_length, angle);
        // 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
        // 第二次三角形疊代
        /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
        // 第三次三角形疊代
        //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
      }
    }

    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
    {
      double error = 0.0;
      int i;
      for(i = 0; i &amp;lt; NUM_OF_POINTS; i++)
      {
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
      }
      return error;
    }

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
    {
      struct Coord tip3_coord;
      double theta3, theta4, length3, length4;
      length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
      length4 = sqrt(pow(r1,2) + pow(r2,2));  
      theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
      theta4 = acos(r1 / length4);
      tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
      tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);

      return tip3_coord;
    }
&lt;/pre&gt;</summary><category term="RGA"></category></entry><entry><title>yen - 如何建立一好的 Wordpress 網站</title><link href="http://project.mde.tw/blog/yen-ru-he-jian-li-yi-hao-de-wordpress-wang-zhan.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ru-he-jian-li-yi-hao-de-wordpress-wang-zhan.html</id><summary type="html">&lt;p&gt;機械設計專題專用的 Wordpress 必須俱備幾項特點: 能夠輸入數學公式, 能夠放入高亮顯示的程式碼, 能夠內嵌影片, 能夠利用 Gmail 帳號寄信, 能夠納入 Disqus 討論區, 能夠杜絕垃圾註冊.&lt;/p&gt;


&lt;p&gt;當然假如能夠如 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html&lt;/a&gt; 中所言, 可以利用 Leo Editor 的指令按鈕, 讓 Wordpress 網誌內容能與 Pelican 靜態網誌內容保持同步, 或許就能同時擁有改版歷程資料與即時動態維護內容的優點.&lt;/p&gt;
&lt;p&gt;Disqus 的討論區留言首推: &lt;a href="https://wordpress.org/plugins/disqus-comment-system/"&gt;https://wordpress.org/plugins/disqus-comment-system/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嵌入影片專用: &lt;a href="https://wordpress.org/plugins/iframe/"&gt;https://wordpress.org/plugins/iframe/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;程式碼的高亮則建議使用: &lt;a href="https://wordpress.org/plugins/syntaxhighlighter/"&gt;https://wordpress.org/plugins/syntaxhighlighter/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;輸入數學公式: &lt;a href="https://wordpress.org/plugins/wp-latex/"&gt;https://wordpress.org/plugins/wp-latex/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;寄信 plugin: &lt;a href="https://wordpress.org/plugins/wp-latex/"&gt;https://wordpress.org/plugins/wp-latex/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;防止垃圾註冊 plugin: &lt;a href="https://wordpress.org/plugins/wp-recaptcha/"&gt;https://wordpress.org/plugins/wp-recaptcha/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至於, 在 WordPress 網誌中利用 &lt;a href="https://wordpress.org/plugins/wp-mail-smtp/"&gt;https://wordpress.org/plugins/wp-mail-smtp/&lt;/a&gt; Plugin 與 Gmail 帳號寄信的設定, 有兩個關鍵:&lt;/p&gt;
&lt;p&gt;第1項就是設定選項:&lt;/p&gt;
&lt;p&gt;選擇 Send all WordPress emails via SMTP&lt;/p&gt;
&lt;p&gt;選擇 smtp.gmail.com: 465&lt;/p&gt;
&lt;p&gt;選擇 Use SSL encryption&lt;/p&gt;
&lt;p&gt;選擇 Use SMTP authentication&lt;/p&gt;
&lt;p&gt;然後給定對應的 Gmail 帳號 與 Gmail 密碼 之後存檔.&lt;/p&gt;
&lt;p&gt;第2項設定則是必須配合所使用的 Gmail 帳號, 利用 &lt;a href="https://www.google.com/settings/security/lesssecureapps"&gt;https://www.google.com/settings/security/lesssecureapps&lt;/a&gt; 將原定的 Turn off 改為 Turn on, 也就是降低安全設定等級, 接著就可以寄出測試信件, 若成功, 則 WordPress 中的其他模組就可以利用設定寄信.&lt;/p&gt;</summary><category term="Wordpress"></category></entry><entry><title>yen - Solvespace 與 V-rep 結合應用</title><link href="http://project.mde.tw/blog/yen-solvespace-yu-v-rep-jie-he-ying-yong.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-solvespace-yu-v-rep-jie-he-ying-yong.html</id><summary type="html">&lt;p&gt;Solvespace 是一套小型的參數式 3D 繪圖開源套件, 而 V-rep 則是一套允許教育界免費使用的開源動態模擬套件, 結合這兩個套件在機械設計專題應用, 一方面使用者可以在可攜的架構下來進行產品開發與模擬, 更重要的是, 使用者可以透過原始程式碼, 一窺專業人士編寫電腦輔助機械設計與分析工具時, 所應用的理論分析與基本架構.&lt;/p&gt;


&lt;p&gt;Solvespace: &lt;a href="http://solvespace.com/"&gt;http://solvespace.com/&lt;/a&gt; 與 &lt;a href="https://github.com/whitequark/solvespace"&gt;https://github.com/whitequark/solvespace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;V-rep: &lt;a href="http://www.coppeliarobotics.com/"&gt;http://www.coppeliarobotics.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/solvespace_v-rep.png" width="800" /&gt;&lt;/p&gt;</summary><category term="Solvespace"></category><category term="V-rep"></category></entry><entry><title>yen - 編譯 Solvespace</title><link href="http://project.mde.tw/blog/yen-bian-yi-solvespace.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-bian-yi-solvespace.html</id><summary type="html">&lt;p&gt;我們有沒有能力在機械設計專題中, 自行編譯 Solvespace, 並且了解其中的原理後, 新增自己需要的零件設計功能?&lt;/p&gt;


&lt;p&gt;&lt;a href="https://github.com/whitequark/solvespace"&gt;https://github.com/whitequark/solvespace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://solvespace.com"&gt;http://solvespace.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自行編譯 solvespace:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;從 &lt;a href="http://www.activestate.com/activeperl/downloads"&gt;http://www.activestate.com/activeperl/downloads&lt;/a&gt; 下載 ActivePerl, 並完成安裝.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下載並安裝 Visual Studio Express.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;從 Visual Studio Express 表單中啟動 Dos Command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進入 Solvespace Makefile 所在目錄, 執行 nmake.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以完成 Solvespace.exe 的編譯.&lt;/p&gt;</summary><category term="Solvespace"></category><category term="MCAD"></category></entry><entry><title>yen - 如何參與 project.mde.tw 的協同編輯</title><link href="http://project.mde.tw/blog/yen-ru-he-can-yu-projectmdetw-de-xie-tong-bian-ji.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-ru-he-can-yu-projectmdetw-de-xie-tong-bian-ji.html</id><summary type="html">&lt;p&gt;只要是 KMOL 機械設計專題的成員, 就可以依照特定程序, 管理 project.mde.tw 網站上的資料&lt;/p&gt;


&lt;p&gt;首先, 你必須是 &lt;a href="https://github.com/coursemdetw/project_site/watchers"&gt;https://github.com/coursemdetw/project_site/watchers&lt;/a&gt; 名單上的成員, 否則就必須透過 Pull Request 的方式來參與 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 網誌內容的協同管理.&lt;/p&gt;
&lt;p&gt;接下來, 利用 git clone 的方式, 將 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 的倉儲資料複製到近端, 並且將分支切換到 gh-pages, 就可以利用 Leo Editor 開啟或建立, 位於 users 目錄中的 user_template.leo, 然後轉存為"學號.leo" 檔案, 透過這個 Leo Editor 的專案檔, 就可以新增文章, 修改其他人的文章, 甚至修改本網誌系統中的任何設定.&lt;/p&gt;
&lt;p&gt;將 user_template.leo 轉存為 "學號.leo" 後, 第1件重要的事就是修改 @edit user_20160301.md 中的 user_20160301.md 的存檔檔名, 改為 學號_當天日期.md, 然後修改此一 md 檔案的文章標題: Title: user - 使用者的範例網誌文章標題, 因為這個網誌系統根據 Title: 之後的名稱來轉換 html, 若有兩個 .md 檔案的 Title: 資料完全一樣, Pelican 將無法轉檔, 並且會在轉檔的命令列中出現錯誤訊息.&lt;/p&gt;
&lt;p&gt;其他的 .md 檔案中, Category: 為文章的類別, 可以參考現有的"2016g1, Misc 與 Tutorial" 等3個類別, 可以是組別或是文章的屬性類別.
Tags: 則是文章的內容標籤,可以就文章的內容關鍵字加以界定, 至於 Author: 則是用戶的名稱.&lt;/p&gt;
&lt;p&gt;在每一個 .md 檔案中, 出現在 "PELICAN_END_SUMMARY" 超文件註解標註之前的內容, Pelican 會視為文章的摘要, 當各文章並列時, 文章只會列出標題與摘要.&lt;/p&gt;
&lt;p&gt;"PELICAN_END_SUMMARY" 超文件註解標註之後的內容就是文章的主要內容.&lt;/p&gt;
&lt;p&gt;文章中的程式可以利用:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
for i in range(5):
    print(i, ":hello")
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;來加以標示.&lt;/p&gt;
&lt;p&gt;圖檔則可以利用 img 標註引用:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/chiamingyen/kmolab/gh-pages/logo/kmol_1172x340_color_3yrs.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;影片引用則可以直接使用 Vimeo 或 Youtube 的 embedded 語法.&lt;/p&gt;
&lt;p&gt;因為本網誌能夠在近端與遠端等兩個不同環境下運作, 而兩端的關鍵字搜尋流程與格式不同, 因此轉檔的按鈕也分為 local-pelican 與 gh-pages-pelican 等兩個, 要在近端測試時, 必須滑鼠停在 local-pelican 轉檔按鈕的對應節點上, 然後按下 local-pelican, 經過瀏覽器檢查近端文章轉檔與內容無誤後, 必須將滑鼠停在 gh-pages-pelican 轉檔按鈕的對應節點上, 然後按下 gh-pages-pelican 按鈕, 之後若無任何問題, 就可以將資料提交推送到遠端倉儲的 gh-pages 分支中, 指令如下:&lt;/p&gt;
&lt;p&gt;git add -A&lt;/p&gt;
&lt;p&gt;git commit -m "提交說明訊息"&lt;/p&gt;
&lt;p&gt;git push origin gh-pages&lt;/p&gt;
&lt;p&gt;最後, 與 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 網站維護有關的訊息溝通或註記, 請透過 &lt;a href="https://github.com/coursemdetw/project_site/wiki/%E6%A9%9F%E6%A2%B0%E8%A8%AD%E8%A8%88%E5%B0%88%E9%A1%8C%E5%8D%94%E5%90%8C%E7%B6%B2%E7%AB%99%E8%A8%98%E4%BA%8B"&gt;倉儲 Wiki&lt;/a&gt; 進行.&lt;/p&gt;</summary><category term="Pelican"></category><category term="Leo Editor"></category></entry><entry><title>yen - 網際 Flask 程式架構</title><link href="http://project.mde.tw/blog/yen-wang-ji-flask-cheng-shi-jia-gou.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-wang-ji-flask-cheng-shi-jia-gou.html</id><summary type="html">&lt;p&gt;Flask 是一套支援 Python3 的全球資訊網程式框架, 這裡希望用它來開發網際輔助機械設計程式.&lt;/p&gt;


&lt;p&gt;&lt;a href="http://flask.pocoo.org/"&gt;http://flask.pocoo.org/&lt;/a&gt; 是一套簡潔的 Python3 網際程式框架, 在這一系列的導引資料中, 將利用 &lt;a href="https://github.com/2015fallhw/simpleflask"&gt;https://github.com/2015fallhw/simpleflask&lt;/a&gt; 倉儲來存放資料, 並將資料同步推送到 &lt;a href="http://simpleflask-2014openshift.rhcloud.com/"&gt;http://simpleflask-2014openshift.rhcloud.com/&lt;/a&gt; 執行.&lt;/p&gt;
&lt;h2&gt;程式環境&lt;/h2&gt;
&lt;p&gt;假如在 Windows 環境中, 使用可攜套件: &lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;, 則已經內建 Flask 模組, 假如沒有, 可以利用&lt;/p&gt;
&lt;p&gt;pip install Flask 安裝.&lt;/p&gt;
&lt;p&gt;假如是在 Ubuntu, 可以要用 pip3 install Flask 安裝, 至於在 OpenShift 的 Python3 應用程式, 則是透過 setup.py 安裝.&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#setup.py 檔案
from setuptools import setup

setup(name='KMOL 2016 project',
      version='1.0',
      description='OpenShift App',
      author='KMOL',
      author_email='course@mde.tw',
      url='https://www.python.org/community/sigs/current/distutils-sig',
      install_requires=['Flask&gt;=0.10.1'],
     )
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;由於這裡所開發的 Flask 程式, 需要在近端與 OpenShift 都能運作, 因此 wsgi.py 的內容設計為:&lt;/p&gt;
&lt;pre class="brush: python;"&gt;
#!/usr/bin/python
# 導入 os 模組, 主要用來判斷是否在 OpenShift 上執行
import os
# 導入同目錄下的 myflaskapp.py
import myflaskapp

# 以下開始判斷在 OpenShift 或近端執行
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示程式在雲端執行
    application = myflaskapp.app
else:
    # 表示在近端執行, 以 python3 wsgi.py 執行,  若採 uwsgi 則與 Openshift 運作模式相同
    myflaskapp.app.run(debug=True)
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;也就是說, wsgi.py  會透過os.environ.keys() 的值來判定執行的環境, 若是在 uwsgi 的環境執行時, 則必須使用與 OpenShift 環境相同的啟動模式.&lt;/p&gt;
&lt;p&gt;而 wsgi.py 中所導入的 myflaskapp.py 內容則為:&lt;/p&gt;
&lt;pre class="brush: python; html-script: false"&gt;
# coding: utf-8
from flask import Flask, send_from_directory, request, redirect, render_template, session, make_response
import random

app = Flask(__name__)

# 使用 session 必須要設定 secret_key
# In order to use sessions you have to set a secret key
# set the secret key.  keep this really secret:
app.secret_key = 'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T'

@app.route("/")
def index():
    #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零
    # 將標準答案存入 answer session 對應區
    theanswer = random.randint(1, 100)
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    session['answer'] = theanswer
    session['count'] = thecount

    return render_template("index.html", answer=theanswer, count=thecount)

@app.route('/user/&lt;name&gt;')
# 為了避免 syntaxhighlighter 自動加上 &lt;/name&gt;, 在這裡先行用註解補上, 之後再找解決方案
def user(name):
    return render_template("user.html", name=name)
@app.route('/red')
def red():
    # 重新導向 google
    return redirect("http://www.google.com")
@app.route('/guessform')
def guessform():
    session["count"] += 1
    guess = session.get("guess")
    theanswer = session.get("answer")
    count = session.get("count")
    return render_template("guessform.html", guess=guess, answer=theanswer, count=count)
@app.route('/docheck', methods=['POST'])
def docheck():
    # session[] 存資料
    # session.get() 取 session 資料
    # 利用 request.form[] 取得表單欄位資料, 然後送到 template
    guess = request.form["guess"]
    session["guess"] = guess
    # 假如使用者直接執行 doCheck, 則設法轉回根方法
    if guess is None:
        redirect("/")
    # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況
    try:
        theanswer = int(session.get('answer'))
    except:
        redirect("/")
    # 經由表單所取得的 guess 資料型別為 string
    try:
        theguess = int(guess)
    except:
        return redirect("/guessform")
    # 每執行 doCheck 一次,次數增量一次
    session["count"] += 1
    count = session.get("count")
    # 答案與所猜數字進行比對
    if theanswer &lt; theguess:
        return render_template("toobig.html", guess=guess, answer=theanswer, count=count)
    elif theanswer &gt; theguess:
        return render_template("toosmall.html", guess=guess, answer=theanswer, count=count)
    else:
        # 已經猜對, 從 session 取出累計猜測次數
        thecount = session.get('count')
        return "猜了 "+str(thecount)+" 次, 終於猜對了, 正確答案為 "+str(theanswer)+": &lt;a href='/'&gt;再猜&lt;/a&gt;"
    return render_template("docheck.html", guess=guess)

@app.route('/option', methods=["GET", "POST"])
def option():
    option_list1 = ["1", "2", "3", "4"]
    option_list2 = ["a", "b"]

    return render_template('option.html', option_list1=option_list1, option_list2=option_list2)
@app.route('/optionaction', methods=['POST'])
def optionaction():
    # 這裡將根據使用者所選擇的選項值, 來進行後續的設計運算
    return request.form["option1"] + ":" + request.form["option2"]
    # 等運算或資料處理結束後, 再將相關值送到對應的 template 進行資料的展示
    #return render_template('optionaction.html', option_list1=option_list1, option_list2=option_list2)


if __name__ == "__main__":
    app.run()
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;此外, 因為 Flask 內定靜態目錄名稱為 static, 且 template 名稱為 templates, 因此在最基本的 Flask 程式架構中, 也需要自行建立這兩個目錄, 然後將靜態文件放入 static 目錄中, 而對應的  template 文件檔案, 則放入 templates 目錄中.&lt;/p&gt;</summary><category term="OpenShift"></category><category term="Flask"></category></entry><entry><title>yen - 2016 年專題啟動</title><link href="http://project.mde.tw/blog/yen-2016-nian-zhuan-ti-qi-dong.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>yen</name></author><id>tag:project.mde.tw,2016-07-01:blog/yen-2016-nian-zhuan-ti-qi-dong.html</id><summary type="html">&lt;p&gt;利用 Github Pages 與 Pelican 建立協同專題製作網誌&lt;/p&gt;


&lt;h2&gt;機械設計工程網誌啟動&lt;/h2&gt;
&lt;p&gt;本網誌自 2016 Spring 開始啟動, 相關建置步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以 &lt;a href="https://github.com/coursemdetw"&gt;https://github.com/coursemdetw&lt;/a&gt; 帳號建立 Gihub 倉儲 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;將倉儲資料 git clone 到近端&lt;/li&gt;
&lt;li&gt;利用 git branch 指令, 建立 gh-pages 分支&lt;/li&gt;
&lt;li&gt;利用 git checkout 指令, 切換至 gh-pages 分支&lt;/li&gt;
&lt;li&gt;開始建立 Pelican 網誌所需的協同架構資料&lt;/li&gt;
&lt;li&gt;安排 users 目錄, 將分別存放各協同組員的 .leo 檔案&lt;/li&gt;
&lt;li&gt;確定 gh-pages 分支中的網誌 &lt;a href="http://coursemdetw.github.io/project_site/"&gt;http://coursemdetw.github.io/project_site/&lt;/a&gt; 可以正常運作&lt;/li&gt;
&lt;li&gt;根據 Github pages 專用網域設定說明 &lt;a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/"&gt;https://help.github.com/articles/using-a-custom-domain-with-github-pages/&lt;/a&gt;, 建立 CNAME, 納入 project.mde.tw&lt;/li&gt;
&lt;li&gt;將 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 倉儲的 Default Branch 設為 gh-pages 分支&lt;/li&gt;
&lt;li&gt;在 mde.tw 網域的 DNS 代管設定中, 加入 project.mde.tw 與 coursemdetw.github.io 之間的 CNAME 別名設定&lt;/li&gt;
&lt;li&gt;等待 CNAME 別名生效後, &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 即可正常連結使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Pelican 網誌設定&lt;/h2&gt;
&lt;p&gt;由於本網誌將 Pelican &lt;a href="https://github.com/getpelican/pelican"&gt;https://github.com/getpelican/pelican&lt;/a&gt; 設定相關的所有資料都留在 Gihub 倉儲 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 中, 目的在讓其他人可以參考本網誌的所有細節內容. 一般在實際應用, 只需將 blog 目錄 &lt;a href="https://github.com/coursemdetw/project_site/tree/gh-pages/blog"&gt;https://github.com/coursemdetw/project_site/tree/gh-pages/blog&lt;/a&gt; 中的資料送到全球資訊網伺服器即可.&lt;/p&gt;
&lt;p&gt;本專題製作採用 &lt;a href="http://leoeditor.com/"&gt;http://leoeditor.com/&lt;/a&gt; 管理所有資料, 但各參與協同的人員各自在 users 目錄下擁有一個 .leo 檔案, 可以分別控管本網誌的所有設定, 並且以協同方式維護網誌內容.&lt;/p&gt;
&lt;p&gt;本網誌分為近端與 Github Pages 端的資料管理配置, 關鍵字搜尋採用 &lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/tipue_search"&gt;https://github.com/getpelican/pelican-plugins/tree/master/tipue_search&lt;/a&gt;, 近端的設定檔案為 local_publishconf.py, 而 Github Pages 端的特有設定為 publishconf.py, 且為了區隔兩端的資料連結差異, 近端的 Pelican 轉檔按鈕為 @button local pelican, 而 Github Pages 端的轉檔按鈕為 @button gh-pages pelican.&lt;/p&gt;
&lt;p&gt;最後, 為了有效區隔各組員所寫的網誌文章, content 目錄內的各 .md 檔案, 除了要求必須冠上組員帳號外, 也希望在文章標題前面加上組員帳號標示, 以避免組員間因為使用相同的文章標題名稱而無法正確完成 Pelican 網誌的轉檔 (本系統採用自動文章標題轉換為 html 檔名的設定).&lt;/p&gt;
&lt;h2&gt;組員參與協同&lt;/h2&gt;
&lt;p&gt;所有專題製作成員均為 &lt;a href="https://github.com/coursemdetw/project_site"&gt;https://github.com/coursemdetw/project_site&lt;/a&gt; 倉儲的協同者, git clone 資料後, 即可將分支固定在 gh-pages 後進行各項資料協同管理的工作.&lt;/p&gt;
&lt;p&gt;參與協同的步驟:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git clone 倉儲資料.&lt;/li&gt;
&lt;li&gt;確定在近端已經切換分支到 gh-pages, 利用  Leo Editor 開啟 users 目錄下的 user_template.leo 檔案.&lt;/li&gt;
&lt;li&gt;修改 @edit user_20160301.md 的標題與內容, 例如, 將 @edit user_20160301.md 改為 @edit 學號_20160301.md, 且將 "Title: user - 使用者的範例網誌文章標題" 改為 "Title: 學號 - 使用者的範例網誌文章標題", "Author: user" 改為 "Author: 學號" 之後, 記得將已經修改過的 user_template.leo 存為 學號.leo 檔案.&lt;/li&gt;
&lt;li&gt;在學號.leo 專案檔案中, 將滑鼠停在 @button local pelican 節點上, 再點擊 local-pelican 按鈕進行轉檔, 最後利用瀏覽器開啟 project_site 目錄中的 index.html, 檢查是否在近端可以正確轉檔.&lt;/li&gt;
&lt;li&gt;若近端的 Pelican 網誌可以正確納入所新增的文章內容, 改將滑鼠停在 @button gh-pages pelican 節點上, 再點擊 gh-pages-pelican 按鈕, 進行 Github Pages 端所需要的內容轉檔.&lt;/li&gt;
&lt;li&gt;利用 git add -A, git commit -m "訊息", git push origin gh-pages 等3個步驟, 將 gh-pages 分支資料,  提交並推送到 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;網誌資料儲存規劃&lt;/h2&gt;
&lt;p&gt;一個靜態網站的內容除了文字檔案外, 還包括 Javascript 檔案, Brython 檔案, 圖檔, 影片檔案, 以及其他各種非 html 的文件檔, 為了保有本網誌專案倉儲的簡潔, 除了必要的設定與文字檔案外, 其他資料均存放在倉儲以外的相關資源位置, 其規劃如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Javascript 與 Brython 程式檔案, 除了儘量使用各 CDN 所提供的最新版本外, 目前以 &lt;a href="https://github.com/2015fallhw/cptocadp/tree/master/static"&gt;https://github.com/2015fallhw/cptocadp/tree/master/static&lt;/a&gt; 對應的 OpenShift 網站存放, 例如, Cango-8v03.js 位於 &lt;a href="http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js"&gt;http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一般圖檔與非 html 文件檔案, 建議以 Github Pages 的網頁架構儲存在獨立的倉儲中, 且該倉儲僅存放檔案, 而無文字檔案, 例如:
&lt;a href="http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png"&gt;http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png&lt;/a&gt; 即為其中的一個圖檔.&lt;/li&gt;
&lt;li&gt;影片檔案則分別存在 &lt;a href="https://vimeo.com/"&gt;https://vimeo.com/&lt;/a&gt; 與 &lt;a href="https://www.youtube.com/"&gt;https://www.youtube.com/&lt;/a&gt; (相同檔案各存一份).&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;圖檔引用&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png" width="600" /&gt;&lt;/p&gt;
&lt;h2&gt;影片檔引用&lt;/h2&gt;
&lt;iframe src="https://player.vimeo.com/video/147991541" width="600" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/147991541"&gt;Gocycle_disassemble&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;特別提醒&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;本網誌為了同時支援近端與遠端的資料內容使用, 資料轉檔分為近端按鈕與遠端按鈕, 協同成員在推送資料到遠端之前, 必須確定資料為遠端 Github Pages 格式.&lt;/li&gt;
&lt;li&gt;鼓勵各成員深入研究本網誌的細節架構, 勇於提出問題, 解決問題, 打造出最適合機械設計工程團隊使用的網際協同架構、模式與系統工具.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="教學導引"></category><category term="網誌設定"></category></entry><entry><title>user - 使用者的範例網誌文章標題</title><link href="http://project.mde.tw/blog/user-shi-yong-zhe-de-fan-li-wang-zhi-wen-zhang-biao-ti.html" rel="alternate"></link><updated>2016-07-01T12:10:06+08:00</updated><author><name>user</name></author><id>tag:project.mde.tw,2016-07-01:blog/user-shi-yong-zhe-de-fan-li-wang-zhi-wen-zhang-biao-ti.html</id><summary type="html">&lt;p&gt;這裡放入 user 所寫的文章摘要&lt;/p&gt;


&lt;p&gt;這裡為 user 所寫的文章主要內容&lt;/p&gt;</summary><category term="範例"></category></entry></feed>