<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016g1.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-07-09T13:21:44+08:00</updated><entry><title>40323143 - 日誌 105年7月6日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-6ri.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-ri-zhi-105nian-7yue-6ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將第二種極限開關新增到零件庫中，並在底座上依其尺寸新增了一個安裝位置，以及在懸盤上新增了一個用來安裝觸發極限開關突出物的安裝孔，和觸發極限開關的圓桿。&lt;/p&gt;
&lt;p&gt;今天還發現原本馬達和承臂的組合方式在實際使用上的問題，問題原因是原本的組合方式是想將馬達上原本就有的固定孔與承臂上的固定孔用螺絲或桿件等連接材將兩個元件結合，但因為孔徑的問題使中心的連接材找不到適合的東西使用，所以今天在承臂與馬達組裝的位置新增了配合實驗室馬達尺寸的凹槽，列印出來安裝測試效果很不錯，實際使用應該就是如此了。&lt;/p&gt;
&lt;p&gt;備註:&lt;/p&gt;
&lt;p&gt;1.原先想用滑環或是其他具相同用途的機構解決線路纏繞的問題，但這些要在這禮拜內完成有難度，所以目前決定在底座設置極限開關作極限點，還會看情況修改。&lt;/p&gt;
&lt;p&gt;2.馬達在Onshape上分為兩部分，在Onshape上分別是Part3和Part4，為了配合承臂上的組合點修改，馬達旋轉端( Part4 )的圖也修改為實際上馬達的外型。&lt;/p&gt;
&lt;p&gt;3.夾頭部分因為在這禮拜完成極限開關的安裝有很大的困難，經討論後決定暫時將這部分放置，等安裝測試完成後繼續。&lt;/p&gt;
&lt;p&gt;Oshape上的極限開關&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ScvGzdi.png"&gt;&lt;/p&gt;
&lt;p&gt;底座上極限開關裝置結果&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/B51Lwxj.png"&gt;&lt;/p&gt;
&lt;p&gt;安裝觸發極限開關突出物的安裝孔&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/G7J9Wh3.png"&gt;&lt;/p&gt;
&lt;p&gt;承臂與馬達組裝位置&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AZZyUBd.png"&gt;&lt;/p&gt;
&lt;p&gt;承臂與馬達組裝位置實際測試結果&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/eoxikJN.jpg"&gt;&lt;/p&gt;
&lt;p&gt;舊的承臂上安裝馬達極極限開關&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/603pE3d.jpg"&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 日誌 105年7月7日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-7ri.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-ri-zhi-105nian-7yue-7ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將兩個承臂與馬達和極限開關組裝固定 ，馬達固定是利用單心線的線芯穿過馬達與承臂上的固定孔鎖緊，因為昨天新增的凹槽可以承受馬達扭轉的力量，只需要讓他不會脫落即可。另外今天還發現固定設計在承臂上極限開關的固定桿強度不足，原因可能是因為列印的方向為桿件的徑向，導致桿在承受外力時列印接合面沒有足夠的強度支撐而產生破壞，解決方法是買5分的自攻螺釘將其鎖固。&lt;/p&gt;
&lt;p&gt;今天新增了一個新物件，目的是為了要使馬達可以有效的對懸盤輸出，與承臂上馬達安裝位置一樣。並且在旋盤底部新增了兩個直徑2.5的孔，其目的是為了配合今天新增的物件鎖固。&lt;/p&gt;
&lt;p&gt;今天將這旋盤以上除了夾頭外的東西組裝完，並由實物來預估線路的配置，線路配置目前的方案是將電線拉的比元件與電源的距離更長，讓電線在空中以圓弧狀放置，然後在底座上極限開關接點指向方向上將所有的線集中，然後拉到安裝在底座的arduino上。實際把線抓在安裝的預備位置轉動手臂測試時，目測在旋盤再碰觸到兩個極限開關的位置間旋轉應該是沒有問題，但今天沒有足夠的時間將底座印出來，沒有實際測試。&lt;/p&gt;
&lt;p&gt;備註:&lt;/p&gt;
&lt;p&gt;1.5分的自攻螺釘是在虎尾的大盤大買的。單心線的線芯是在工具箱拿的，固定大概用10公分。&lt;/p&gt;
&lt;p&gt;2.與極限開關相撞的桿子是用免洗筷剪短裝上去的，免洗筷是從系館後面的7-11跟店員要來的，十分堅固。&lt;/p&gt;
&lt;p&gt;3.目前的線路配置絕對不是個好方法，真的絕對不是個好方法。&lt;/p&gt;
&lt;p&gt;4.不直接在旋盤底面新增新特徵，而是新增新物件，原因是為了方便列印旋盤。&lt;/p&gt;
&lt;p&gt;斷裂的固定桿及其光滑的斷面&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lRDKIzp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;承臂與馬達固定&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4T1Z4rD.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/08grS9t.jpg"&gt;&lt;/p&gt;
&lt;p&gt;極限開關的鎖固&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LzJqB6t.jpg"&gt;&lt;/p&gt;
&lt;p&gt;觸發極限開關的桿子&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WkMM6Wg.jpg"&gt;&lt;/p&gt;
&lt;p&gt;底座上電線大概的集中位置&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u3uzFJ6.png"&gt;&lt;/p&gt;
&lt;p&gt;旋盤新增的孔&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oYsv4NR.png"&gt;&lt;/p&gt;
&lt;p&gt;新增的零件&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/YBxVUiq.png"&gt;&lt;/p&gt;
&lt;p&gt;提問:&lt;/p&gt;
&lt;p&gt;實際上在設計機構，機構上的電路配置有什麼重點需要注意?有沒有固定的配置方式?&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 3D printer 列印完下料後的倉儲機構設計理念及繪圖</title><link href="http://project.mde.tw/blog/40323143-3d-printer-lie-yin-wan-xia-liao-hou-de-cang-chu-ji-gou-she-ji-li-nian-ji-hui-tu.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-3d-printer-lie-yin-wan-xia-liao-hou-de-cang-chu-ji-gou-she-ji-li-nian-ji-hui-tu.html</id><summary type="html">&lt;p&gt;只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容&lt;/p&gt;


&lt;p&gt;這裡為 40323130 所寫的文章主要內容&lt;/p&gt;
&lt;p&gt;這是設計構想的全圖&lt;/p&gt;
&lt;p&gt;&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/asm0001.stl"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;我的想法是讓3D printer 在一個輸送帶上的平面列印，在輸送帶後方因為曲率不同使成品自然脫落，然後用一個盛盤接住成品一動到固定位置，使成盤傾斜讓成品掉落我們想要放置的位置。&lt;/p&gt;
&lt;p&gt;我使用一個由上而往看下呈一個工字型的機構，因為我認為這種機構機構簡單、組裝容易、運動路徑明確，控制上應該比較方便，可以節省很多製造、控制上的麻煩。&lt;/p&gt;
&lt;p&gt;動力方面想使用馬達接上摩擦輪驅動另外兩個摩擦輪，原本想用齒輪作為動力傳輸，但考慮到組原想要自己製造出來的想法，齒輪對我們來說製造難度太高，所以改用摩擦輪。&lt;/p&gt;
&lt;p&gt;組裝上也是盡量用簡單方便的方法組裝，例如摩擦輪就只是挖一個槽用重力固定，馬達安裝是用夾板鎖螺栓固定，其餘都是鎖螺栓夾緊，在組裝上應該不會有困難。&lt;/p&gt;
&lt;p&gt;零件圖:&lt;/p&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/1long.stl"&gt;&lt;/script&gt;

&lt;p&gt;&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/2long.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/3.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/3long.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/4-02.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/4-46.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/5.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/6.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/6-3.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/46-2.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/a.stl"&gt;&lt;/script&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/blog/theme/files/40323143/b.stl"&gt;&lt;/script&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 日誌 105年6月27日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-27ri.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-ri-zhi-105nian-6yue-27ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將個人Onshape上的機械手臂部分零件合進零件庫，設定六個參數，分別是motor_fixhole , motor_x , motor_y , motor_z , suan_pan , degore 六個參數，motor_fixhole為設定馬達固定孔大小，motor_x , motor_y , motor_z為設定馬達的長寬高， suan_pan為設定旋盤的大小，大小為motor_y的1.7倍，degore為設定底座的直徑，大小為3倍的suan_pan。&lt;/p&gt;
&lt;p&gt;合進零件庫的零件&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VoMTC8g.png"&gt;&lt;/p&gt;
&lt;p&gt;參數設定&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AsRWjtd.png"&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 日誌 105年6月28日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-28ri.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-ri-zhi-105nian-6yue-28ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將所有機械手臂零件全部合進零件庫，並用零件庫的零件再組合出一個組圖。今天沒有設定新的變數，未來將會新增有關手臂長度的零件參數，並由實際使用需求及感測器尺寸調整參數。&lt;/p&gt;
&lt;p&gt;備註:&lt;/p&gt;
&lt;p&gt;1.夾頭動力傳輸由原先畫的6齒圓齒輪改成25齒的正齒輪&lt;/p&gt;
&lt;p&gt;6/28零件庫&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wrPCKrc.png"&gt;&lt;/p&gt;
&lt;p&gt;組合圖&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GrrtDHo.png"&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 日誌 105年7月4日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-4ri.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-ri-zhi-105nian-7yue-4ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將Onshape平台上的因馬達尺寸測量錯誤導致機械手臂零件與馬達不能配合的錯誤修正，並增加馬達的外部特徵(電線接頭)及新增參數。以及因應手臂上馬達線路的配置改變設計，目前修改的有承臂末端新增一個槽及一個孔。還有嘗試一個夾頭的連桿構想，但是沒有成功。&lt;/p&gt;
&lt;p&gt;備註:&lt;/p&gt;
&lt;p&gt;1.馬達固定端的寬度由和馬達邊相等的20mm改成實際尺寸18mm，因應改變馬達固定孔中心距由原本的12mm變成10mm。&lt;/p&gt;
&lt;p&gt;2.新增arm_fixhole_diameter(承臂及馬達連接孔的孔徑)和arm_fixhole_disdance(承臂及馬達連接孔的中心距)兩個參數，arm_fixhole_diameter=1.5，arm_fixhole_disdance=21。&lt;/p&gt;
&lt;p&gt;3.承臂末端新增一個11*10的槽，以及一個直徑為6的孔。&lt;/p&gt;
&lt;p&gt;4.夾頭的連桿構想在Assembly 3裡，原先想將兩根從動桿分別裝在主動桿不同位置，利用其旋轉時不同的位移來帶動前方橫桿的作動，達成像握住般的夾持，結果兩側的夾持變得太少，所以沒有成功。&lt;/p&gt;
&lt;p&gt;馬達固定孔的尺寸修改&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Lx2ImtA.png"&gt;&lt;/p&gt;
&lt;p&gt;承臂與馬達連接孔尺寸修改&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Z69YQxk.png"&gt;&lt;/p&gt;
&lt;p&gt;夾頭構想圖&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/JdPYWaP.png"&gt;&lt;/p&gt;
&lt;p&gt;提問:&lt;/p&gt;
&lt;p&gt;請問有沒有機構能讓有連接線的物體作360度旋轉，卻不會讓線纏住的機構？  &lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 日誌 105年7月5日</title><link href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-5ri.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-ri-zhi-105nian-7yue-5ri.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;p&gt;今天將買了三種不同接觸點種類的極限開關，並將其中一種新增進入零件庫，且由其尺寸在承臂上新增其安裝位置，在Onshape上目測沒有和其他零件有接觸，承臂上的極限開關配置應該已經確定了，但夾頭座的極限開關配置找不到適合的位置，可能需要變更夾頭座的外型，或是在畫外接的零件，底座的極限開關配置還沒有畫出來，但應該會是在底座配置極限開關，在旋盤上設置接觸點觸發極限開關。&lt;/p&gt;
&lt;p&gt;備註:&lt;/p&gt;
&lt;p&gt;1.應祐生要求，將會在極限開關配置完成後利用3D列印印出一組非工作尺寸的手臂。&lt;/p&gt;
&lt;p&gt;2.Onshape上只有話接觸點最長的極限開關，實際使用時會依照實際狀況運用三種不同階典的極限開關。&lt;/p&gt;
&lt;p&gt;3.極限開關是在虎尾的國輝電子買的，三種接頭各三顆，原先想連滑環一起買，但沒有賣。&lt;/p&gt;
&lt;p&gt;4.想自己做滑環，但是怕會燒掉。&lt;/p&gt;
&lt;p&gt;極限開關的實體圖及量測尺寸&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SssLtym.jpg"&gt;&lt;/p&gt;
&lt;p&gt;承臂上極限開關裝置位置&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/0BTAGoI.png"&gt;&lt;/p&gt;
&lt;p&gt;極限開關&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uJ9mhD7.png"&gt;&lt;/p&gt;
&lt;p&gt;極限開關組合完-1&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/gykOTCW.png"&gt;&lt;/p&gt;
&lt;p&gt;極限開關組合完-2&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/te6PT6l.png"&gt;&lt;/p&gt;</summary><category term="範例"></category></entry><entry><title>40323143 - 說明如何參與協同機械設計專題網誌編寫</title><link href="http://project.mde.tw/blog/40323143-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323143</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323143-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html</id><summary type="html">&lt;p&gt;只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容&lt;/p&gt;


&lt;p&gt;這裡為 40323130 所寫的文章主要內容&lt;/p&gt;
&lt;p&gt;本機械設計專題網誌的架構包含近端與遠端的資料檢視設計, 專案資料以 Leo Editor 進行管理.&lt;/p&gt;
&lt;p&gt;以下教學影片示範從 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 機械設計專題網誌中取得倉儲的網址後, 可以利用 git clone 複製倉儲資料, 之後:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 git checkout gh-pages 將工作目錄指到 Github pages 的對應分支內容&lt;/li&gt;
&lt;li&gt;以 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案&lt;/li&gt;
&lt;li&gt;根據自己的帳號, 修改 .md 檔案存檔的名稱, 目的在透過加入帳號與時間註記, 避免 content 目錄中的檔案彼此複寫&lt;/li&gt;
&lt;li&gt;在 .md 的 Title 標題中, 冠上自己的帳號, 主要也是避免 Pelican 將 .md 根據標題轉成 html 時, 產生檔案複寫&lt;/li&gt;
&lt;li&gt;本系統的 Pelican 分為近端與遠端轉檔按鈕, 因此若要在近端檢查時, 與要推送到 Github 時採用不同轉檔按鈕&lt;/li&gt;
&lt;li&gt;為了簡化 git 指令的 add, commit 與 push, 加入 ungit, 只要啟動隨身系統候, 再利用 start_ungit.bat 開啟, 就可以在瀏覽器中簡化改版過程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vimeo:&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/157247703" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/157247703"&gt;2016project_1&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Youtube:&lt;/p&gt;
&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/hQR1wxALifU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="範例"></category></entry><entry><title>40323131日誌 105/06/30</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050630.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323131ri-zhi-1050630.html</id><summary type="html">&lt;p&gt;安裝wxpython 與 將control_3dprinter 從原本python2語法 修改成python3語法
&lt;/p&gt;
&lt;h3&gt;python2語法 修改成python3語法&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;原本圖片的紅框處為 except IOError, x:為python2語法，將它修改成能在python3上執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/yONrOlL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;原來python2 為Queue 將它修改成queue 因為python3裡頭更改成queue了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/sbLTZIj.png"&gt;
&lt;/br&gt;
&lt;h3&gt;還有要加上括號，因為python2上執行可以不需要括號起來，但是在python3上執行要加上小括號，目前找到這些語法問題
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;目前遇到的問題&lt;/h3&gt;

&lt;h4&gt;在下圖執行的時候跑出name 'reload' is not define &lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/FjZQHVW.png"&gt;
&lt;/br&gt;
&lt;h4&gt;上網google一下，找到了有可能是沒有reload到，所以多 import imp &lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/HhP42Gs.png"&gt;
&lt;/br&gt;
&lt;h4&gt;可是又遇到了下圖的問題，好像是python2默認的使用的是ascii，要將它更改成utf-8，不過看起來沒有成功&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/KZJt1YS.png"&gt;
&lt;/br&gt;
&lt;h4&gt;想要執行一下，來確認一下是否更改成功，不過不知道為什麼又跑出name 'reload' is not define&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/UmwpPJd.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;目前卡在這邊，無法想通為什麼會變成這樣&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323131日誌 105/07/01</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050701.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323131ri-zhi-1050701.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;python2語法 修改成python3語法&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;下圖框框處，原本的程式碼是 gettext.install(domain, './locale', unicode = 1)，我是將unicode = 1 拿掉&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/S4niXlw.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;底下的程式碼原本為imp.reload(sys) 
sys.setdefaultencoding('utf-8') ，在這裡我是將後面的sys.setdefaultencoding('utf-8') 拿掉，因為好像python3默認的編碼原本就是utf-8了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/g1UJkp7.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的問題&lt;/h3&gt;
&lt;h4&gt;下面的錯誤是說模組沒有被loaded，所以無法導入，不過我去找了一下它的目錄裡頭是有bufferedcanvas這個檔案的，所以就不清楚錯誤出在哪裡&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/K3srBRX.png"&gt;
&lt;/br&gt;
&lt;h4&gt;接著底下的這個問題大概是我卡最久的地方，self.bgcolor = wx.Colour()，錯誤是說Colour這個物件沒有歸類在SetFromName裡頭，我試了蠻多次，結果都差不多....&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/tgWDvca.png"&gt;
&lt;/br&gt;
&lt;h4&gt;於是我又進到wx套件裡頭去找有沒有Colour這個物件，是找到蠻多有Colour字母的檔案，不過我不清楚要import哪一個&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/k3SVgXL.png"&gt;
&lt;/br&gt;
&lt;h3&gt;由於自己對於python的物件導向沒什麼概念，class跟__init__這些都不是很熟，感覺整天修改下來根本沒改什麼東西，所以感覺蠻有挫折感的...，另外用python3裡頭內建的2to3.py檔下去修改python2轉成python3語法的錯誤，感覺方便許多，我用的指令是python y:\Python34\Tools\Scipts\2to3.py -w 要修改的py檔，y:\Python34\Tools\Scipts\2to3.py 這裡是給定2to3.py檔的位置給它，-w是write的意思，然後才是要修改的py檔案&lt;/h3&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323131日誌 105/07/03</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050703.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323131ri-zhi-1050703.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;學習python3 物件導向&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;稍微讀了一下老師提供的有關物件導向的資料，對於物件導向有個概念了，也有稍微做了一些筆記，放在資料夾裡頭，不過對於上次的問題，還是無法順利的解決，所以只好先跳過那一部分，先解決其他部分&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;下面幾張圖都是有關於上次遇到無法解決的那部分，於是我將那裏先行註解掉&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/tgsGvTv.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/K6zpDXO.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/wFkbnjQ.png"&gt;
&lt;/br&gt;
&lt;h3&gt;略過上述的那些問題，再將一些語法問題排除後，終於成功讓控制器介面跑出來了，不過跟原本的好像又差蠻多的，沒有圖片...，那部分可能還要花時間去了解，內部的一些按鈕的功能也不確定能不能使用，還有上述的那個問題，也要解決畢竟那是有關於顏色參數那方面的問題，所以非常重要，而且看指令列那邊，在執行的時候也還是出現蠻多錯誤的，而且又不知道問題出在哪裡了，所以還有好一大段路要走阿...&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/j4TRMp2.png"&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323131日誌 105/07/07</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050707.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323131ri-zhi-1050707.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;學習python&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;因為遇到了一些問題，所以打算從頭學起，希望可以真正了解問題點在哪裡，也希望可以幫到其他人&lt;/h3&gt;
&lt;h3&gt;先從最基本的名稱、物件、型別、指派&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;命名規則&lt;/h3&gt;
&lt;h4&gt;當我們要在程式裡取名時，必須遵守Python的規則 :&lt;/h4&gt;
&lt;h4&gt;1. 可使用英文字母小寫 a ~ z  大寫 A ~ Z  數字 0 ~ 9  底線 _ &lt;/h4&gt;
&lt;h4&gt;2. 第一個字不能是數字&lt;/h4&gt;
&lt;h4&gt;Python的名稱區分大小寫，所以money跟Money代表不同的名稱，不過有些識別字被Python拿去用了，稱為保留字(reserved word)或關鍵字(keyword)，代表特定的意思，有其特殊用途，不能拿來命名，下圖為Python保留字&lt;/h4&gt; 
&lt;/br&gt;
&lt;img src="http://i.imgur.com/8pnfigw.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;串列(list)&lt;/h3&gt;
&lt;h4&gt;除了整數(int)、浮點數(float)、字串(str)外;叫做串列(list)，此種型別可放入任何型別的物件。想建立串列物件時，語法是方括號[]，放入想含有的物件，範例&lt;/h4&gt;
&lt;img src="http://i.imgur.com/svqclfC.jpg"&gt;
&lt;img src="http://i.imgur.com/3ZmPgi5.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;當我們說串列內可存放物件時，是讓該串列能以索引的方是指向別的物件&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;可變與不可變&lt;/h3&gt;
&lt;h4&gt;型別int、float、str的物件，都有不可變(immutable)的特性，一旦建立之後，其值就無法更動;可以讓名稱轉而指向別的物件，但無法修改不可變物件&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/27GqNUf.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;別名&lt;/h3&gt;
&lt;h4&gt;因為Python有不可變(int,float,str)跟可變(list)物件之分，而且名稱跟物件其實是獨立的兩樣東西，所以要注意當兩個(或以上)的名稱都指向同一個物件時的狀況，別名(alias)也叫做共享參考(shared reference)&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/VuRhuyg.jpg"&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/tSDhZOi.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;tuple(元組)&lt;/h3&gt;
&lt;h4&gt;就是不可變的list(串列)，須使用小括號()放入想含有的物件&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;運算式&lt;/h3&gt;
&lt;h3&gt;算術運算子&lt;/h3&gt;
&lt;h4&gt;包括(+, -, &lt;em&gt;, /, %,  //, &lt;strong&gt; )，*是乘法，&lt;/strong&gt;是冪次方，/是除法，//是地板除法，%餘數運算子，來看例子&lt;/h4&gt;
&lt;img src="http://i.imgur.com/ShNje04.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;str字串跟list與tuple也可以使用 + , * 作運算&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/nlxgaxY.jpg"&gt;
&lt;img src="http://i.imgur.com/w4pospm.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;比較運算子&lt;/h3&gt;
&lt;h4&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, &amp;lt;&amp;gt;, == :作大小比較&lt;/h4&gt;
&lt;h4&gt;in, not in :檢查某元素是否在容器型物件裡頭&lt;/h4&gt;
&lt;h4&gt;is , is not :判斷兩個物件是否為同一個&lt;/h4&gt;
&lt;h4&gt;結果會產生bool(布林)型別的物件，True與False&lt;/h4&gt;
&lt;img src="http://i.imgur.com/aPADy6u.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;邏輯運算子&lt;/h3&gt;
&lt;h4&gt;and, or, not ，當and運算時，只有左右兩邊皆為True時，運算結果才會是True，其餘皆為False; or則只要有一個為True，得到的結果就是True，not則 是反轉真假值&lt;/h4&gt;
&lt;img src="http://i.imgur.com/tH1yLVL.jpg"&gt;
&lt;img src="http://i.imgur.com/hHQKeGD.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;一般的數值運算子，如(+, &lt;/em&gt;, /)等等，其優先順序都高於比較運算子，如(&amp;lt;=, !=, is not)等&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;述句&lt;/h3&gt;
&lt;h4&gt;是Python程式裡最小最基本的執行單位，每種數據都有其獨特的語法和語意，不符合述句語法的話，就是不合法的程式碼，就不能被直譯器執行&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;指派述句&lt;/h3&gt;
&lt;img src="http://i.imgur.com/dCoijfP.jpg"&gt;
&lt;img src="http://i.imgur.com/xfroPdq.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;多重指派&lt;/h3&gt;
&lt;img src="http://i.imgur.com/YJO9WE2.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;序列指派&lt;/h3&gt;
&lt;img src="http://i.imgur.com/ESozV9L.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;增強型指派述句&lt;/h3&gt;
&lt;img src="http://i.imgur.com/fSedP2d.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;if 條件判斷述句&lt;/h3&gt;
&lt;h4&gt;if述句可根據運算式結果(True或False)，作為條件來判斷應該執行哪部分的程式碼，控制走向，稱此類的述句為程式流程控制，if, elif, else那一行的最後面要加上冒號(:)，表是後面將接著一組程式述句，而裡頭的述句必須縮排。&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/IVb2SZB.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;Python因使用縮排來標示程式碼的層級，不同於C / C++ / Java / C# / JavaScript 以大括號{}來包住程式碼的方式&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;pass述句&lt;/h3&gt;
&lt;h4&gt;pass述句什麼也不做，因為根據Python語法，有時須放進述句，但不需要或不知道該寫什麼，就放pass述句，這樣便可符合語法，否則將發生錯誤&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;while迴圈述句&lt;/h3&gt;
&lt;img src="http://i.imgur.com/4NKE1mQ.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;for迴圈述句&lt;/h3&gt;
&lt;img src="http://i.imgur.com/4s0y3Mt.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;break述句與continue述句&lt;/h3&gt;
&lt;img src="http://i.imgur.com/Ig9WH6U.jpg"&gt;
&lt;img src="http://i.imgur.com/UyA58Gp.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;述句總覽表&lt;/h3&gt;
&lt;img src="http://i.imgur.com/8ob7Wit.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;函式&lt;/h3&gt;
&lt;h4&gt;定義函式的語法 def 函式名稱 (參數0, 參數1, ......):&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/bDVrgav.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;參數&lt;/h3&gt;
&lt;h4&gt;呼叫函式時可傳入參數，這個動作跟指派幾乎一模一樣，所謂傳入參數，也就是說呼叫方把某物件指派給參數的名稱，要小心的是，如果參數是可變物件，那麼函式拿到該參數後，也可以改變該物件&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;return述句&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/vXfp3sU.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;可視範圍(scope)&lt;/h3&gt;
&lt;h4&gt;名稱的可視範圍，決定了在程式的什麼地方能夠看到該名稱，進而存取該名稱指向的物件，在尚未定義函式的程式範圍裡，所有名稱通通都擁有[全域(global)]可視範圍，這些名稱定義在程式最高最外圍的地方，如下圖 a ,b, foo, x, y ，一旦定義後，就能存取名稱指向的物件，簡稱為(全域名稱);而定義在函式範圍裡的名稱(包括參數)，如下圖的n, m，只擁有[區域(local)]可視範圍，只有在該函式內才看得到這些名稱，簡稱(區域名稱)。&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/BWbCR4f.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;在函式(區域)裡，雖可以自由取用全域名稱，但只能讀 不能寫，該如何把新物件指派給全域名稱呢?一但在函式裡把全域名稱放在指派述句的左邊，會產生區域名稱，而不是把新物件指派給全域名稱。辦法是使用(global述句)，便可在函式內重新指派全域名稱到新物件&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/qA7lmCu.jpg"&gt;
&lt;/br&gt;
&lt;h3&gt;內建函式&lt;/h3&gt;
&lt;h4&gt;跟算術相關的內建函式&lt;/h4&gt;
&lt;h4&gt;求總合函式sum(), 求串列長度len()&lt;/h4&gt;
&lt;h4&gt; range()是建立出(能提供一連串東西的物件)，可用在for迴圈&lt;/h4&gt;
&lt;h4&gt;abs()絕對值, pow()冪次方，等同於**運算子, round()四捨五入到小數點後第二位, divmod()商和餘數&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/qchnuOI.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;跟邏輯相關的內建函式&lt;/h4&gt;
&lt;h4&gt;all(), any()&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/RJB7lZx.jpg"&gt;
&lt;/br&gt;
&lt;h4&gt;有些可得知關於物件的資訊&lt;/h4&gt;
&lt;h4&gt;id(), type()物件的型別, callable()是不是可被呼叫&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/rmbQIDR.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323131日誌 105/06/28</title><link href="http://project.mde.tw/blog/40323131ri-zhi-1050628.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323131</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323131ri-zhi-1050628.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;研讀Octopi的設定檔&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;設定檔位置位在  /Octoprint/src/octoprint/setting.py&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/YJvnK0t.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定檔位置位在  /Octoprint/src/octoprint/static/less/octoprint.less&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/OfsVzCx.png"&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;目前遇到的問題&lt;/h3&gt;

&lt;h4&gt;host位置顯示在0.0.0.0:5000  可是網頁開起來無法顯示&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/9sqNCk1.png"&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>PySerial 問題</title><link href="http://project.mde.tw/blog/pyserial-wen-ti.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/pyserial-wen-ti.html</id><summary type="html">&lt;p&gt;今日讀的進度，以及筆記&lt;/p&gt;


&lt;h2&gt;發現到的問題&lt;/h2&gt;

&lt;p&gt;主要是安裝wxpython phoenix 和他原本使用的wxpython不一樣，因此需要更改一些兩者的不同，但是在wxTerminal的部分可以跑出gui介面，但是再傳收值得部分，有些許問題，來自於wxpython和wxpython phoenix 的部分他們不互相支援，可能是他們還有些問題&lt;/p&gt;
&lt;p&gt;主要出問題的部分是來自於line 349&lt;/p&gt;
&lt;p&gt;git clone :https://github.com/pyserial/pyserial  在example裡面的wxTerminal.py啟動收值部分有些許問題&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uIMc1rm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src= "http://i.imgur.com/xMa2cwn.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pFmSRlE.png"&gt;&lt;/p&gt;
&lt;h3&gt;底下為我寫的測試的程式&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

import serial

with serial.Serial() as ser:
    ser.baudrate = 9600
    ser.port = 'COM6'
    ser.open()
    print(ser.name)
#    ser.write(b'hello')
    while(1):
# transform data

        #ser.write(b"hello")


        x = ser.read().decode

        print(x)
&lt;/pre&gt;

&lt;h3&gt;實際測試部分&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/uIMc1rm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aEOnq9R.png"&gt;&lt;/p&gt;
&lt;h3&gt;最後補上  認真==鑽牛角尖的第二組  量螺絲&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/UlaIizY.jpg"&gt;&lt;/p&gt;</summary><category term="wxpython"></category></entry><entry><title>PySerial 問題0703</title><link href="http://project.mde.tw/blog/pyserial-wen-ti-0703.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/pyserial-wen-ti-0703.html</id><summary type="html">&lt;p&gt;今日讀的進度，以及筆記&lt;/p&gt;


&lt;h3&gt;改成執行緒的方式收值&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

import serial
from threading import *
import sys
import time

def handleClient():

    while(True):
        print("waiting for client")
        time.sleep(3)
#with serial.Serial('COM6',9600,timeout = 1) as ser:

def recevive():


    my_list = [12]
 #   CRLF[10]="\r\n"
    with serial.Serial() as ser:
        ser.baudrate = 9600
        ser.port = 'COM6'
        ser.open()
        #print(ser.name)
        while(True):

            text = ser.read().decode('utf-8')

            text = text.replace('\r','\n')
            my_list = text

            #想要整理成矩陣 目前無頭緒
            print (my_list,end ='')
            if my_list[0] =="S":
                print("perfect")
            else:
                print("failed")
            time.sleep(0.1)

if __name__ == "__main__":

    t = Timer(3.0,handleClient)
    s = Timer(3.0,recevive)
    s.start()

&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/9MkMv7u.png"&gt;&lt;/p&gt;
&lt;p&gt;有關執行緒的部分有多種方式可以使用，上面只是其中一個，還有別種方法是利用class的方法，不過在python3中用的方法都比較嚴謹，沒辦法隨意使用，以及他使用的語法和C其實差蠻多的，有可能後面做法做看看，利用python控制C的程式，說不定會簡單一點，但是不一定，也要實作才知道，最主要python2和python3的差別來自於他們對於編碼的方式不同，而且相對於他們使用的嚴謹，for example (encode . decode)部分的可能要需要再研讀一陣子。&lt;/p&gt;</summary><category term="python串列傳輸實作"></category></entry><entry><title>PySerial進度</title><link href="http://project.mde.tw/blog/pyserialjin-du.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/pyserialjin-du.html</id><summary type="html">&lt;p&gt;今日讀的進度，以及筆記&lt;/p&gt;


&lt;h3&gt;三個要件&lt;/h3&gt;

&lt;p&gt;1.pyserial&lt;/p&gt;
&lt;p&gt;2.wxpython with Phoenix&lt;/p&gt;
&lt;p&gt;3.python3以上的版本&lt;/p&gt;
&lt;h3&gt;2.7版的wxxpython和phoenix wxpython api比較&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://wxpython.org/Phoenix/docs/html/classic_vs_phoenix.html#classic-vs-phoenix"&gt;網站連結&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PySerial documation about io control&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://pyserial.readthedocs.io/en/latest/shortintro.html"&gt;網站連結&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Wxxpython API Module&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://wxpython.org/Phoenix/docs/html/main.html"&gt;網站連結&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Wxxpython GUI Bulider wxGlade&lt;/h3&gt;

&lt;p&gt;今日寫程式遇到的問題點&lt;/p&gt;
&lt;p&gt;1.在wxTeriminal中遇到問題來自於他沒辦法顯示我傳給他的值&lt;/p&gt;
&lt;p&gt;2.以及他的pyserial中，需要詳細測試他所收到以及送的值的格式&lt;/p&gt;
&lt;p&gt;3.才能自己寫一套for python3 Gui的程式控制&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GUqnneU.jpg"&gt;&lt;/p&gt;
&lt;p&gt;要能成功執行下方的程式必須要安裝&lt;/p&gt;
&lt;p&gt;1.python 3.4+&lt;/p&gt;
&lt;p&gt;2.wxPython Phoenix&lt;/p&gt;
&lt;p&gt;3.pyserial&lt;/p&gt;
&lt;h3&gt;關於程式碼有更改後的&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

#file name wxSerialConfigDialog.py

import wx
import serial
import serial.tools.list_ports

SHOW_BAUDRATE = 1 &lt;&lt; 0
SHOW_FORMAT = 1 &lt;&lt; 1
SHOW_FLOW = 1 &lt;&lt; 2
SHOW_TIMEOUT = 1 &lt;&lt; 3
SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT


class SerialConfigDialog(wx.Dialog):
    """\
    Serial Port configuration dialog, to be used with pySerial 2.0+
    When instantiating a class of this dialog, then the "serial" keyword
    argument is mandatory. It is a reference to a serial.Serial instance.
    the optional "show" keyword argument can be used to show/hide different
    settings. The default is SHOW_ALL which corresponds to
    SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be
    found in this module (not the class).
    """

    def __init__(self, *args, **kwds):
        # grab the serial keyword and remove it from the dict
        self.serial = kwds['serial']
        del kwds['serial']
        self.show = SHOW_ALL
        if 'show' in kwds:
            self.show = kwds.pop('show')
        # begin wxGlade: SerialConfigDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_2 = wx.StaticText(self, -1, "Port")
        self.choice_port = wx.Choice(self, -1, choices=[])
        self.label_1 = wx.StaticText(self, -1, "Baudrate")
        self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN)
        self.sizer_1_staticbox = wx.StaticBox(self, -1, "Basics")
        self.panel_format = wx.Panel(self, -1)
        self.label_3 = wx.StaticText(self.panel_format, -1, "Data Bits")
        self.choice_databits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_4 = wx.StaticText(self.panel_format, -1, "Stop Bits")
        self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_5 = wx.StaticText(self.panel_format, -1, "Parity")
        self.choice_parity = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, "Data Format")
        self.panel_timeout = wx.Panel(self, -1)
        self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, "Use Timeout")
        self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, "")
        self.label_6 = wx.StaticText(self.panel_timeout, -1, "seconds")
        self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, "Timeout")
        self.panel_flow = wx.Panel(self, -1)
        self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, "RTS/CTS")
        self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, "Xon/Xoff")
        self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, "Flow Control")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        # attach the event handlers
        self.__attach_events()

    def __set_properties(self):
        # begin wxGlade: SerialConfigDialog.__set_properties
        self.SetTitle("Serial Port Configuration")
        self.choice_databits.SetSelection(0)
        self.choice_stopbits.SetSelection(0)
        self.choice_parity.SetSelection(0)
        self.text_ctrl_timeout.Enable(False)
        self.button_ok.SetDefault()
        # end wxGlade
        self.SetTitle("Serial Port Configuration")
        if self.show &amp; SHOW_TIMEOUT:
            self.text_ctrl_timeout.Enable(0)
        self.button_ok.SetDefault()

        if not self.show &amp; SHOW_BAUDRATE:
            self.label_1.Hide()
            self.combo_box_baudrate.Hide()
        if not self.show &amp; SHOW_FORMAT:
            self.panel_format.Hide()
        if not self.show &amp; SHOW_TIMEOUT:
            self.panel_timeout.Hide()
        if not self.show &amp; SHOW_FLOW:
            self.panel_flow.Hide()

        # fill in ports and select current setting
        preferred_index = 0
        self.choice_port.Clear()
        self.ports = []
        for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())):
            self.choice_port.Append('{} - {}'.format(portname, desc))
            self.ports.append(portname)
            if self.serial.name == portname:
                preferred_index = n
        self.choice_port.SetSelection(preferred_index)
        if self.show &amp; SHOW_BAUDRATE:
            preferred_index = None
            # fill in baud rates and select current setting
            self.combo_box_baudrate.Clear()
            for n, baudrate in enumerate(self.serial.BAUDRATES):
                self.combo_box_baudrate.Append(str(baudrate))
                if self.serial.baudrate == baudrate:
                    preferred_index = n
            if preferred_index is not None:
                self.combo_box_baudrate.SetSelection(preferred_index)
            else:
                self.combo_box_baudrate.SetValue('{}'.format(self.serial.baudrate))
        if self.show &amp; SHOW_FORMAT:
            # fill in data bits and select current setting
            self.choice_databits.Clear()
            for n, bytesize in enumerate(self.serial.BYTESIZES):
                self.choice_databits.Append(str(bytesize))
                if self.serial.bytesize == bytesize:
                    index = n
            self.choice_databits.SetSelection(index)
            # fill in stop bits and select current setting
            self.choice_stopbits.Clear()
            for n, stopbits in enumerate(self.serial.STOPBITS):
                self.choice_stopbits.Append(str(stopbits))
                if self.serial.stopbits == stopbits:
                    index = n
            self.choice_stopbits.SetSelection(index)
            # fill in parities and select current setting
            self.choice_parity.Clear()
            for n, parity in enumerate(self.serial.PARITIES):
                self.choice_parity.Append(str(serial.PARITY_NAMES[parity]))
                if self.serial.parity == parity:
                    index = n
            self.choice_parity.SetSelection(index)
        if self.show &amp; SHOW_TIMEOUT:
            # set the timeout mode and value
            if self.serial.timeout is None:
                self.checkbox_timeout.SetValue(False)
                self.text_ctrl_timeout.Enable(False)
            else:
                self.checkbox_timeout.SetValue(True)
                self.text_ctrl_timeout.Enable(True)
                self.text_ctrl_timeout.SetValue(str(self.serial.timeout))
        if self.show &amp; SHOW_FLOW:
            # set the rtscts mode
            self.checkbox_rtscts.SetValue(self.serial.rtscts)
            # set the rtscts mode
            self.checkbox_xonxoff.SetValue(self.serial.xonxoff)

    def __do_layout(self):
        # begin wxGlade: SerialConfigDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_flow_staticbox.Lower()
        sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL)
        self.sizer_timeout_staticbox.Lower()
        sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL)
        self.sizer_format_staticbox.Lower()
        sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL)
        grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0)
        self.sizer_1_staticbox.Lower()
        sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL)
        sizer_basics = wx.FlexGridSizer(3, 2, 0, 0)
        sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0)
        sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0)
        sizer_basics.AddGrowableCol(1)
        sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0)
        sizer_2.Add(sizer_1, 0, wx.EXPAND, 0)
        grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        self.panel_format.SetSizer(sizer_format)
        sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0)
        sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0)
        sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        self.panel_timeout.SetSizer(sizer_timeout)
        sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0)
        sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add((10, 10), 1, wx.EXPAND, 0)
        self.panel_flow.SetSizer(sizer_flow)
        sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK)
        wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel)
        if self.show &amp; SHOW_TIMEOUT:
            wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout)

    def OnOK(self, events):
        success = True
        self.serial.port = self.ports[self.choice_port.GetSelection()]
        if self.show &amp; SHOW_BAUDRATE:
            try:
                b = int(self.combo_box_baudrate.GetValue())
            except ValueError:
                with wx.MessageDialog(
                        self,
                        'Baudrate must be a numeric value',
                        'Value Error',
                        wx.OK | wx.ICON_ERROR) as dlg:
                    dlg.ShowModal()
                success = False
            else:
                self.serial.baudrate = b
        if self.show &amp; SHOW_FORMAT:
            self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()]
            self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()]
            self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()]
        if self.show &amp; SHOW_FLOW:
            self.serial.rtscts = self.checkbox_rtscts.GetValue()
            self.serial.xonxoff = self.checkbox_xonxoff.GetValue()
        if self.show &amp; SHOW_TIMEOUT:
            if self.checkbox_timeout.GetValue():
                try:
                    self.serial.timeout = float(self.text_ctrl_timeout.GetValue())
                except ValueError:
                    with wx.MessageDialog(
                            self,
                            'Timeout must be a numeric value',
                            'Value Error',
                            wx.OK | wx.ICON_ERROR) as dlg:
                        dlg.ShowModal()
                    success = False
            else:
                self.serial.timeout = None
        if success:
            self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        self.EndModal(wx.ID_CANCEL)

    def OnTimeout(self, events):
        if self.checkbox_timeout.GetValue():
            self.text_ctrl_timeout.Enable(True)
        else:
            self.text_ctrl_timeout.Enable(False)

# end of class SerialConfigDialog


class MyApp(wx.App):
    """Test code"""
    def OnInit(self):
        wx.InitAllImageHandlers()

        ser = serial.Serial()
        print(ser)
        # loop until cancel is pressed, old values are used as start for the next run
        # show the different views, one after the other
        # value are kept.
        for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL):
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser, show=flags)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        # the user can play around with the values, CANCEL aborts the loop
        while True:
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        return 0

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;

&lt;h3&gt;主程式部分&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

#file name wxTerminal.py

import codecs
import serial
import threading
import wx
import wxSerialConfigDialog

# ----------------------------------------------------------------------
# Create an own event type, so that GUI updates can be delegated
# this is required as on some platforms only the main thread can
# access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave
# could be used too, but an event is more elegant.

SERIALRX = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0)


class SerialRxEvent(wx.PyCommandEvent):
    eventType = SERIALRX

    def __init__(self, windowID, data):
        wx.PyCommandEvent.__init__(self, self.eventType, windowID)
        self.data = data

    def Clone(self):
        self.__class__(self.GetId(), self.data)

# ----------------------------------------------------------------------

ID_CLEAR = wx.NewId()
ID_SAVEAS = wx.NewId()
ID_SETTINGS = wx.NewId()
ID_TERM = wx.NewId()
ID_EXIT = wx.NewId()
ID_RTS = wx.NewId()
ID_DTR = wx.NewId()

NEWLINE_CR = 0
NEWLINE_LF = 1
NEWLINE_CRLF = 2


class TerminalSetup:
    """
    Placeholder for various terminal settings. Used to pass the
    options to the TerminalSettingsDialog.
    """
    def __init__(self):
        self.echo = False
        self.unprintable = False
        self.newline = NEWLINE_CRLF


class TerminalSettingsDialog(wx.Dialog):
    """Simple dialog with common terminal settings like echo, newline mode."""

    def __init__(self, *args, **kwds):
        self.settings = kwds['settings']
        del kwds['settings']
        # begin wxGlade: TerminalSettingsDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.checkbox_echo = wx.CheckBox(self, -1, "Local Echo")
        self.checkbox_unprintable = wx.CheckBox(self, -1, "Show unprintable characters")
        self.radio_box_newline = wx.RadioBox(self, -1, "Newline Handling", choices=["CR only", "LF only", "CR+LF"], majorDimension=0, style=wx.RA_SPECIFY_ROWS)
        self.sizer_4_staticbox = wx.StaticBox(self, -1, "Input/Output")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.__attach_events()
        self.checkbox_echo.SetValue(self.settings.echo)
        self.checkbox_unprintable.SetValue(self.settings.unprintable)
        self.radio_box_newline.SetSelection(self.settings.newline)

    def __set_properties(self):
        # begin wxGlade: TerminalSettingsDialog.__set_properties
        self.SetTitle("Terminal Settings")
        self.radio_box_newline.SetSelection(0)
        self.button_ok.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalSettingsDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_4_staticbox.Lower()
        sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL)
        sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4)
        sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4)
        sizer_4.Add(self.radio_box_newline, 0, 0, 0)
        sizer_2.Add(sizer_4, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId())

    def OnOK(self, events):
        """Update data wil new values and close dialog."""
        self.settings.echo = self.checkbox_echo.GetValue()
        self.settings.unprintable = self.checkbox_unprintable.GetValue()
        self.settings.newline = self.radio_box_newline.GetSelection()
        self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        """Do not update data but close dialog."""
        self.EndModal(wx.ID_CANCEL)

# end of class TerminalSettingsDialog


class TerminalFrame(wx.Frame):
    """Simple terminal program for wxPython"""

    def __init__(self, *args, **kwds):
        self.serial = serial.Serial()
        self.serial.timeout = 0.5   # make sure that the alive event can be checked from time to time
        self.settings = TerminalSetup()  # placeholder for the settings
        self.thread = None
        self.alive = threading.Event()
        # begin wxGlade: TerminalFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        # Menu Bar
        self.frame_terminal_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_CLEAR, "&amp;Clear", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(ID_SAVEAS, "&amp;Save Text As...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_TERM, "&amp;Terminal Settings...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_EXIT, "&amp;Exit", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "&amp;File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_RTS, "RTS", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_DTR, "&amp;DTR", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_SETTINGS, "&amp;Port Settings...", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "Serial Port")
        self.SetMenuBar(self.frame_terminal_menubar)
        # Menu Bar end
        self.text_ctrl_output = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE | wx.TE_READONLY)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS)
        self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        # end wxGlade
        self.__attach_events()          # register events
        self.OnPortSettings(None)       # call setup dialog on startup, opens port
        if not self.alive.isSet():
            self.Close()

    def StartThread(self):
        """Start the receiver thread"""
        self.thread = threading.Thread(target=self.ComPortThread)
        self.thread.setDaemon(1)
        self.alive.set()
        self.thread.start()
        self.serial.rts = True
        self.serial.dtr = True
        self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts)
        self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr)

    def StopThread(self):
        """Stop the receiver thread, wait until it's finished."""
        if self.thread is not None:
            self.alive.clear()          # clear alive event for thread
            self.thread.join()          # wait until thread has finished
            self.thread = None

    def __set_properties(self):
        # begin wxGlade: TerminalFrame.__set_properties
        self.SetTitle("Serial Terminal")
        self.SetSize((546, 383))
        self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, ""))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        # register events at the controls
        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey)
        self.Bind(EVT_SERIALRX, self.OnSerialRead)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnExit(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Menu point Exit"""
        self.Close()

    def OnClose(self, event):
        """Called on application shutdown."""
        self.StopThread()               # stop reader thread
        self.serial.close()             # cleanup
        self.Destroy()                  # close windows, exit app

    def OnSaveAs(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Save contents of output window."""
        with wx.FileDialog(
                None,
                "Save Text As...",
                ".",
                "",
                "Text File|*.txt|All Files|*",
                wx.SAVE) as dlg:
            if dlg.ShowModal() == wx.ID_OK:
                filename = dlg.GetPath()
                with codecs.open(filename, 'w', encoding='utf-8') as f:
                    text = self.text_ctrl_output.GetValue().encode("utf-8")
                    f.write(text)

    def OnClear(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Clear contents of output window."""
        self.text_ctrl_output.Clear()

    def OnPortSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """
        Show the port settings dialog. The reader thread is stopped for the
        settings change.
        """
        if event is not None:           # will be none when called on startup
            self.StopThread()
            self.serial.close()
        ok = False
        while not ok:
            with wxSerialConfigDialog.SerialConfigDialog(
                    self,
                    -1,
                    "",
                    show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW,
                    serial=self.serial) as dialog_serial_cfg:
                dialog_serial_cfg.CenterOnParent()
                result = dialog_serial_cfg.ShowModal()
            # open port if not called on startup, open it on startup and OK too
            if result == wx.ID_OK or event is not None:
                try:
                    self.serial.open()
                except serial.SerialException as e:
                    with wx.MessageDialog(self, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)as dlg:
                        dlg.ShowModal()
                else:
                    self.StartThread()
                    self.SetTitle("Serial Terminal on {} [{},{},{},{}{}{}]".format(
                        self.serial.portstr,
                        self.serial.baudrate,
                        self.serial.bytesize,
                        self.serial.parity,
                        self.serial.stopbits,
                        ' RTS/CTS' if self.serial.rtscts else '',
                        ' Xon/Xoff' if self.serial.xonxoff else '',
                        ))
                    ok = True
            else:
                # on startup, dialog aborted
                self.alive.clear()
                ok = True

    def OnTermSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """\
        Menu point Terminal Settings. Show the settings dialog
        with the current terminal settings.
        """
        with TerminalSettingsDialog(self, -1, "", settings=self.settings) as dialog:
            dialog.CenterOnParent()
            dialog.ShowModal()

    def OnKey(self, event):
        """\
        Key event handler. If the key is in the ASCII range, write it to the
        serial port. Newline handling and local echo is also done here.
        """
        code = event.GetUnicodeKey()
        if code &lt; 256:   # XXX bug in some versions of wx returning only capital letters
            code = event.GetKeyCode()
        if code == 13:                      # is it a newline? (check for CR which is the RETURN key)
            if self.settings.echo:          # do echo if needed
                self.text_ctrl_output.AppendText('\n')
            if self.settings.newline == NEWLINE_CR:
                self.serial.write(b'\r')     # send CR
            elif self.settings.newline == NEWLINE_LF:
                self.serial.write(b'\n')     # send LF
            elif self.settings.newline == NEWLINE_CRLF:
                self.serial.write(b'\r\n')   # send CR+LF
        else:
            char = chr(code)
            if self.settings.echo:          # do echo if needed
                self.WriteText(char)
            self.serial.write(char.encode('UTF-8', 'replace'))         # send the character

    def WriteText(self, text):
        if self.settings.unprintable:
            text = ''.join([c if (c &gt;= ' ' and c != '\x7f') else chr(0x2400 + ord(c)) for c in text])
        self.text_ctrl_output.AppendText(text)

    def OnSerialRead(self, event):
        """Handle input from the serial port."""
        self.WriteText(event.data.decode('UTF-8', 'replace'))

    def ComPortThread(self):
        """\
        Thread that handles the incoming traffic. Does the basic input
        transformation (newlines) and generates an SerialRxEvent
        """
        while self.alive.isSet():
            b = self.serial.read(self.serial.in_waiting or 1)
            if b:
                # newline transformation
                if self.settings.newline == NEWLINE_CR:
                    b = b.replace(b'\r', b'\n')
                elif self.settings.newline == NEWLINE_LF:
                    pass
                elif self.settings.newline == NEWLINE_CRLF:
                    b = b.replace(b'\r\n', b'\n')
                event = SerialRxEvent(self.GetId(), b)
                self.GetEventHandler().AddPendingEvent(event)

    def OnRTS(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.rts = event.IsChecked()

    def OnDTR(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.dtr = event.Checked()

# end of class TerminalFrame


class MyApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_terminal = TerminalFrame(None, -1, "")
        self.SetTopWindow(frame_terminal)
        frame_terminal.Show(True)
        return 1

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;</summary><category term="wxpython"></category></entry><entry><title>Octopi測試與實作</title><link href="http://project.mde.tw/blog/octopice-shi-yu-shi-zuo.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/octopice-shi-yu-shi-zuo.html</id><summary type="html">&lt;p&gt;設定使用octopi與實作&lt;/p&gt;


&lt;p&gt;octopi走乙太網路線進行控制以及連線&lt;/p&gt;
&lt;p&gt;實際測試的照片以及需要用到的方法&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Umf1J3w.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zMUAcXs.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Sqh1bWP.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PzFmXoH.jpg"&gt;&lt;/p&gt;</summary><category term="Octopi"></category></entry><entry><title>PySerial</title><link href="http://project.mde.tw/blog/pyserial.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/pyserial.html</id><summary type="html">&lt;p&gt;更新資料Wxpython for python3&lt;/p&gt;


&lt;p&gt;安裝方法
https://www.youtube.com/watch?v=_djD5EHfNCw&lt;/p&gt;
&lt;pre class="brush: python"&gt;

#先檢查網路
#確定python版本為python3.4

pip install -U --trusted-host wxpython.org --pre -f https://wxpython.org/Phoenix/snapshot-builds/ wxPython_Phoenix

#記得打開terimal 檢查import wx
#看有沒有成功

#因為要做串列傳輸Serial
#要下指令安裝pyserial
pip install pyserial


&lt;/pre&gt;

&lt;h3&gt;接下來先用範例程式測試串列傳輸&lt;/h3&gt;

&lt;p&gt;&lt;html&gt;https://github.com/pyserial/pyserial/tree/master/examples&lt;/html&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;

#
#!/usr/bin/env python
#
# A simple terminal application with wxPython.
#
# (C) 2001-2015 Chris Liechti &lt;cliechti@gmx.net&gt;
#
# SPDX-License-Identifier:    BSD-3-Clause

import codecs
import serial
import threading
import wx
import wxSerialConfigDialog


SERIALRX = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0)


class SerialRxEvent(wx.PyCommandEvent):
    eventType = SERIALRX

    def __init__(self, windowID, data):
        wx.PyCommandEvent.__init__(self, self.eventType, windowID)
        self.data = data

    def Clone(self):
        self.__class__(self.GetId(), self.data)

# ----------------------------------------------------------------------

ID_CLEAR = wx.NewId()
ID_SAVEAS = wx.NewId()
ID_SETTINGS = wx.NewId()
ID_TERM = wx.NewId()
ID_EXIT = wx.NewId()
ID_RTS = wx.NewId()
ID_DTR = wx.NewId()

NEWLINE_CR = 0
NEWLINE_LF = 1
NEWLINE_CRLF = 2


class TerminalSetup:
    """
    Placeholder for various terminal settings. Used to pass the
    options to the TerminalSettingsDialog.
    """
    def __init__(self):
        self.echo = False
        self.unprintable = False
        self.newline = NEWLINE_CRLF


class TerminalSettingsDialog(wx.Dialog):
    """Simple dialog with common terminal settings like echo, newline mode."""

    def __init__(self, *args, **kwds):
        self.settings = kwds['settings']
        del kwds['settings']
        # begin wxGlade: TerminalSettingsDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.checkbox_echo = wx.CheckBox(self, -1, "Local Echo")
        self.checkbox_unprintable = wx.CheckBox(self, -1, "Show unprintable characters")
        self.radio_box_newline = wx.RadioBox(self, -1, "Newline Handling", choices=["CR only", "LF only", "CR+LF"], majorDimension=0, style=wx.RA_SPECIFY_ROWS)
        self.sizer_4_staticbox = wx.StaticBox(self, -1, "Input/Output")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.__attach_events()
        self.checkbox_echo.SetValue(self.settings.echo)
        self.checkbox_unprintable.SetValue(self.settings.unprintable)
        self.radio_box_newline.SetSelection(self.settings.newline)

    def __set_properties(self):
        # begin wxGlade: TerminalSettingsDialog.__set_properties
        self.SetTitle("Terminal Settings")
        self.radio_box_newline.SetSelection(0)
        self.button_ok.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalSettingsDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_4_staticbox.Lower()
        sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL)
        sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4)
        sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4)
        sizer_4.Add(self.radio_box_newline, 0, 0, 0)
        sizer_2.Add(sizer_4, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId())

    def OnOK(self, events):
        """Update data wil new values and close dialog."""
        self.settings.echo = self.checkbox_echo.GetValue()
        self.settings.unprintable = self.checkbox_unprintable.GetValue()
        self.settings.newline = self.radio_box_newline.GetSelection()
        self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        """Do not update data but close dialog."""
        self.EndModal(wx.ID_CANCEL)

# end of class TerminalSettingsDialog


class TerminalFrame(wx.Frame):
    """Simple terminal program for wxPython"""

    def __init__(self, *args, **kwds):
        self.serial = serial.Serial()
        self.serial.timeout = 0.5   # make sure that the alive event can be checked from time to time
        self.settings = TerminalSetup()  # placeholder for the settings
        self.thread = None
        self.alive = threading.Event()
        # begin wxGlade: TerminalFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        # Menu Bar
        self.frame_terminal_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_CLEAR, "&amp;Clear", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(ID_SAVEAS, "&amp;Save Text As...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_TERM, "&amp;Terminal Settings...", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_EXIT, "&amp;Exit", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "&amp;File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_RTS, "RTS", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_DTR, "&amp;DTR", "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_SETTINGS, "&amp;Port Settings...", "", wx.ITEM_NORMAL)
        self.frame_terminal_menubar.Append(wxglade_tmp_menu, "Serial Port")
        self.SetMenuBar(self.frame_terminal_menubar)
        # Menu Bar end
        self.text_ctrl_output = wx.TextCtrl(self, -1, "", style=wx.TE_MULTILINE | wx.TE_READONLY)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS)
        self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        # end wxGlade
        self.__attach_events()          # register events
        self.OnPortSettings(None)       # call setup dialog on startup, opens port
        if not self.alive.isSet():
            self.Close()

    def StartThread(self):
        """Start the receiver thread"""
        self.thread = threading.Thread(target=self.ComPortThread)
        self.thread.setDaemon(1)
        self.alive.set()
        self.thread.start()
        self.serial.rts = True
        self.serial.dtr = True
        self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts)
        self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr)

    def StopThread(self):
        """Stop the receiver thread, wait until it's finished."""
        if self.thread is not None:
            self.alive.clear()          # clear alive event for thread
            self.thread.join()          # wait until thread has finished
            self.thread = None

    def __set_properties(self):
        # begin wxGlade: TerminalFrame.__set_properties
        self.SetTitle("Serial Terminal")
        self.SetSize((546, 383))
        self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, ""))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: TerminalFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        # register events at the controls
        self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR)
        self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS)
        self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT)
        self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS)
        self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM)
        self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey)
        self.Bind(EVT_SERIALRX, self.OnSerialRead)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnExit(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Menu point Exit"""
        self.Close()

    def OnClose(self, event):
        """Called on application shutdown."""
        self.StopThread()               # stop reader thread
        self.serial.close()             # cleanup
        self.Destroy()                  # close windows, exit app

    def OnSaveAs(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Save contents of output window."""
        with wx.FileDialog(
                None,
                "Save Text As...",
                ".",
                "",
                "Text File|*.txt|All Files|*",
                wx.SAVE) as dlg:
            if dlg.ShowModal() == wx.ID_OK:
                filename = dlg.GetPath()
                with codecs.open(filename, 'w', encoding='utf-8') as f:
                    text = self.text_ctrl_output.GetValue().encode("utf-8")
                    f.write(text)

    def OnClear(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """Clear contents of output window."""
        self.text_ctrl_output.Clear()

    def OnPortSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """
        Show the port settings dialog. The reader thread is stopped for the
        settings change.
        """
        if event is not None:           # will be none when called on startup
            self.StopThread()
            self.serial.close()
        ok = False
        while not ok:
            with wxSerialConfigDialog.SerialConfigDialog(
                    self,
                    -1,
                    "",
                    show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW,
                    serial=self.serial) as dialog_serial_cfg:
                dialog_serial_cfg.CenterOnParent()
                result = dialog_serial_cfg.ShowModal()
            # open port if not called on startup, open it on startup and OK too
            if result == wx.ID_OK or event is not None:
                try:
                    self.serial.open()
                except serial.SerialException as e:
                    with wx.MessageDialog(self, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)as dlg:
                        dlg.ShowModal()
                else:
                    self.StartThread()
                    self.SetTitle("Serial Terminal on {} [{},{},{},{}{}{}]".format(
                        self.serial.portstr,
                        self.serial.baudrate,
                        self.serial.bytesize,
                        self.serial.parity,
                        self.serial.stopbits,
                        ' RTS/CTS' if self.serial.rtscts else '',
                        ' Xon/Xoff' if self.serial.xonxoff else '',
                        ))
                    ok = True
            else:
                # on startup, dialog aborted
                self.alive.clear()
                ok = True

    def OnTermSettings(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        """\
        Menu point Terminal Settings. Show the settings dialog
        with the current terminal settings.
        """
        with TerminalSettingsDialog(self, -1, "", settings=self.settings) as dialog:
            dialog.CenterOnParent()
            dialog.ShowModal()

    def OnKey(self, event):
        """\
        Key event handler. If the key is in the ASCII range, write it to the
        serial port. Newline handling and local echo is also done here.
        """
        code = event.GetUnicodeKey()
        if code &lt; 256:   # XXX bug in some versions of wx returning only capital letters
            code = event.GetKeyCode()
        if code == 13:                      # is it a newline? (check for CR which is the RETURN key)
            if self.settings.echo:          # do echo if needed
                self.text_ctrl_output.AppendText('\n')
            if self.settings.newline == NEWLINE_CR:
                self.serial.write(b'\r')     # send CR
            elif self.settings.newline == NEWLINE_LF:
                self.serial.write(b'\n')     # send LF
            elif self.settings.newline == NEWLINE_CRLF:
                self.serial.write(b'\r\n')   # send CR+LF
        else:
            char = unichr(code)
            if self.settings.echo:          # do echo if needed
                self.WriteText(char)
            self.serial.write(char.encode('UTF-8', 'replace'))         # send the character

    def WriteText(self, text):
        if self.settings.unprintable:
            text = ''.join([c if (c &gt;= ' ' and c != '\x7f') else unichr(0x2400 + ord(c)) for c in text])
        self.text_ctrl_output.AppendText(text)

    def OnSerialRead(self, event):
        """Handle input from the serial port."""
        self.WriteText(event.data.decode('UTF-8', 'replace'))

    def ComPortThread(self):
        """\
        Thread that handles the incoming traffic. Does the basic input
        transformation (newlines) and generates an SerialRxEvent
        """
        while self.alive.isSet():
            b = self.serial.read(self.serial.in_waiting or 1)
            if b:
                # newline transformation
                if self.settings.newline == NEWLINE_CR:
                    b = b.replace(b'\r', b'\n')
                elif self.settings.newline == NEWLINE_LF:
                    pass
                elif self.settings.newline == NEWLINE_CRLF:
                    b = b.replace(b'\r\n', b'\n')
                event = SerialRxEvent(self.GetId(), b)
                self.GetEventHandler().AddPendingEvent(event)

    def OnRTS(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.rts = event.IsChecked()

    def OnDTR(self, event):  # wxGlade: TerminalFrame.&lt;event_handler&gt;
        self.serial.dtr = event.Checked()

# end of class TerminalFrame


class MyApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_terminal = TerminalFrame(None, -1, "")
        self.SetTopWindow(frame_terminal)
        frame_terminal.Show(True)
        return 1

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;

&lt;h3&gt;wxSerialConfigDialog.py&lt;/h3&gt;

&lt;pre class="brush: python"&gt;

#!/usr/bin/env python
#
# A serial port configuration dialog for wxPython. A number of flags can
# be used to configure the fields that are displayed.
#
# (C) 2001-2015 Chris Liechti &lt;cliechti@gmx.net&gt;
#
# SPDX-License-Identifier:    BSD-3-Clause

import wx
import serial
import serial.tools.list_ports

SHOW_BAUDRATE = 1 &lt;&lt; 0
SHOW_FORMAT = 1 &lt;&lt; 1
SHOW_FLOW = 1 &lt;&lt; 2
SHOW_TIMEOUT = 1 &lt;&lt; 3
SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT


class SerialConfigDialog(wx.Dialog):
    """\
    Serial Port configuration dialog, to be used with pySerial 2.0+
    When instantiating a class of this dialog, then the "serial" keyword
    argument is mandatory. It is a reference to a serial.Serial instance.
    the optional "show" keyword argument can be used to show/hide different
    settings. The default is SHOW_ALL which corresponds to
    SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be
    found in this module (not the class).
    """

    def __init__(self, *args, **kwds):
        # grab the serial keyword and remove it from the dict
        self.serial = kwds['serial']
        del kwds['serial']
        self.show = SHOW_ALL
        if 'show' in kwds:
            self.show = kwds.pop('show')
        # begin wxGlade: SerialConfigDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_2 = wx.StaticText(self, -1, "Port")
        self.choice_port = wx.Choice(self, -1, choices=[])
        self.label_1 = wx.StaticText(self, -1, "Baudrate")
        self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN)
        self.sizer_1_staticbox = wx.StaticBox(self, -1, "Basics")
        self.panel_format = wx.Panel(self, -1)
        self.label_3 = wx.StaticText(self.panel_format, -1, "Data Bits")
        self.choice_databits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_4 = wx.StaticText(self.panel_format, -1, "Stop Bits")
        self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.label_5 = wx.StaticText(self.panel_format, -1, "Parity")
        self.choice_parity = wx.Choice(self.panel_format, -1, choices=["choice 1"])
        self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, "Data Format")
        self.panel_timeout = wx.Panel(self, -1)
        self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, "Use Timeout")
        self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, "")
        self.label_6 = wx.StaticText(self.panel_timeout, -1, "seconds")
        self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, "Timeout")
        self.panel_flow = wx.Panel(self, -1)
        self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, "RTS/CTS")
        self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, "Xon/Xoff")
        self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, "Flow Control")
        self.button_ok = wx.Button(self, wx.ID_OK, "")
        self.button_cancel = wx.Button(self, wx.ID_CANCEL, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        # attach the event handlers
        self.__attach_events()

    def __set_properties(self):
        # begin wxGlade: SerialConfigDialog.__set_properties
        self.SetTitle("Serial Port Configuration")
        self.choice_databits.SetSelection(0)
        self.choice_stopbits.SetSelection(0)
        self.choice_parity.SetSelection(0)
        self.text_ctrl_timeout.Enable(False)
        self.button_ok.SetDefault()
        # end wxGlade
        self.SetTitle("Serial Port Configuration")
        if self.show &amp; SHOW_TIMEOUT:
            self.text_ctrl_timeout.Enable(0)
        self.button_ok.SetDefault()

        if not self.show &amp; SHOW_BAUDRATE:
            self.label_1.Hide()
            self.combo_box_baudrate.Hide()
        if not self.show &amp; SHOW_FORMAT:
            self.panel_format.Hide()
        if not self.show &amp; SHOW_TIMEOUT:
            self.panel_timeout.Hide()
        if not self.show &amp; SHOW_FLOW:
            self.panel_flow.Hide()

        # fill in ports and select current setting
        preferred_index = 0
        self.choice_port.Clear()
        self.ports = []
        for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())):
            self.choice_port.Append(u'{} - {}'.format(portname, desc))
            self.ports.append(portname)
            if self.serial.name == portname:
                preferred_index = n
        self.choice_port.SetSelection(preferred_index)
        if self.show &amp; SHOW_BAUDRATE:
            preferred_index = None
            # fill in baud rates and select current setting
            self.combo_box_baudrate.Clear()
            for n, baudrate in enumerate(self.serial.BAUDRATES):
                self.combo_box_baudrate.Append(str(baudrate))
                if self.serial.baudrate == baudrate:
                    preferred_index = n
            if preferred_index is not None:
                self.combo_box_baudrate.SetSelection(preferred_index)
            else:
                self.combo_box_baudrate.SetValue(u'{}'.format(self.serial.baudrate))
        if self.show &amp; SHOW_FORMAT:
            # fill in data bits and select current setting
            self.choice_databits.Clear()
            for n, bytesize in enumerate(self.serial.BYTESIZES):
                self.choice_databits.Append(str(bytesize))
                if self.serial.bytesize == bytesize:
                    index = n
            self.choice_databits.SetSelection(index)
            # fill in stop bits and select current setting
            self.choice_stopbits.Clear()
            for n, stopbits in enumerate(self.serial.STOPBITS):
                self.choice_stopbits.Append(str(stopbits))
                if self.serial.stopbits == stopbits:
                    index = n
            self.choice_stopbits.SetSelection(index)
            # fill in parities and select current setting
            self.choice_parity.Clear()
            for n, parity in enumerate(self.serial.PARITIES):
                self.choice_parity.Append(str(serial.PARITY_NAMES[parity]))
                if self.serial.parity == parity:
                    index = n
            self.choice_parity.SetSelection(index)
        if self.show &amp; SHOW_TIMEOUT:
            # set the timeout mode and value
            if self.serial.timeout is None:
                self.checkbox_timeout.SetValue(False)
                self.text_ctrl_timeout.Enable(False)
            else:
                self.checkbox_timeout.SetValue(True)
                self.text_ctrl_timeout.Enable(True)
                self.text_ctrl_timeout.SetValue(str(self.serial.timeout))
        if self.show &amp; SHOW_FLOW:
            # set the rtscts mode
            self.checkbox_rtscts.SetValue(self.serial.rtscts)
            # set the rtscts mode
            self.checkbox_xonxoff.SetValue(self.serial.xonxoff)

    def __do_layout(self):
        # begin wxGlade: SerialConfigDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_flow_staticbox.Lower()
        sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL)
        self.sizer_timeout_staticbox.Lower()
        sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL)
        self.sizer_format_staticbox.Lower()
        sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL)
        grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0)
        self.sizer_1_staticbox.Lower()
        sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL)
        sizer_basics = wx.FlexGridSizer(3, 2, 0, 0)
        sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0)
        sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0)
        sizer_basics.AddGrowableCol(1)
        sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0)
        sizer_2.Add(sizer_1, 0, wx.EXPAND, 0)
        grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        self.panel_format.SetSizer(sizer_format)
        sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0)
        sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0)
        sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        self.panel_timeout.SetSizer(sizer_timeout)
        sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0)
        sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4)
        sizer_flow.Add((10, 10), 1, wx.EXPAND, 0)
        self.panel_flow.SetSizer(sizer_flow)
        sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0)
        sizer_3.Add(self.button_ok, 0, 0, 0)
        sizer_3.Add(self.button_cancel, 0, 0, 0)
        sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade

    def __attach_events(self):
        wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK)
        wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel)
        if self.show &amp; SHOW_TIMEOUT:
            wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout)

    def OnOK(self, events):
        success = True
        self.serial.port = self.ports[self.choice_port.GetSelection()]
        if self.show &amp; SHOW_BAUDRATE:
            try:
                b = int(self.combo_box_baudrate.GetValue())
            except ValueError:
                with wx.MessageDialog(
                        self,
                        'Baudrate must be a numeric value',
                        'Value Error',
                        wx.OK | wx.ICON_ERROR) as dlg:
                    dlg.ShowModal()
                success = False
            else:
                self.serial.baudrate = b
        if self.show &amp; SHOW_FORMAT:
            self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()]
            self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()]
            self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()]
        if self.show &amp; SHOW_FLOW:
            self.serial.rtscts = self.checkbox_rtscts.GetValue()
            self.serial.xonxoff = self.checkbox_xonxoff.GetValue()
        if self.show &amp; SHOW_TIMEOUT:
            if self.checkbox_timeout.GetValue():
                try:
                    self.serial.timeout = float(self.text_ctrl_timeout.GetValue())
                except ValueError:
                    with wx.MessageDialog(
                            self,
                            'Timeout must be a numeric value',
                            'Value Error',
                            wx.OK | wx.ICON_ERROR) as dlg:
                        dlg.ShowModal()
                    success = False
            else:
                self.serial.timeout = None
        if success:
            self.EndModal(wx.ID_OK)

    def OnCancel(self, events):
        self.EndModal(wx.ID_CANCEL)

    def OnTimeout(self, events):
        if self.checkbox_timeout.GetValue():
            self.text_ctrl_timeout.Enable(True)
        else:
            self.text_ctrl_timeout.Enable(False)

# end of class SerialConfigDialog


class MyApp(wx.App):
    """Test code"""
    def OnInit(self):
        wx.InitAllImageHandlers()

        ser = serial.Serial()
        print(ser)
        # loop until cancel is pressed, old values are used as start for the next run
        # show the different views, one after the other
        # value are kept.
        for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL):
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser, show=flags)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        # the user can play around with the values, CANCEL aborts the loop
        while True:
            dialog_serial_cfg = SerialConfigDialog(None, -1, "", serial=ser)
            self.SetTopWindow(dialog_serial_cfg)
            result = dialog_serial_cfg.ShowModal()
            print(ser)
            if result != wx.ID_OK:
                break
        return 0

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/ciQDIeh.png"&gt;&lt;/p&gt;</summary><category term="wxpython"></category></entry><entry><title>ubuntu IPV4 IPV6 使用教學</title><link href="http://project.mde.tw/blog/ubuntu-ipv4-ipv6-shi-yong-jiao-xue.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/ubuntu-ipv4-ipv6-shi-yong-jiao-xue.html</id><summary type="html">&lt;p&gt;關於IPV4  IPV6設定&lt;/p&gt;


&lt;pre class="brush: python"&gt;

#先檢查網路
$ ifconfig
#修改/etc/network/interface的檔案
# interfaces(5) file used by ifup(8) and ifdown(8)
auto lo
iface lo inet loopback

sudo eth0
iface eth0 inet static
address 140.130.17.105
netmask 255.255.255.0
network 140.130.17.0
broadcast 140.130.17.255
gateway 140.130.17.254
# dns-* options are implemented by the resolvconf package, if $
dns-nameservers 140.130.1.2 140.130.17.3 168.95.1.1
dns-search mde.nfu.edu.tw

#老師的地址3004

#從新啟動

可以到IPV6的網站測試是否可以連線

&lt;/pre&gt;

&lt;p&gt;試用ubuntu系統改成IPV6和IPV4使用，並測試速度的使用上的問題，主要是在沒有IPV6的網站沒辦法連上去，這部份可能需要依靠proxy進行代理伺服器&lt;/p&gt;</summary><category term="ubuntu 網路設定"></category></entry><entry><title>保養3D列印機</title><link href="http://project.mde.tw/blog/bao-yang-3dlie-yin-ji.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/bao-yang-3dlie-yin-ji.html</id><summary type="html">&lt;p&gt;Control 3D printer and some Question&lt;/p&gt;


&lt;p&gt;1.第一步清理平台&lt;/p&gt;
&lt;p&gt;2.幫滑軌上專用潤滑油&lt;/p&gt;
&lt;p&gt;3.加熱後將線材退出&lt;/p&gt;
&lt;p&gt;4.清理機台外觀&lt;/p&gt;
&lt;p&gt;5.確保滑軌滑動順利&lt;/p&gt;
&lt;p&gt;約兩個禮拜做一次，自動校正，不要太長使用，會導致買新的噴頭。
詳細注意事項，在另行公告&lt;/p&gt;</summary><category term="3d printer"></category></entry><entry><title>OpenCv實作</title><link href="http://project.mde.tw/blog/opencvshi-zuo.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/opencvshi-zuo.html</id><summary type="html">&lt;p&gt;OpenCv in python and use&lt;/p&gt;


&lt;p&gt;實作系統Ubuntu 14.04&lt;/p&gt;
&lt;p&gt;剛開始必須要先安裝依些相關的compiler以及設定黨
步驟如同老師所下載的順序
&lt;pre class="brush: python"&gt;&lt;/p&gt;
&lt;h1&gt;apt-get 更新&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get update&lt;/p&gt;
&lt;h1&gt;apt-get 升級&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get upgrade&lt;/p&gt;
&lt;h1&gt;安裝所需的開發套件&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install build-essential cmake git pkg-config&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的程式庫&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的程式庫&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的程式庫&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libgtk2.0-dev&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的 fortran 編譯器&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install libatlas-base-dev gfortran&lt;/p&gt;
&lt;h1&gt;安裝編譯過程所需的原始碼&lt;/h1&gt;
&lt;p&gt;$ sudo apt-get install python3.4-dev&lt;/p&gt;
&lt;h1&gt;本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy  模組&lt;/h1&gt;
&lt;p&gt;$ sudo pip3 install numpy&lt;/p&gt;
&lt;h1&gt;希望在帳號目錄下的 tmp 進行編譯工作&lt;/h1&gt;
&lt;p&gt;$ cd&lt;/p&gt;
&lt;h1&gt;new folder&lt;/h1&gt;
&lt;p&gt;$ mkdir tmp&lt;/p&gt;
&lt;h1&gt;更換目錄到 tmp&lt;/h1&gt;
&lt;p&gt;$ cd tmp&lt;/p&gt;
&lt;h1&gt;利用 git clone 取得原始碼&lt;/h1&gt;
&lt;p&gt;$ git clone https://github.com/Itseez/opencv.git&lt;/p&gt;
&lt;h1&gt;準備進入倉儲切換分支&lt;/h1&gt;
&lt;p&gt;$ cd opencv&lt;/p&gt;
&lt;h1&gt;採用 3.1.0 版&lt;/h1&gt;
&lt;p&gt;$ git checkout 3.1.0&lt;/p&gt;
&lt;h1&gt;回到用戶目錄&lt;/h1&gt;
&lt;p&gt;$ cd ..&lt;/p&gt;
&lt;h1&gt;再利用 git clone 下載原始碼&lt;/h1&gt;
&lt;p&gt;$ git clone https://github.com/Itseez/opencv_contrib.git&lt;/p&gt;
&lt;h1&gt;準備進入倉儲切換分支&lt;/h1&gt;
&lt;p&gt;$ cd opencv_contrib&lt;/p&gt;
&lt;h1&gt;與 opencv 配合, 採用 3.1.0 版&lt;/h1&gt;
&lt;p&gt;$ git checkout 3.1.0&lt;/p&gt;
&lt;p&gt;$ cd ..&lt;/p&gt;
&lt;h1&gt;準備開始建立程式庫&lt;/h1&gt;
&lt;p&gt;$ cd opencv&lt;/p&gt;
&lt;p&gt;$ mkdir build&lt;/p&gt;
&lt;p&gt;$ cd build&lt;/p&gt;
&lt;h1&gt;這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案&lt;/h1&gt;
&lt;p&gt;$ cmake -D CMAKE_BUILD_TYPE=RELEASE \
    -D CMAKE_INSTALL_PREFIX=/usr/local \
    -D INSTALL_C_EXAMPLES=OFF \
    -D INSTALL_PYTHON_EXAMPLES=ON \
    -D PYTHON_EXECUTABLE=$(which python3) \
    -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \
    -D BUILD_EXAMPLES=ON ..&lt;/p&gt;
&lt;p&gt;$ make -j4&lt;/p&gt;
&lt;p&gt;$ sudo make install&lt;/p&gt;
&lt;p&gt;$ sudo ldconfig&lt;/p&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/opencv_python3_windows.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;有做些許更改同樣也可以達到使用上的設定&lt;/p&gt;
&lt;p&gt;windows中
只需要開起2016spring中把py檔
用cmd line 來執行
下python3 你的程式碼的名子
只要有攝影機就可以執行
請注意
必須要裝好攝影機的驅動才可以執行cvcapture(0)
否則無法執行
0是預設的第1台攝影機
1是第2台
以此類推&lt;/p&gt;</summary><category term="OpenCv"></category></entry><entry><title>R2C2的資料</title><link href="http://project.mde.tw/blog/r2c2de-zi-liao.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/r2c2de-zi-liao.html</id><summary type="html">&lt;p&gt;新的R2C2資料&lt;/p&gt;


&lt;p&gt;中間有新的資料for raspberrypi
是使用node.js啟動server
client端可以看到的
https://github.com/nneves/Raspberrypi_NodeJS&lt;/p&gt;
&lt;p&gt;&lt;a href = "https://github.com/nneves/R2C2_WebInterface/blob/master/README.md"&gt;RaspberryPi R2C2&lt;/a&gt;&lt;/p&gt;</summary><category term="client control"></category></entry><entry><title>樹梅派指令表和使用</title><link href="http://project.mde.tw/blog/shu-mei-pai-zhi-ling-biao-he-shi-yong.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/shu-mei-pai-zhi-ling-biao-he-shi-yong.html</id><summary type="html">&lt;p&gt;找到的些許文章和探討&lt;/p&gt;


&lt;p&gt;在Octoprint底下有個資料夾&lt;/p&gt;
&lt;p&gt;底層有些方法包括模組以及設定檔&lt;/p&gt;
&lt;p&gt;linux指令:&lt;/p&gt;
&lt;p&gt;cp&lt;/p&gt;
&lt;p&gt;mv&lt;/p&gt;
&lt;p&gt;指令再raspberry pi 要熟悉，因為在搬移檔案以及設定檔案，會常使用到，以及設定需要的檔案，像是網路的方法，以及未來可能要用到的USB掛載傳輸資料或者使用&lt;/p&gt;
&lt;pre class="brush: python"&gt;

#先檢查自己找到的usb數量
$ sudo fdisk -l
#...省略....
#Device         Boot  Start      End  Sectors  Size Id Type
#/dev/mmcblk0p1        8192   137215   129024   63M  c W95 FAT32 (LBA)
#/dev/mmcblk0p2      137216 31116287 30979072 14.8G 83 Linux

$ sudo mkdir /media/usbstick
$ sudo chown pi:pi /media/usbstick 

#手動掛載
$ sudo mount -t vfat -o uid=pi,gid=pi /dev/sda1 /media/usbstick
#就可以進行存取

#要拔除時要下指令
$ sudo umount /media/usbstick

&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/kkeiJv2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DeYzBNo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在這些設定檔中使用到的可以更改圖片或者是把程式碼拿出來理解目前解讀進度:&lt;/p&gt;
&lt;p&gt;1.再octoprint中有將各模組拆開來，近日把python的設定看完，可能會接近5%的進度&lt;/p&gt;
&lt;p&gt;2.圖片用到的部分，可能要從新Make(command)才可以用&lt;/p&gt;
&lt;p&gt;待完成部分:&lt;/p&gt;
&lt;p&gt;1.javascript&lt;/p&gt;
&lt;p&gt;2.往後寫出一套for our flask.py&lt;/p&gt;
&lt;p&gt;3.plugin部分&lt;/p&gt;</summary><category term="octopi"></category></entry><entry><title>40323123 - 專題參考資料</title><link href="http://project.mde.tw/blog/40323123-zhuan-ti-can-kao-zi-liao.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323123-zhuan-ti-can-kao-zi-liao.html</id><summary type="html">&lt;p&gt;raspberry pi  connect 3d printer to control the 3d printer &lt;/p&gt;


&lt;p&gt;1.回報目前專題進度:
事項一:目前題目定義 製作一台3D printer跟atom同樣款式的
事項二:因為有三組的成員，目前分配如下所示&lt;/p&gt;
&lt;p&gt;40323123 這組:利用octopi來進行遠端控制，以及自動下料等的問題，自動下料的機構利用GA進行運算&lt;/p&gt;
&lt;p&gt;40323250 這組:進行組裝，設計，Onshape組裝，V-Rep(組裝設計模擬)&lt;/p&gt;
&lt;p&gt;黃婉菁這組:先利用opencv來產生3d module並轉換成stl進行列印(主要目的影像建模出3Dstl)&lt;/p&gt;
&lt;p&gt;參考資料:
1.octopi
&lt;a href="http://plugins.octoprint.org/"&gt;octopi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.octoprintDocs
&lt;a href="http://docs.octoprint.org/en/master/"&gt;octoprint Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.octopi_github
&lt;a href="https://github.com/foosel/OctoPrint/wiki"&gt;octoprint WIKI&lt;/a&gt;
&lt;a href="https://github.com/foosel/OctoPrint/wiki/FAQ"&gt;FAQ&lt;/a&gt;
&lt;a href="https://github.com/guysoft/OctoPi"&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.flux 3d printer中的底板樣式以及掃描方式
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/l9ZISxSo2X0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;5.OpenCv 3d nodule
&lt;a href="http://www.opencv.org.cn/"&gt;OpenCv可參考&lt;/a&gt;&lt;/p&gt;</summary><category term="3d printer"></category></entry><entry><title>40323123 - 3d printer</title><link href="http://project.mde.tw/blog/40323123-3d-printer.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323123-3d-printer.html</id><summary type="html">&lt;p&gt;raspberry pi  connect 3d printer to control the 3d printer &lt;/p&gt;


&lt;p&gt;遠端控制3D列印
這邊使用的遠端列印是使用web client控制&lt;/p&gt;
&lt;p&gt;目前有兩套在觀望的系統~
一個是
&lt;a href="http://octoprint.org/download/"&gt;octopi&lt;/a&gt;
另一個是
&lt;a href="https://www.astroprint.com/downloads"&gt;Astropromt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者是我們自己寫一套
兩套皆使用樹梅派當為控制電腦及server
使用心得:在之前已經有安裝過octopi，使用狀況是不錯，但是gui介面有些許的問題，使用上是沒什麼大礙，在3D printer的控制板，做動方式，像是一般CNC一樣，接收
G指令
&lt;a href="http://reprap.org/wiki/G-code"&gt;Gcoce 大全&lt;/a&gt;
&lt;a href="http://www.slideshare.net/roboard/3d-printer-marlin"&gt;控制系統的code解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這兩套系統，都有開放原始碼，不過因為解析程式有巨大的阻礙，因為對python和樹梅派不熟悉，導致只會安裝不會自己編譯。&lt;/p&gt;</summary><category term="3d printer"></category></entry><entry><title>40323123 - 專題組員的範例文章標題</title><link href="http://project.mde.tw/blog/40323123-zhuan-ti-zu-yuan-de-fan-li-wen-zhang-biao-ti.html" rel="alternate"></link><updated>2016-07-09T13:21:44+08:00</updated><author><name>40323123</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323123-zhuan-ti-zu-yuan-de-fan-li-wen-zhang-biao-ti.html</id><summary type="html">&lt;p&gt;這裡放入 40323123 所寫的文章摘要&lt;/p&gt;


&lt;p&gt;這裡為 40323123 所寫的文章主要內容&lt;/p&gt;</summary><category term="範例"></category></entry></feed>