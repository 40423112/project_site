<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016bg2.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-07-14T23:47:18+08:00</updated><entry><title>40323231日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050714.html" rel="alternate"></link><updated>2016-07-14T23:47:18+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323231ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;3DP碰到的問題及解決&lt;/p&gt;


&lt;h3&gt;第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床?&lt;/h3&gt;
&lt;h3&gt;解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為"+""-""S"顏色分別為"紅""藍""黑"，夢工老師接的是"+"接紅，"-"接藍，"S"接黑。網路是"+"接紅，"-"接黑，"S"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。&lt;/h3&gt;
&lt;h3&gt;問題:1. "+""-""S"如何接?  2.為何線路有的接兩條有的接三條?&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;限位開關分兩種:&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;1. 機械微動開關接法&lt;/h3&gt;
&lt;h4&gt;機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;2. 光學限位開關接法(我們的)&lt;/h3&gt;
&lt;h4&gt;光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;1.S為藍，+為紅，-為黑&lt;/h3&gt;
&lt;h3&gt;2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天進度&lt;/h3&gt;
&lt;h4&gt;組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050714.html" rel="alternate"></link><updated>2016-07-14T22:35:57+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;試圖解決SWIG問題&lt;/p&gt;


&lt;h2&gt;撰寫批次檔 :&lt;/h2&gt;

&lt;p&gt;依照&lt;a href="http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html" title="ittc.ku.edu"&gt;http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html&lt;/a&gt;提供的gcc指令，撰寫了3個批次檔來執行。&lt;/p&gt;
&lt;p&gt;第一個命名為interface.bat，用來讓swig生成"_wrap.c"檔，並建立"build"和"dist"兩個資料夾。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set interface_name=example

echo 編譯接口
swig -python -py3 %interface_name%.i
echo 編譯完成
pause

REM MKDIR
echo 正在建立目錄
MKDIR "build"
MKDIR "dist"
echo 目錄已建立
pause
&lt;/pre&gt;

&lt;p&gt;第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。&lt;/p&gt;
&lt;p&gt;原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成".o"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成".pyd"檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example
set module_name=example

echo 正在建立暫存檔
gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include
move %target_name%.o build\%target_name%.o
move %target_name%_wrap.o build\%target_name%_wrap.o
echo 暫存檔建立
pause

echo 正在建立PYD
gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd
echo PYD建立

copy /Y runme.py dist\runme.py

python dist\runme.py

pause
&lt;/pre&gt;

&lt;p&gt;第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example

echo RMDIR...
RMDIR /S /Q .\build
RMDIR /S /Q .\dist

echo DEL...
del /F /S /Q %target_name%_wrap.c
del /F /S /Q %target_name%.py

pause
&lt;/pre&gt;

&lt;p&gt;檔案如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iPB2jDu.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;執行測試 :&lt;/h2&gt;

&lt;p&gt;之前的example.c和example.i內容並沒有更動。&lt;/p&gt;
&lt;p&gt;第一次執行後，發現會出現以下錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/d0FfYoF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oeY2vw4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2HjltE6.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是這個舉動實在是太耗費時間了，所以後來放棄了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pXH2OW2.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4vVIw2v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;估計是這裡有錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4Dhvqym.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過不知道怎麼調整。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。&lt;/p&gt;
&lt;p&gt;另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323218日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050714.html" rel="alternate"></link><updated>2016-07-14T04:38:20+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323218ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h2&gt;翻譯文章重點&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h2&gt;原文章網址：&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm "&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm &lt;/a&gt;&lt;/p&gt; 
&lt;br&gt;
&lt;h2&gt;Building the visible shapes：&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;1. Automatic mesh division：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Divide selected shapes]&lt;br&gt;
(自動分割物件，有時候會無作用)&lt;br&gt;
[Menu bar --&amp;gt; Edit -&amp;gt; Grouping/Merging --&amp;gt; Merge selected shapes]&lt;br&gt;(使選擇的物件組合在一起)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;2. Extract the convex hull：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
(使物件轉換成convex hull)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;3. Decimate the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Decimate selected shape...]&lt;br&gt;
(減少mesh三角形量)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;4. Remove the inside of the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Extract inside of selected shape]&lt;br&gt;
(此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;下圖說明上述功能應用到imported mesh（沒有第一項）：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;再來我們要分割imported mesh，有兩種方式可使用。&lt;br&gt;&lt;br&gt;
1. Automatic mesh division：跟上面一樣
&lt;br&gt;
2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。&lt;/h3&gt;
&lt;br&gt;
&lt;h2&gt;Building the joints&lt;/h2&gt;&lt;br&gt;
&lt;h3&gt;再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep2.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt; 右鍵→Add→Joint→Revolute(創建一個Revolute joint)，
再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep3.png" weight=600 &gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep4.png" weight=600 &gt;
&lt;br&gt;
&lt;h2&gt;Building the dynamic shapes&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是：&lt;br&gt;&lt;br&gt;
1. dynamic or static：&lt;br&gt;
dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。&lt;br&gt;
static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著
運動移動。&lt;br&gt;&lt;br&gt;
2. respondable or non-respondable：&lt;br&gt;
respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。&lt;br&gt;non-respondable shapes 是相反，他們不會造成碰撞運動。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀：&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;1. Pure shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape]&lt;br&gt;
一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。&lt;br&gt;
&lt;br&gt;
2. Pure compound shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
它是由多個Pure shape組合而成的，功能跟Pure shape雷同。
&lt;br&gt;
&lt;br&gt;
3. Convex shapes：&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex hull of selection] &lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。
&lt;br&gt;
&lt;br&gt;
4. Compound convex shapes, or convex decomposed shapes&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex decomposition of selection...]&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into its convex decomposition...]&lt;br&gt;
它是由多個convex shapes組合而成的，功能跟convex shapes雷同。
&lt;br&gt;
&lt;br&gt;
5. Random shapes：&lt;br&gt;
一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。&lt;/h3&gt;&lt;br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050705.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323250ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;V-rep 與 Solvespace的結合應用&lt;/p&gt;


&lt;h3&gt;最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 &lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_solvespace.png" &gt;
&lt;h3&gt;(檔案位於solvespace官網的 tutorial : linkages)
&lt;/h3&gt;&lt;p&gt;&lt;a href="http://solvespace.com/dl/mechanisms.zip "&gt;壓縮檔載點&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3&gt;由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep.png"&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;軸都放好了 ,只是從屬關係還是不太清楚要如何放置&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep_allaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結果我又弄了一個圖 ,試圖從這邊學習從屬設定&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前只會讓它亂轉&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.gif"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;感覺和各個旋轉軸速度也有關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test2.gif"&gt;
&lt;hr&gt;
&lt;h3&gt;105 - 07/10更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;現在能夠讓連桿旋轉了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;想要測試能否以固定角度來回旋轉 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間...&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_types.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前先以控單軸為主 ,但是遇到以下狀況&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_control2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/example_code1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/code_error1.png" &gt;
&lt;h3&gt;如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;參考 :&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm "&gt;Joint types and operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded "&gt;Child Scripts&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/11更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Joint 種類分成以下4種 :&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/joint-types.png" &gt;
&lt;/br&gt;
&lt;h4&gt;1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。&lt;/h4&gt;
&lt;h4&gt;2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 &lt;/h4&gt;
&lt;h4&gt;3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。&lt;/h4&gt;
&lt;h4&gt;4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;Control the joint :&lt;/h3&gt;
&lt;h4&gt;1.simSetJointPosition : when your joint is not in force/torque mode&lt;/h4&gt;
&lt;h4&gt;2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled&lt;/h4&gt;
&lt;h4&gt;3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試:&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/12更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... &lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/little_car.ttt?raw=true"&gt;little_car.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/little_car.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/14更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Printer_new.png" &gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new.ttt?raw=true"&gt;printer_new.ttt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new_2.ttt?raw=true"&gt;printer_new_2.ttt&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;</summary><category term="solvespace&amp;v-rep"></category></entry><entry><title>40323230日誌 - 105/07/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050712.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ri-zhi-1050712.html</id><summary type="html">&lt;p&gt;瞭解SWIG的用法。&lt;/p&gt;


&lt;h2&gt;軟體修正 :&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;NetBeans&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;為NetBeans安裝python的附加元件，使其可以編譯python文件。&lt;/p&gt;
&lt;p&gt;這些附加元件還包含了jython2.7.0。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M1eGLck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SWIG&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/swig/files/swigwin/" title="sourceforge.net"&gt;https://sourceforge.net/projects/swig/files/swigwin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K2UBCMh.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著就能用它下參數了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Enjvaxe.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;SWIG簡介 :&lt;/h2&gt;

&lt;p&gt;SWIG的功能就是利用自己的Interface檔案".i"，產生出一個"_wrap.c"檔，如果DLL專案一起將這個".c"編譯的話，就可以讓其他高階語言呼叫了。&lt;/p&gt;
&lt;p&gt;SWIG內有個\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。&lt;/p&gt;
&lt;p&gt;諸如：D語言、java、javascript、lua、php、python、ruby。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yrDg75c.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;練習應用 :&lt;/h2&gt;

&lt;p&gt;參考範例：&lt;/p&gt;
&lt;p&gt;/Examples/python/simple/index.html&lt;/p&gt;
&lt;p&gt;&lt;img src="" &gt;&lt;/p&gt;
&lt;p&gt;先寫一個".c"程式碼。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File : example.c */

/* A global variable */
double Foo = 3.0;

/* Compute the greatest common divisor of positive integers */
int gcd(int x, int y) {
  int g;
  g = y;
  while (x &gt; 0) {
    g = x;
    x = y % x;
    y = g;
  }
  return g;
}
&lt;/pre&gt;

&lt;p&gt;然後再寫一個Interface的".i"文件。&lt;/p&gt;
&lt;p&gt;至於格式可能要參考手冊的其他內容。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File: example.i */
%module example

extern int gcd(int x, int y);
extern double Foo;
&lt;/pre&gt;

&lt;p&gt;然後用cmd到/Examples/python/simple中下指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -python example.i
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/Enjvaxe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。&lt;/p&gt;
&lt;p&gt;但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aGmZKry.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG的操作大致知道了，但是仍有些許不瞭解的地方。&lt;/p&gt;
&lt;p&gt;像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現".i"文件格式錯誤的訊息。&lt;/p&gt;
&lt;p&gt;而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。&lt;/p&gt;
&lt;p&gt;另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323230日誌 - 105/07/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050713.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ri-zhi-1050713.html</id><summary type="html">&lt;p&gt;Python 3.5.2軟體更新&lt;/p&gt;


&lt;h2&gt;軟體更新目標 :&lt;/h2&gt;

&lt;p&gt;之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。&lt;/p&gt;
&lt;p&gt;以W:為主，Y:用來撰寫網誌暫不需要更新。&lt;/p&gt;
&lt;p&gt;1.Python 3.5及之前安裝的套件。&lt;/p&gt;
&lt;p&gt;2.Leo 5.3正式版。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Python及套件更新步驟 :&lt;/h2&gt;

&lt;p&gt;將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。&lt;/p&gt;
&lt;p&gt;Python 3.5.2下載處：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/downloads/" title="python.org"&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xgAInox.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip freeze &gt; rq.txt
&lt;/pre&gt;

&lt;p&gt;清單中列的就是Python 3.4安裝的套件版本。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pUMf021.jpg" &gt;&lt;/p&gt;
&lt;p&gt;進入Python 3.5後使用pip指令時出現類似"Fatal error in launcher"的訊息，原因是官方的pip版本較舊。&lt;/p&gt;
&lt;p&gt;如果不更新，只能用"python -m pip"的方式驅動它，所以先命令它為自己升級。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python -m pip install pip --upgrade
&lt;/pre&gt;

&lt;p&gt;然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PN2P60t.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著利用下列指令更新：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip install -r rq.txt
&lt;/pre&gt;

&lt;p&gt;就會裝回所有的套件了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RuXhQhT.jpg" &gt;&lt;/p&gt;
&lt;p&gt;使用下列指令可以查看已安裝的套件。&lt;/p&gt;
&lt;p&gt;而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//已安裝套件
pip freeze
//過期套件
pip list --outdated
&lt;/pre&gt;

&lt;hr&gt;

&lt;h2&gt;Leo更新步驟 :&lt;/h2&gt;

&lt;p&gt;至於安裝Leo，到&lt;a href="http://sourceforge.net/projects/leo/files/Leo/" title="sourceforge.net"&gt;http://sourceforge.net/projects/leo/files/Leo/&lt;/a&gt;下載5.3的安裝檔，並暫時解壓縮到根目錄。&lt;/p&gt;
&lt;p&gt;接著進入\Leo-5.3-final\leo\dist資料夾，執行下面指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python setup.py install
&lt;/pre&gt;

&lt;p&gt;安裝完後，接著就能把解壓縮的檔案刪除了。&lt;/p&gt;
&lt;p&gt;不過在pip的紀錄中還是5.0 Bata2的樣子。&lt;/p&gt;
&lt;p&gt;新版的Leo介面（設定檔複製之前的）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DZGSNFn.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;上次的swig還是沒成功，"_wrap.c"中似乎還要加一些python3的判斷式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python3porting.com/cextensions.html#module-initialization" title="python3porting.com"&gt;http://python3porting.com/cextensions.html#module-initialization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230練習 - 105/07/11</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050711.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230lian-xi-1050711.html</id><summary type="html">&lt;p&gt;使用2015cp範本練習".py"呼叫".pyd"。&lt;/p&gt;


&lt;h2&gt;編譯出Python的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/coursemdetw/2015cp" title="coursemdetw/2015cp"&gt;https://github.com/coursemdetw/2015cp&lt;/a&gt;下載老師的範本練習。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vifdEXt.jpg" &gt;&lt;/p&gt;
&lt;p&gt;C程式的部分分成pymod和pyfun。&lt;/p&gt;
&lt;p&gt;這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kanLiEj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;button裡的內容如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("Z:/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o V:/IDE/Python33/libs/libpython33.a")
g.es("done")
&lt;/pre&gt;

&lt;p&gt;在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("gcc -c -g -IW:/Python34/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("gcc -shared -o dist/"+module_name+".pyd build/"+target_name+".o W:/Python34/libs/python34.lib")
g.es("pymod done")
&lt;/pre&gt;

&lt;p&gt;而另一邊的pyfun同理。&lt;/p&gt;
&lt;p&gt;接著就能在\dist資料夾中編譯出sum.pyd和pyfun.pyd了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CF0b3Ff.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;使用mypy.py :&lt;/h2&gt;

&lt;p&gt;接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。&lt;/p&gt;
&lt;p&gt;mypy.py中導入sum，並使用它裡面的函式sum()。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(sum.sum(1, 30))
&lt;/pre&gt;

&lt;p&gt;在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 定義內部運算的函式內容
int sum2(int a, int b)
{
    return a+b;
}

// sum 函式的 interface
static PyObject* mod_sum(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int s;
    // ii 表示兩個輸入變數都是整數
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係
    s = sum2(a,b);
    // i 表示 s 為整數
    return Py_BuildValue("i",s);
}

// 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function)
// Mod_Methods 為函式 (方法) 結構定義
static struct PyMethodDef Mod_Methods[] = {
    {"sum", mod_sum, METH_VARARGS, "Description.."},
    {NULL,NULL,0,NULL}
};
&lt;/pre&gt;

&lt;p&gt;sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/00d1W9j.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。&lt;/p&gt;
&lt;p&gt;這次是加入一段字串。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(pyfun.pyfun("我的字串"))
&lt;/pre&gt;

&lt;p&gt;在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pyfun(PyObject *self,PyObject *args)
{
    const char *to_who;
    if(!PyArg_ParseTuple(args,"s",&amp;to_who))
        return NULL;
     // pyfun 函式會將輸入字串變數傳回
    return PyUnicode_FromString(to_who);
}
&lt;/pre&gt;

&lt;p&gt;執行後的結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FhNTo1L.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這兩個pyd的結尾不太一樣。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sum.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 模組啟始, PyInit_ 後必須使用"名稱".pyd 中的模組名稱, 以便啟動
// 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum
PyMODINIT_FUNC
PyInit_sum(void)
{
    // 建立模組的起始, 輸入為模組結構名稱之 address
    (void) PyModule_Create(&amp;ModMethods);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;pyfun.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同
PyInit_pyfun(void)
{
    PyObject *m;
    m = PyModule_Create(&amp;moduledef);
    return m;
}
&lt;/pre&gt;

&lt;p&gt;意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。&lt;/p&gt;
&lt;p&gt;若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;延伸應用 :&lt;/h2&gt;

&lt;p&gt;只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。&lt;/p&gt;
&lt;p&gt;在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DYEFA1M.jpg" &gt;&lt;/p&gt;
&lt;p&gt;添加了下列指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//導入
#include "math.h"
//宣告
int sum3(int a, int b);
//副程式sum3
int sum3(int a, int b)
{
    return sqrt(a+b)*10;
}
//定義輸入值和sum3的外部名稱score
static PyObject* mod_score(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int t;
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    t = sum3(a,b);
    return Py_BuildValue("i",t);
}
&lt;/pre&gt;

&lt;p&gt;並在PyMethodDef Mod_Methods[]中再新增一串：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
{"score", mod_score, METH_VARARGS, "Description.."},
&lt;/pre&gt;

&lt;p&gt;接著在mypy.py中呼叫sum.score()就行了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。&lt;/p&gt;
&lt;p&gt;這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？&lt;/p&gt;
&lt;p&gt;不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。&lt;/p&gt;</summary><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230練習 - 105/07/09</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050709.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230lian-xi-1050709.html</id><summary type="html">&lt;p&gt;嘗試用C語言解題&lt;/p&gt;


&lt;h2&gt;BUG fix :&lt;/h2&gt;

&lt;p&gt;W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nXiTYLx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;只要修改cpp.properties的路徑就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zjc51Kz.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Nutcracker Solution :&lt;/h2&gt;

&lt;p&gt;上學期的&lt;a href="http://chiamingyen.github.io/kmolab/blog/2015-fall-cadp-w16.html" title="github.io"&gt;Nutcracker網誌內容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Tfik6jG.jpg" &gt;&lt;/p&gt;
&lt;p&gt;之前的python題目，稍微研究一下後轉成C語言。&lt;/p&gt;
&lt;p&gt;不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RwJbKM9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;先做了兩個程式，不過第一是介面而已，第二個才是主要架構。&lt;/p&gt;
&lt;p&gt;撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。&lt;/p&gt;
&lt;p&gt;有時候會偷吃步測試一些解法。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PDHq9QA.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。&lt;/p&gt;
&lt;p&gt;演算法概念：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iOuX4ks.jpg" &gt;&lt;/p&gt;
&lt;p&gt;途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int k=40;
int h=10;
int a=40;
int b=80;
double r=10;
double pi=M_PI;
int num=1000;

int main()
{
    double deg =pi/180;
    for (int j=45*num; j&lt;=180*num; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        printf("%g\n", (int)(j/num0*100000+.5)/100000.);
        if(r1&lt;=r){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            break;
        }
    }
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;第二支程式的最後成果。&lt;/p&gt;
&lt;p&gt;最後精確度還是沒有很高，不知道問題出在哪裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jbtn7X1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。&lt;/p&gt;
&lt;p&gt;後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int a, b, k, h, r, lim;
double o, wp, thmin, thmax;
double pi=M_PI;
int num=1000;

double solve_minpath(int, int, int, int, int);
double solve_maxangle(int, int, int, int, int);
double solve_maxpath(int, int, int, int);
double solve_minangle(int, int, int, int);

int main()
{
    scanf("%d,%d,%d,%d,%d,%d", &amp;a, &amp;b, &amp;k, &amp;h, &amp;r, &amp;lim);
//強制正值
    a=abs(a);
    b=abs(b);
    h=abs(h);
    k=abs(k);
    r=abs(r);
    lim=abs(lim);
    printf("\n---\n");
    printf("Used pi= %f\n", pi);
    printf("---\n");
    printf("Connecting Rod:\n");
    printf("a= %d b= %d\n", a, b);
    printf("Rod radius= %d\n", r);
    printf("Rod width= %d\n", r*2);
    printf("Space Usage:\n");
    printf("h= %d k= %d\n", h, k);
    printf("Work Path= %d\n", lim);
    printf("---\n\n");
//相關參數代入副程式解題
    o=solve_minpath(k, h, a, b, r);
    wp=solve_maxpath(lim, a, b, r)-o;
    thmin=solve_minangle(lim, a, b, r);
    thmax=solve_maxangle(k, h, a, b, r);
    if(a*b*lim==0){
        printf("---ERRO---\nSome value can't be zero.\n");
        return 1;
    }
    else{
        if(o+r&gt;lim){
            printf("---ERRO---\nSpace is not enough.\n");
            return 2;
        }
        else{
            printf("\n---\n---Result---\n");
            printf("Distance:\n");
            printf("Offset distance:\n");
            printf("o= %f\n", o);
            printf("Work distance:\n");
            printf("wp= %f\n", wp);
            printf("Angle(Degree):\n");
            printf("min= %f max= %f\n---\n", thmin, thmax);
            return 0;
        }
    }
}

double solve_minpath(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return x2;
            break;
        }
    }
    return 0;
}

double solve_maxangle(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return th/deg;
            break;
        }
    }
    return 0;
}

double solve_maxpath(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/2*a*n);
    }
    return n;
}

double solve_minangle(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/(2*a*n));
    }
    return th;
}

&lt;/pre&gt;

&lt;p&gt;最後執行的結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/S6oj3vJ.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。&lt;/p&gt;
&lt;p&gt;後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230練習 - 105/07/10</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050710.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230lian-xi-1050710.html</id><summary type="html">&lt;p&gt;由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。&lt;/p&gt;


&lt;h2&gt;編譯出C的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;找到了一個別人學校的DLL簡單範例。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/" title="niu.edu.tw"&gt;http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。&lt;/p&gt;
&lt;p&gt;使用NetBeans建立了一個C/C++ Dynamic Library。&lt;/p&gt;
&lt;p&gt;若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vLbLF1a.jpg" &gt;&lt;/p&gt;
&lt;p&gt;新建完成後，Projects的欄位就會幫使用者分類：&lt;/p&gt;
&lt;p&gt;Header Files, Resource Files, Source Files, Test Files.&lt;/p&gt;
&lt;p&gt;這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。&lt;/p&gt;
&lt;p&gt;如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇"Add Existing Item..."，再選擇想加入的檔案就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K1LuZ3T.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照範例先在SciTE中寫好了三個檔案。&lt;/p&gt;
&lt;p&gt;編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/acz9z6v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*str, int a, int b)
{
    printf("This is your ID(8):\n");
    printf("Your ID: %s\n", str);
    printf("%d+%d=%d:\n", a, b, a+b);
    return "OK";
}
&lt;/pre&gt;

&lt;p&gt;標頭檔中也有這一段匯入，供可執行檔呼叫。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*, int, int);
&lt;/pre&gt;

&lt;p&gt;這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。&lt;/p&gt;
&lt;p&gt;在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/B5driZY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時候會顯示成功，並在\dist\Debug\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L3U9skL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯出C的可執行檔 :&lt;/h2&gt;

&lt;p&gt;這時再把call DLL.c加入Source File中。&lt;/p&gt;
&lt;p&gt;call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。&lt;/p&gt;
&lt;p&gt;call DLL.c的主程式如下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
int main(void)
{
    int i1, i2;
    char str1[9];
    printf("Key in:\n");
    scanf("%s,%d,%d", &amp;str1, i1, i2);
    printf("\n");

    HMODULE hInst=LoadLibrary("DLLtest.dll");
    if(hInst==NULL){
        printf("Can't load library.\n");
        system("PAUSE");
        return 1;
    }
    char* (*CallDll)(char*, int, int);
    (FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
    if(CallDll==NULL){
        printf("NO Value.\n");
        system("PAUSE");
        return 2;
    }
    printf("Result: %s\n", CallDll(str1, i1,i2));
    FreeLibrary(hInst);
    system("PAUSE");
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;然而在編譯時，NetBeans卻顯示了下列訊息：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/JjwIcXD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;顯示是在這段出了問題：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
(FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
&lt;/pre&gt;

&lt;p&gt;這裡的問題是定義項和被定義項的關係錯誤。&lt;/p&gt;
&lt;p&gt;上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。&lt;/p&gt;
&lt;p&gt;由於是內建函式，所以不太了解其格式甚麼的。&lt;/p&gt;
&lt;p&gt;於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg);
&lt;/pre&gt;

&lt;p&gt;完全不用呼叫dll名稱什麼的。&lt;/p&gt;
&lt;p&gt;因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的"Slvs_"指派計算。&lt;/p&gt;
&lt;p&gt;編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。&lt;/p&gt;
&lt;p&gt;至於工程師規定的格式在slvs.h的註解中有所說明。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。&lt;/p&gt;
&lt;p&gt;下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - 瞭解SWIG &amp; CDemo的資源</title><link href="http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html</id><summary type="html">&lt;p&gt;安裝SWIG&lt;/p&gt;
&lt;p&gt;並檢視下列檔案：&lt;/p&gt;
&lt;p&gt;CDemo.exe&lt;/p&gt;
&lt;p&gt;CDemo.c&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;除了英文的資料，另外還讀了一下關於SWIG的相關中文資料：&lt;/p&gt;
&lt;p&gt;1.Python的資料庫形式&lt;/p&gt;
&lt;p&gt;&lt;a href="https://read01.com/PnGeDg.html" title="read01.com"&gt;https://read01.com/PnGeDg.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.Python在Windows中用SWIG呼叫C/C++的函式（VC）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html" title="falldog7.blogspot.tw"&gt;http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.SWIG概念&lt;/p&gt;
&lt;p&gt;&lt;a href="http://user.frdm.info/ckhung/b/mi/swig.php" title="user.frdm.info"&gt;http://user.frdm.info/ckhung/b/mi/swig.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著從&lt;a href="http://www.swig.org/download.html" title="swig.org"&gt;swig.org&lt;/a&gt;下載最新版的SWIG 3.0.10，將壓縮包解至W:內。&lt;/p&gt;
&lt;p&gt;SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的".tar.gz"。&lt;/p&gt;
&lt;p&gt;解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/G3moEiW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;如果該步驟需要完整的流程，\Doc\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。&lt;/p&gt;
&lt;p&gt;在閱讀\Doc\Manual\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。&lt;/p&gt;
&lt;p&gt;只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VHvu5ps.jpg" &gt;&lt;/p&gt;
&lt;p&gt;手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vaa3Shm.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.exe :&lt;/h2&gt;

&lt;p&gt;CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。&lt;/p&gt;
&lt;p&gt;在原本的\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。&lt;/p&gt;
&lt;p&gt;為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7y0nwjC.jpg" &gt;&lt;/p&gt;
&lt;p&gt;由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。&lt;/p&gt;
&lt;p&gt;顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hzotTGs.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.c :&lt;/h2&gt;

&lt;p&gt;由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。&lt;/p&gt;
&lt;p&gt;用SciTE開啟CDemo.c，可以發現CDemo的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6IlMv1k.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而為了方便，將它部分的原始碼貼在下面：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/*-----------------------------------------------------------------------------
 * Some sample code for slvs.dll. We draw some geometric entities, provide
 * initial guesses for their positions, and then constrain them. The solver
 * calculates their new positions, in order to satisfy the constraints.
 *
 * Copyright 2008-2013 Jonathan Westhues.
 *---------------------------------------------------------------------------*/
#ifdef HAVE_CONFIG_H
...
#endif
#ifdef WIN32
...
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_STDINT_H
...
#endif

#include &lt;slvs.h&gt;

static Slvs_System sys;

static void *CheckMalloc(size_t n)
{
    void *r = malloc(n);
    if(!r) {
        printf("out of memory!\n");
        exit(-1);
    }
    return r;
}

/*-----------------------------------------------------------------------------
 * An example of a constraint in 3d. We create a single group, with some
 * entities and constraints.
 *---------------------------------------------------------------------------*/
void Example3d()
{
...
}

/*-----------------------------------------------------------------------------
 * An example of a constraint in 2d. In our first group, we create a workplane
 * along the reference frame's xy plane. In a second group, we create some
 * entities in that group and dimension them.
 *---------------------------------------------------------------------------*/
void Example2d()
{
...
}

int main()
{
    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));
    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));
    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));

    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));
    sys.faileds = 50;

    /*Example3d();*/
    for(;;) {
        Example2d();
        sys.params = sys.constraints = sys.entities = 0;
        break;
    }
    return 0;
}

&lt;/pre&gt;

&lt;p&gt;在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。&lt;/p&gt;
&lt;p&gt;所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
void Example2d()
{
    Slvs_hGroup g;
    double qw, qx, qy, qz;

    g = 1;
    /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
    Slvs_MakeQuaternion(1, 0, 0,
                        0, 1, 0, &amp;qw, &amp;qx, &amp;qy, &amp;qz);
    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

    /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
    g = 2;
    /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */
    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);

    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);

    /* And we create a line segment with those endpoints. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,
                                        200, 301, 302);

    /* Now three more points. */
    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);
    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);

    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);
    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);

    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);
    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);

    /* And arc, centered at point 303, starting at point 304, ending at
     * point 305. */
    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,
                                    303, 304, 305);

    /* Now one more point, and a distance */
    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);
    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);

    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);
    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);

    /* And a complete circle, centered at point 306 with radius equal to
     * distance 307. The normal is 102, the same as our workplane. */
    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,
                                    306, 102, 307);


    /* The length of our line segment is 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            30.0,
                                            301, 302, 0, 0);

    /* And the distance from our line segment to the origin is 10.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            2, g,
                                            SLVS_C_PT_LINE_DISTANCE,
                                            200,
                                            10.0,
                                            101, 0, 400, 0);
    /* And the line segment is vertical. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            3, g,
                                            SLVS_C_VERTICAL,
                                            200,
                                            0.0,
                                            0, 0, 400, 0);
    /* And the distance from one endpoint to the origin is 15.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            4, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            15.0,
                                            301, 101, 0, 0);
#if 0
    /* And same for the other endpoint; so if you add this constraint then
     * the sketch is overconstrained and will signal an error. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            5, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            18.0,
                                            302, 101, 0, 0);
#endif /* 0 */

    /* The arc and the circle have equal radius. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            6, g,
                                            SLVS_C_EQUAL_RADIUS,
                                            200,
                                            0.0,
                                            0, 0, 401, 402);
    /* The arc has radius 17.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            7, g,
                                            SLVS_C_DIAMETER,
                                            200,
                                            17.0*2,
                                            0, 0, 401, 0);

    /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
    sys.calculateFaileds = 1;

    /* And solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("solved okay\n");
        printf("line from (%.3f %.3f) to (%.3f %.3f)\n",
                sys.param[7].val, sys.param[8].val,
                sys.param[9].val, sys.param[10].val);

        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\n",
                sys.param[11].val, sys.param[12].val,
                sys.param[13].val, sys.param[14].val,
                sys.param[15].val, sys.param[16].val);

        printf("circle center (%.3f %.3f) radius %.3f\n",
                sys.param[17].val, sys.param[18].val,
                sys.param[19].val);
        printf("%d DOF\n", sys.dof);
    } else {
        int i;
        printf("solve failed: problematic constraints are:");
        for(i = 0; i &lt; sys.faileds; i++) {
            printf(" %d", sys.failed[i]);
        }
        printf("\n");
        if(sys.result == SLVS_RESULT_INCONSISTENT) {
            printf("system inconsistent\n");
        } else {
            printf("system nonconvergent\n");
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;"Slvs_hGroup g"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。&lt;/p&gt;
&lt;p&gt;之後便能用"sys.param[sys.params++]"或是"sys.entity[sys.entities++]"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。&lt;/p&gt;
&lt;p&gt;比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。&lt;/p&gt;
&lt;p&gt;畫完圖之後，最後解決的程式是使用Slvs_Solve(&amp;amp;sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。&lt;/p&gt;
&lt;p&gt;不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。&lt;/p&gt;
&lt;p&gt;雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="SWIG"></category></entry><entry><title>40323230紀錄 - 編譯Solvespace流程</title><link href="http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html</id><summary type="html">&lt;p&gt;由原始碼編譯出Solvespace和CDemo的執行檔&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。&lt;/p&gt;
&lt;p&gt;連結為下載處。&lt;/p&gt;
&lt;p&gt;1.MinGW (Not official version), &lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;https://nuwen.net/mingw.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.msys (Official version), &lt;a href="http://www.mingw.org/wiki/msys" title="mingw.org"&gt;http://www.mingw.org/wiki/msys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.CMake  (Official version), &lt;a href="https://cmake.org/download/" title="cmake.org"&gt;https://cmake.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.NetBeans (Our storage), &lt;a href="http://140.130.17.17/public/Netbeans/" title="140.130.17.17/public/"&gt;http://140.130.17.17/public/Netbeans/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存放位置除了CMake之外皆為W:內，CMake存於W:\app資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kHQFc1g.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;下載Solvespace原始碼 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;git clone最新的原始碼到W:\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KUJCPoJ.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從\NetBeans\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/m7uH7TA.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/D6TKKRZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rame7tV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;若有必要可以為NetBeans安裝CMake的附加元件。&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6mi2Lz1.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;執行Build :&lt;/h2&gt;

&lt;p&gt;接著按下New Project...新增專案。&lt;/p&gt;
&lt;p&gt;選擇Project with Existing Sources繼續。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TxisGUv.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後選擇Whitequark的Solvespace原始碼目錄。&lt;/p&gt;
&lt;p&gt;並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Gzqb7so.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DF15llN.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時開啟專案內的\src\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。&lt;/p&gt;
&lt;p&gt;註：如果不是填在最後一項會有讀取順序錯誤的問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rAC4a2W.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\src和\exposed資料夾下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/0CEdXhu.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - Solvespace</title><link href="http://project.mde.tw/blog/40323230ji-lu-solvespace.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ji-lu-solvespace.html</id><summary type="html">&lt;p&gt;找到的Solvespace原始碼版本&lt;/p&gt;


&lt;h2&gt;目前可攜式環境內存放的Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;超連結為下載處。&lt;/h3&gt;

&lt;p&gt;1.&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;：非官方人員開發的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dcchKn7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace 2.0&lt;/a&gt;：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/HBZ0DM4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="https://github.com/solvespace/solvespace/releases/tag/v2.1" title="github.com"&gt;Solvespace 2.1&lt;/a&gt;：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和&lt;a href="https://github.com/solvespace/libdxfrw" title="github.com"&gt;solvespace/libdxfrw&lt;/a&gt;有關聯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Zqu4j7i.jpg" &gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href="https://github.com/solvespace/solvespace/tree/2.x" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/UYXGcF7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;相關連結：版本差異紀錄-&lt;a href="https://github.com/solvespace/solvespace/blob/2.x/CHANGELOG.md" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ZGLaQ0j.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WkmsWPq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;點開記錄錯誤的視窗：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/52VlrUJ.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/11</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050711.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323218ri-zhi-1050711.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h4&gt;嘗試四連桿機構&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1&gt;&lt;h3&gt;理想狀態：&lt;/h3&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;br&gt;&lt;/h1&gt;
&lt;h3&gt;前期嘗試：&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/before.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;前期階級排列：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step10.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;查詢資料：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step11.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;(在兩個dynamic item之間不能有static item)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;修改後：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step12.png" weight=600 &gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/after.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;未來嘗試：製作搖擺機構&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm &lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050705.html" rel="alternate"></link><updated>2016-07-14T02:12:22+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索-2&lt;/p&gt;
&lt;p&gt;註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。&lt;/p&gt;


&lt;p&gt;目前NetBeans的&lt;a href="https://netbeans.org/kb/docs/intro-screencasts.html?utm_source=netbeans&amp;amp;utm_campaign=welcomepage" title="netbeans.org"&gt;官方網站&lt;/a&gt;並沒有很詳盡的介紹，只有放一些改版的導覽影片。&lt;/p&gt;
&lt;p&gt;基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。&lt;/p&gt;
&lt;h2&gt;NetBeans啟動 :&lt;/h2&gt;

&lt;p&gt;每次啟動可攜式環境，NetBeans portable都會保留之前的設定。&lt;/p&gt;
&lt;p&gt;只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。&lt;/p&gt;
&lt;p&gt;另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。&lt;/p&gt;
&lt;p&gt;不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。&lt;/p&gt;
&lt;p&gt;設定start.bat在啟動後自動打開NetBeans。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VyTHn6F.jpg" &gt;&lt;/p&gt;
&lt;p&gt;NetBeans在啟動時載入專案的提示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/g2hnriA.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans介面 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/dpboPO9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;跟大部分的文字編譯軟體差不多的介面。&lt;/p&gt;
&lt;p&gt;在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。&lt;/p&gt;
&lt;p&gt;行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。&lt;/p&gt;
&lt;p&gt;捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。&lt;/p&gt;
&lt;p&gt;NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dHiNW4x.jpg" &gt;&lt;/p&gt;
&lt;p&gt;主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。&lt;/p&gt;
&lt;p&gt;另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。&lt;/p&gt;
&lt;p&gt;上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y94zmYv.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。&lt;/p&gt;
&lt;p&gt;以下是File的檔案目錄和檔案總管顯示的比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ekWZDfJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ORqMv0Q.jpg" &gt;&lt;/p&gt;
&lt;p&gt;服務頁籤中會顯示一些工具，不過不知道怎麼使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qMeIdGo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。&lt;/p&gt;
&lt;p&gt;在物件上點擊兩下會移到該物件所在的檔案位置。&lt;/p&gt;
&lt;p&gt;在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rTjJ0jx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XBywmpk.jpg" &gt;&lt;/p&gt;
&lt;p&gt;工具列的功能說明：&lt;/p&gt;
&lt;p&gt;1：Source-切換至編輯原始碼模式。&lt;/p&gt;
&lt;p&gt;2：History-切換至編輯記錄模式。&lt;/p&gt;
&lt;p&gt;3：Last Edit-回到上次編輯（插入／刪除）過的位置。&lt;/p&gt;
&lt;p&gt;4：Go back to-上一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;5：Forward-下一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;6：Find Selection-在本檔案搜尋框選的文字。&lt;/p&gt;
&lt;p&gt;7：Find Previous Occurrence-尋找前一個關鍵字。&lt;/p&gt;
&lt;p&gt;8：Find Next Occurrence-尋找後一個關鍵字。&lt;/p&gt;
&lt;p&gt;9：Toggle Highlight Search-切換高亮度標示。&lt;/p&gt;
&lt;p&gt;10：Toggle Rectangular Selection-切換矩形框選模式。&lt;/p&gt;
&lt;p&gt;11：Previous Bookmark-前一個書籤。&lt;/p&gt;
&lt;p&gt;12：Next Bookmark-下一個書籤。&lt;/p&gt;
&lt;p&gt;13：Toggle Bookmark-切換書籤。&lt;/p&gt;
&lt;p&gt;14：Shift Line Left-往左縮排。&lt;/p&gt;
&lt;p&gt;15：Shift Line Right-往右縮排。&lt;/p&gt;
&lt;p&gt;16：Start Macro Recording-開始巨集（腳本）錄製。&lt;/p&gt;
&lt;p&gt;17：Stop Macro Recording-停止巨集錄製。&lt;/p&gt;
&lt;p&gt;18：Comment-註解。&lt;/p&gt;
&lt;p&gt;19：UNcomment-刪掉註解。&lt;/p&gt;
&lt;p&gt;20：Go to Header/Source-開啟源頭檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。&lt;/p&gt;
&lt;p&gt;以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323250日誌 - 105/07/01</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050701.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323250ri-zhi-1050701.html</id><summary type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;


&lt;h2&gt;★暑期第一個禮拜的 星期四 - 06/30★&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h2&gt;心得 :&lt;/h2&gt;
&lt;h3&gt;今天在網路上找了一堆範例影片 ,每一部片都快一個小時 ,然後都不知道怎麼運用 ,但至少對V-rep功能多了解一些了。&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;★暑期第一個禮拜的 星期五 - 07/01★&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;基本功能 : &lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;導入stl檔案&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/import.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;先點選導入的檔案 ,然後點選Edit選單下的Grouping / Merging ,點選 Divide selected shapes 分離零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/divide_objects.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;分離完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/divide_done.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;拆解可能遇到的問題&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_problems.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;加入旋轉軸 : 在右側視窗點選右鍵 , 新增 → 節點 → 旋轉軸
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;新增完成 ,快點兩下圖示 ,可以設定相關性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;橘色框框為旋轉軸長度及直徑 ,旋轉軸最後可以設定隱藏&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;如果相關參數都設定好了 ,點選右鍵→編輯→使旋轉軸與零件結合成一物件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結合後的從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_parent.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;心得 :&lt;/h2&gt;
&lt;h3&gt;V-rep很好玩 ,但是它組裝的層次又比creo2.0又更上一檔次了 ,
俗話說的好 「良藥苦口」,好用的東西種剛開始總是特別棘手。 &lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;★暑期第一個禮拜的 星期六 - 07/02★&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;工廠認證 及 探查狀況&lt;/h3&gt;
&lt;h3&gt;傳統機臺幾乎沒有精度可言 ,一年級時故障的機臺也都沒有維修 ,只怕使用傳統機臺會成為受害者 ,不敢使用!!&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;旋轉軸(馬達)設定&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;先將各部位組立完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_pin.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定底座Dynamic性質 , ( X = 不打勾 )
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定Revolute_joint(馬達)性質 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉軸Dynamic性質 ,設為動態物件
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉桿Dynamic性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在Assciated object選擇STL_Imported_sub(主體) &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後打開左方script ,並加入下面那行程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/child_script.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定完之後就可以按start ,跑老師的python範例了&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;★暑期第二個禮拜的 星期一 - 07/04★&lt;/h2&gt;
&lt;h2&gt;加入攝影機&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;vision_sensor類型可分為 :
a.為orthographic type  及  b.為perspective type&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_types.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 ,
綠色框框為範圍內的解析度 (2^n ,2~256) ,棕色框框為攝影機大小&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將旋轉桿和攝影機結合並設定從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/add_2views.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/first_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/second_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;啟動程式來跑看看囉~&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision.gif"&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/29</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050629.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323250ri-zhi-1050629.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;


&lt;h3&gt;進度&lt;/h3&gt;

&lt;h4&gt;目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖:&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/OCcfYur.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/64Qlmfm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是v-rep拆解後的截圖&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;簡易版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/1C9EKl2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;完整版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/I7q77aX.png"&gt;
&lt;/br&gt;
&lt;h3&gt;明天應該就可以開始測試模擬了。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/28</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050628.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323250ri-zhi-1050628.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;


&lt;h3&gt;目前組合進度&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/D2k3uqk.gif"&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的狀況&lt;/h3&gt;
&lt;h4&gt;我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/W3N5pkC.png"&gt;
&lt;/br&gt;
&lt;h4&gt;滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>Summer Plan</title><link href="http://project.mde.tw/blog/summer-plan.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-04:blog/summer-plan.html</id><summary type="html">&lt;p&gt;Summer project&lt;/p&gt;


&lt;p&gt;1.畫3D Printer (V-rep ,Onshape)&lt;/p&gt;

&lt;p&gt;2.實驗室網站介面&lt;/p&gt;

&lt;p&gt;3.Octopi ,機械手臂&lt;/p&gt;

&lt;p&gt;4.OpenCV &lt;/p&gt;

&lt;p&gt;5.RGA演算&lt;/p&gt;

&lt;p&gt;6.認證主機(Virtual Box)&lt;/p&gt;

&lt;p&gt;7.Proxy&lt;/p&gt;

&lt;p&gt;8.報告(拍照 ,內容整理)&lt;/p&gt;

&lt;p&gt;9.找碩班教授&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;暑期人數 : &lt;/p&gt;
&lt;p&gt;七月:第一組3人 ,第二組4人&lt;/p&gt;
&lt;p&gt;八月:第一組3人 ,第二組4人 ,第三組1人&lt;/p&gt;
&lt;p&gt;&lt;font size="5" face="Arial"&gt;&lt;marquee border="0" scrollamount="50" behavior="alternate"&gt;You can't see me&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>OpenCv範例執行</title><link href="http://project.mde.tw/blog/opencvfan-li-zhi-xing.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-04:blog/opencvfan-li-zhi-xing.html</id><summary type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;


&lt;h3&gt;實作系統Ubuntu 14.04 以及 老師整合的檔案&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image"&gt;範例網址1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/picture/messi.jpg"&gt;使用到的圖片&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
img = cv2.imread('messi.jpg',0)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv2.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv2.imwrite('messigray.png',img)
    cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/tI55TDf.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html#display-video"&gt;範例網址2.&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)
while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break&lt;/p&gt;
&lt;h1&gt;When everything done, release the capture&lt;/h1&gt;
&lt;p&gt;cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/MOL03LL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;範例網址3.(同上)&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)&lt;/p&gt;
&lt;h1&gt;Define the codec and create VideoWriter object&lt;/h1&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        # write the flipped frame
        out.write(frame)
        cv2.imshow('frame',frame)
        if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
            break
    else:
        break&lt;/p&gt;
&lt;h1&gt;Release everything if job is finished&lt;/h1&gt;
&lt;p&gt;cap.release()
out.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;h4&gt;得到檔案名稱為output的avi影片檔&lt;/h4&gt;&lt;/p&gt;</summary><category term="OpenCv"></category></entry><entry><title>40323230日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;改用CMD設定CMake&lt;/p&gt;


&lt;h2&gt;CMD命令cmake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的Command-line build&lt;/h3&gt;

&lt;p&gt;使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/F6tBRr1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2h18M7K.jpg" &gt;&lt;/p&gt;
&lt;p&gt;到CMD中下Readme中提供的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpzsMMZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下nmake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SMlMAQc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是在最後出現一些錯誤，不知道原因為何。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CZ2wMoU.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。&lt;/p&gt;
&lt;p&gt;如果要改用NetBeans，就不用下nmake的指令。&lt;/p&gt;
&lt;hr&gt;

&lt;h3&gt;Readme的MSVC build&lt;/h3&gt;

&lt;p&gt;這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/8D6cRvV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著同樣按照Readme的說明用CMD下指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iXmV4cR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過後面的make指令會說無法讀取makefile檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/04-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050704-2.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索&lt;/p&gt;


&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;MinGW Distro - nuwen.net&lt;/a&gt;下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。&lt;/p&gt;
&lt;p&gt;下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。&lt;/p&gt;
&lt;p&gt;這個MinGW裡還配有一個比較簡單的git工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QusRHMc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。&lt;/p&gt;
&lt;p&gt;先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。&lt;/p&gt;
&lt;p&gt;設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aY6AzV5.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans專案 :&lt;/h2&gt;

&lt;p&gt;之後新建專案，選擇C語言已有源代碼的專案。&lt;/p&gt;
&lt;p&gt;選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MOdwa0P.jpg" &gt;&lt;/p&gt;
&lt;p&gt;基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/f4sSsvQ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接下來是清理和建置指令，就和打在CMD視窗裡的一樣。&lt;/p&gt;
&lt;p&gt;幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/HrGJNnU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。&lt;/p&gt;
&lt;p&gt;下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。&lt;/p&gt;
&lt;p&gt;左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。&lt;/p&gt;
&lt;p&gt;左下的導航欄似乎能執行CMake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mFKn2Pc.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。&lt;/p&gt;
&lt;p&gt;雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050703.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;


&lt;h2&gt;編譯 Solvespace 前的準備 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="http://www.activestate.com/activeperl/downloads" title="activestate.com"&gt;Active State&lt;/a&gt;下載了 ActivePerl，使用的是5.24.0／x64版。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="visualstudio.com"&gt;Microsoft&lt;/a&gt;下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;GitHub&lt;/a&gt;下載Solvespace的原始碼，另外在&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace&lt;/a&gt;提供下載的頁面中也有一個較舊版的原始碼。&lt;/p&gt;
&lt;p&gt;裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/we7AKIF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;用CMD從安裝目錄的\VC\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iCFeYAe.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;關於NMAKE的使用方法，找了幾個中國的網站介紹：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://www.cnblogs.com/kekec/archive/2013/04/21/3007277.html" title="cnblogs.com"&gt;NMAKE的指令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.csdn.net/cneaglelee/article/details/11714803" title="csdn.net"&gt;NMAKE的開發環境設置&lt;/a&gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050703-2.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace(更新)&lt;/p&gt;


&lt;h2&gt;使用CMake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的GUI build&lt;/h3&gt;

&lt;p&gt;下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。&lt;/p&gt;
&lt;p&gt;在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。&lt;/p&gt;
&lt;p&gt;CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nk3qTV4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。&lt;/p&gt;
&lt;p&gt;要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。&lt;/p&gt;
&lt;p&gt;Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。&lt;/p&gt;
&lt;p&gt;雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。&lt;/p&gt;
&lt;p&gt;Configure的部分嘗試選擇MinGW的選項。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/5br2VyW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OljnPa7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;暫時用Visual Studio的設定，但是結果似乎不理想。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TSfLb5n.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.youtube.com/watch?v=gYmgbqGfv-8" title="youtube.com"&gt;教學影片-Visual Studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.youtube.com/watch?v=2A-iRgOhL8A" title="youtube.com"&gt;教學影片-Mingw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄</title><link href="http://project.mde.tw/blog/40323230ji-lu.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ji-lu.html</id><summary type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;


&lt;h2&gt;V-REP Example Learning Reviews&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;嘗試用英文說明&lt;/h4&gt;
&lt;/br&gt;
&lt;h2&gt;Notes :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;The "Scene hierarchy" panel can show whole of outward and entity in a tree.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy" title="coppeliarobotics.com"&gt;Scene hierarchy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/cqIHtFn.jpg" &gt;
&lt;/br&gt;
&lt;h3&gt;In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Any parts can insert a script to control them.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;"Dummy" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummies.htm" title="coppeliarobotics.com"&gt;Dummy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/caU2SLx.jpg" &gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;目前整理完幾何部件的檔案。存於\users\g2_files\VREP_Simulation.ttt中。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNvEHRc.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="V-rep"></category></entry><entry><title>40323218日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050704.html" rel="alternate"></link><updated>2016-07-04T23:56:38+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323218ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h3&gt;熟悉 V-Rep 基本操作&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/introduce1.PNG"&gt;
&lt;br&gt;
&lt;h3&gt;1. 2D移動&lt;br&gt;
2. 3D旋轉&lt;br&gt;
3. 遠近&lt;br&gt;
4. 移動畫面至物體&lt;br&gt;
5. 物體定位(x,y,z)&lt;br&gt;
6. 物體旋轉(x,y,z)&lt;br&gt;
7. 開始模擬&lt;br&gt;
8. 暫停模擬&lt;br&gt;
9. 結束模擬&lt;br&gt;
10. 慢速&lt;br&gt;
11. 加速&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;嘗試製作 one_link_robot&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;File→import→Mesh...(從資料夾中輸入 stl檔)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;選擇單位和方向&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step3.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選物體使用"object shift"調整Z軸距離&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;右鍵→Add→Joint→Revolute(增加旋轉軸)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ...
&lt;br&gt;
&lt;h3&gt;再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用"object shift"在XYZ都點Apply to selection , 在"Orientation/Rotations"也點 Apply , 使兩軸重疊&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step6.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動)
&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step7.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;
使圓柱降階成為旋轉軸的Child&lt;br&gt;
使旋轉物降階成為圓柱的Child&lt;br&gt;
使旋轉軸降階成為底座的Child&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step8.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;按左側"Script" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座.&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step9.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;double - click the child script,  在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) &lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/Round.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選"Start simulation" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~&lt;/h3&gt;&lt;/p&gt;
&lt;h3&gt;製作影片：&lt;/h3&gt;

&lt;iframe src="https://player.vimeo.com/video/173321561" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/173321561"&gt;V-Rep one_link_robot&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry></feed>