<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016bg2.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-09-05T21:00:00+08:00</updated><entry><title>40323230日誌 - 105/09/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050905.html" rel="alternate"></link><published>2016-09-05T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-05:blog/40323230ri-zhi-1050905.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小細節修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼顯示功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;繪圖選項&lt;/h2&gt;
&lt;p&gt;新增顯示尺度和反黑背景的選項。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GR2XV7W.png" &gt;&lt;/p&gt;
&lt;h2&gt;佈署面板&lt;/h2&gt;
&lt;p&gt;由於碰到一些小障礙，所以就先作模擬面板的部份。&lt;/p&gt;
&lt;p&gt;之所以使用嵌入的 Widget，是因為必須一面看著畫布作調整，所以都放在主視窗作業會比較好。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mzzttQV.png" &gt;&lt;/p&gt;
&lt;p&gt;不過之間的傳輸功能還在研究，和視窗設定的形式不一樣，不能在關閉的瞬間偵測。&lt;/p&gt;
&lt;h2&gt;右鍵選單&lt;/h2&gt;
&lt;p&gt;由於發現會受表格標頭欄厚度的影響，微調了一下右鍵選單的位置，不過這些定值會因為字體大小而改變。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/i1HaiEu.png" &gt;&lt;/p&gt;
&lt;p&gt;拆開滑鼠游標的 X Y 位置作像素調整：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def on_point_context_menu(self, point):
    pos = QPoint(point.x()+43, point.y()+23)
    action = self.popMenu_point.exec_(self.Entiteis_Point.mapToGlobal(pos))
    ...
&lt;/pre&gt;

&lt;p&gt;以及偵測加入項目後出現欄的寬度：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def on_link_context_menu(self, point):
    if self.Entiteis_Link.rowCount()==0: pos = QPoint(point.x()+3, point.y()+23)
    else: pos = QPoint(point.x()+15, point.y()+23)
&lt;/pre&gt;

&lt;h2&gt;存檔提示&lt;/h2&gt;
&lt;p&gt;視窗標題會在修改後，未存檔時多出星號。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vu3IpEj.png" &gt;&lt;/p&gt;
&lt;p&gt;讀檔、開新檔案、存檔後星號會消失。&lt;/p&gt;
&lt;p&gt;在沒有星號的情形下，關閉程式時不會提示是否存檔。&lt;/p&gt;
&lt;h2&gt;圖形顏色對應&lt;/h2&gt;
&lt;p&gt;利用 Python 的 dict 鍵值功能作顏色對應表，基本概念如下：&lt;/p&gt;
&lt;pre&gt;
dict = {key1 : value1, key2 : value2}
dict[key1] 得 value1
dict[key2] 得 value2
&lt;/pre&gt;

&lt;p&gt;可以使用 zip 來將兩個 list 縫合，顏色代碼對應 Qt 的 Name space。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.Color = dict(zip(self.re_Color, val_Color))
&lt;/pre&gt;

&lt;p&gt;這樣就可得（無定義則用綠色）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
try: pen.setColor(self.Color[self.table_style.item(i, 1).text()])
except KeyError: pen.setColor(Qt.green)
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;Print 程式碼&lt;/h1&gt;
&lt;p&gt;新增一個功能，會在監視窗中 Print 所有迴圈呈現的程式碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IaWfQ3B.png" &gt;&lt;/p&gt;
&lt;p&gt;這個功能目前僅只於 print，之後會做成顯示在視窗中、存成文字的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;路徑計算問題&lt;/h1&gt;
&lt;p&gt;將約束帶入後似乎出現了問題，還在研究如何解決。&lt;/p&gt;
&lt;p&gt;路徑計算功能能夠畫出指定點（可複數）的移動軌跡，設定視窗中使用兩個表單達成這個功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vAZJs5i.png" &gt;&lt;/p&gt;
&lt;p&gt;結果計算後變成 180° 之後的軌跡出現錯亂。&lt;/p&gt;
&lt;p&gt;下圖繪製 Point2 和 Point3 的軌跡，Point3 的圓周運動是一切正常，但是 Point2 在繞回來時運算不知道為何出了嚴重的錯誤，畫在不可能出現的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VYzwVFZ.png" &gt;&lt;/p&gt;
&lt;p&gt;由於這部份功能的程式滿大的，也是用自己的邏輯手寫的，可能會漏一些沒注意的地方，檢查費了不少功夫。&lt;/p&gt;
&lt;p&gt;原理是用一整個 list object 傳送座標群的，包含選擇的點，從 start angle 到 end angle 的範圍，理論上是三維的。&lt;/p&gt;
&lt;p&gt;不過迴圈迭代時有點小毛病，所以改成 object[0] 是第一個點的 X 軸，object[1] 是 Y 軸，object[2] 是第二個點的 X 軸，以此類推。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#取值用的迴圈
for i in range(0, len(self.Path), 2):
    X_path = self.Path[i]
    Y_path = self.Path[i+1]
&lt;/pre&gt;

&lt;p&gt;可能是 slvs 程式庫的約束處理問題，因為我是先將「呆鍊」組成三角形後才約束「連桿」接起，因而動到主動軸的點，產生了這個問題。&lt;/p&gt;
&lt;p&gt;相反地，「客製化」零件的約束順序採用最保險的方式，所以沒有這個問題。&lt;/p&gt;
&lt;p&gt;歸納幾個解決方式，是製作以下功能（都會加入）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;調整表格順序的功能（決定優先權，比較好知道原因）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;優先偵測主動軸的參照點，優先定義與其相關的連桿約束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前提到的，因為這部份程式碼滿大的，跨了3個檔案，所以可能要一些時間處理。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050903.html" rel="alternate"></link><published>2016-09-03T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-03:blog/40323230ri-zhi-1050903.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;QPaint 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模擬功能-目標&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;QPaint&lt;/h1&gt;
&lt;p&gt;其實 QPaint 繪圖就跟 slvs 程式庫滿像的，只需要擔心順序（圖層）問題。&lt;/p&gt;
&lt;p&gt;用 QPaint 繪圖的話，想辦法將最新的座標 copy 進去就行了。&lt;/p&gt;
&lt;p&gt;把繪圖的 Widget 和處理 list 的副程式獨立出來，名為 &lt;code&gt;canvas.py&lt;/code&gt; 和 &lt;code&gt;list_process&lt;/code&gt;，沒什麼影響，讓主程式不會太雜亂。&lt;/p&gt;
&lt;p&gt;Class 中宣告一個名為 &lt;code&gt;update_figure&lt;/code&gt; 的函式，主程式要刷新時就會呼叫，並填進主程式的表單，這個函式就會將所有表單填進 &lt;code&gt;self&lt;/code&gt; 的 object 裡，讓 &lt;code&gt;paintEvent&lt;/code&gt; 函式讀取。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def update_figure(self, table_point, table_line,
        table_chain, table_shaft,
        table_slider, table_rod,
        table_style, zoom_rate):
    self.Xval = []
    self.Yval = []
    zoom = float(zoom_rate.replace("%", ""))/100
    self.table_point = table_point
    ...
    self.update()
&lt;/pre&gt;

&lt;p&gt;之所以這樣寫，是因為 &lt;code&gt;paintEvent&lt;/code&gt; 函式和所有 Qt 的 &lt;code&gt;Event&lt;/code&gt; 函式都不能輸入 &lt;code&gt;event&lt;/code&gt; 以外的參數。&lt;/p&gt;
&lt;p&gt;而且 Qt 有規定 QPainter 只能畫在 &lt;code&gt;paintEvent&lt;/code&gt; 函式中，不然會出錯。而這個函式也同時決定重新繪製的時機（視窗縮放，改變大小時）。&lt;/p&gt;
&lt;p&gt;若想手動刷新，對 Widget 物件下 &lt;code&gt;self.update()&lt;/code&gt; 或 &lt;code&gt;self.repaint()&lt;/code&gt;（不建議，閃爍頻率高）就行了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;event&lt;/code&gt; 參數是專門傳入事件發生相關的數據，如滑鼠座標：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def mouseMoveEvent(self, event):
    if self.drag:
        self.origin_x = event.x()
        self.origin_y = event.y()
        self.update()
&lt;/pre&gt;

&lt;p&gt;能夠繪圖後，必須校正視圖的大小和位置，由於大小要看這個機構的基本尺寸是多少，所以給使用者自己調整是最好的方法了。&lt;/p&gt;
&lt;p&gt;預設是將座標尺度放大兩倍後定義為畫布的一倍，所以剛才的 &lt;code&gt;update_figure&lt;/code&gt; 中有下列轉換式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
for i in range(table_point.rowCount()):
    self.Xval += [float(table_point.item(i, 1).text())*zoom*rate_all]
    self.Yval += [float(table_point.item(i, 2).text())*zoom*rate_all*(-1)]
&lt;/pre&gt;

&lt;p&gt;Y 軸座標乘上負號是因為不論 Window 和 Widget，兩者都是從「標題欄」往下延伸的，所以向下是負值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tqzbuxp.png" &gt;&lt;/p&gt;
&lt;p&gt;上次更新中加入沒用到的 QSlider 滑桿，這次讓它能夠定義放大的倍率，從 50％ 到 500％，應該都能夠支援幾乎所有尺度的機構了。&lt;/p&gt;
&lt;p&gt;另外調整畫布大小可以用 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + 滑鼠滾輪調整，&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 左鍵按住拖移或雙擊可以定義原點位置。&lt;/p&gt;
&lt;p&gt;這樣設定是讓使用者不會亂拉將圖面移走，也更能知道機構樣貌。&lt;/p&gt;
&lt;p&gt;而這次顏色設定暫時只有 R、G、B 三色，其他色碼的加入還要看下說明文件，原本的顏色都偏亮或太黯淡，所以會整合後加入其他顏色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;＊上次的 mpl 畫布就有加入存成 png 圖片的功能了，想不到現在 QPainter 也能如法炮製。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好像大部分 Widget 都能用這個方式截圖，不過 OpenGL 不知道可不可行。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
fileName, sub = QFileDialog.getSaveFileName(self, 'Save file...', '../', 'PNG file(*.png)')
if fileName:
    fileName = fileName.replace(".png", "")
    fileName += ".png"
    pixmap = self.mplWindow.grab()
    pixmap.save(fileName)
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;模擬功能&lt;/h1&gt;
&lt;p&gt;主要關鍵都在 Drive Shaft （驅動軸）的清單上，太多驅動軸就會有很多組解，可能要慢慢代入；活塞部份還沒想到怎做。&lt;/p&gt;
&lt;p&gt;期望模擬的部份有如下效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;畫出機構運動時指定點（可複數）路徑，路徑可以用線條或打點的方式繪出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相關動畫的展示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用者觀看自訂角度（滑鼠在圖面上拖拉最佳）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測量工具（指定點距離）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050902.html" rel="alternate"></link><published>2016-09-02T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-02:blog/40323230ri-zhi-1050902.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;改換 Qt 5.7 與 PyQt 5.7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些操作重點&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Qt 5.3 -&amp;gt; 5.7&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Qt 5.8 預計今年11月29日釋出穩定版&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一些繪圖功能需要較高的 Qt 版本才支援，所以選擇升級了當前的函式庫。&lt;/p&gt;
&lt;p&gt;將需要的 Qt 版本載下來，不須舊版的話可以刪掉。&lt;/p&gt;
&lt;p&gt;要切換 Qt 的版本，必須修改之前的 &lt;code&gt;.bashrc&lt;/code&gt; 的目錄至切換的版本，並重新建立 QMake 的軟連結，這樣就可以了（對 C++ 的使用者來說）。&lt;/p&gt;
&lt;pre&gt;
$sudo rm -f /usr/bin/qmake
$sudo ln -s /opt/Qt/5.7/gcc_64/bin/qmake /usr/bin/qmake
&lt;/pre&gt;

&lt;p&gt;但是對其他語言的使用者來說，必須將接口套件的設定一起切換版本，所以得重新安裝 Python 的 PyQt（亦或 PySide）。&lt;/p&gt;
&lt;p&gt;使用下列指令刪除 PyQt：&lt;/p&gt;
&lt;pre&gt;
$sudo rm -r -f /usr/lib/python3/dist-packages/PyQt5
&lt;/pre&gt;

&lt;p&gt;然後從&lt;a href="https://riverbankcomputing.com/software/pyqt/download5" title="riverbankcomputing.com"&gt;官方載點&lt;/a&gt;下載 Linux 版本。&lt;/p&gt;
&lt;p&gt;照著之前的範例重新安裝 PyQt、QScintilla2、Eric6，並修改 Eric6 的相關設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CAdFahb.png" &gt;&lt;/p&gt;
&lt;p&gt;裝完後，若 Eric 安裝時出現版本過低的狀況，就必須完全刪除 PyQt 再重新安裝。&lt;/p&gt;
&lt;p&gt;若是出現缺少一些套件的狀況，請使用 &lt;code&gt;apt-get&lt;/code&gt; 下載安裝，相關名稱如下網站所示。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://packages.ubuntu.com/search?keywords=python3-pyqt5" title="packages.ubuntu.com"&gt;http://packages.ubuntu.com/search?keywords=python3-pyqt5&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;安裝後檢查&lt;/h1&gt;
&lt;p&gt;即使安裝完成，都能啟動或匯入相關套件，因為是重新安裝，還是得檢查一下是否載到舊版的檔案。&lt;/p&gt;
&lt;p&gt;在 Python3 的直譯器中檢查：&lt;/p&gt;
&lt;pre&gt;
&gt;&gt;&gt;from PyQt5.QtCore import qVersion
&gt;&gt;&gt;print("Qt Version: {0}".format(qVersion.strip()))
#顯示 Qt 版本

&gt;&gt;&gt;from PyQt5.QtCore import PYQT_VERSION_STR as pyqtVersion
&gt;&gt;&gt;print("PyQt Version:", pyqtVersion.strip())
#顯示 PyQt 版本
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/MBTakmh.png" &gt;&lt;/p&gt;
&lt;p&gt;在 Eric6 的 Settings -&amp;gt; Show extermal tools 選項中，載入所有相關的工具版本。&lt;/p&gt;
&lt;p&gt;下圖中的 Qt 工具版本均要一致，選擇的部份是 PyQt，非常重要，因為和 Python 中顯示的版本是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KtevLeH.png" &gt;&lt;/p&gt;
&lt;p&gt;另一個就是觀察 Qt 附的相關工具，不過只要載對版本應該都是對的，僅供參考。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rbnu8Gy.png" &gt;&lt;/p&gt;
&lt;p&gt;新版的 Qt 工具也會支援新功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nyrxK7y.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;稍微看過上次範例倉儲的程式碼，QPainter 是可以和 QOpenGL 的元件組合使用的，不過如果直接插入空的圖形化元件，會造成程式視窗內黑屏，應該要另外設定。&lt;/p&gt;
&lt;p&gt;新版的 Qt 支援 OpenGL3D 的嵌入，會找一些範例，作到和之前 bokeh 套件相仿的功能，再把其他運算功能補齊（或許之後會做銜接其他 CAD 軟體的格式），本機解題+繪圖專案就完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LuIz34p.png" &gt;
&lt;img src="http://i.imgur.com/tKoNPIx.png" &gt;&lt;/p&gt;
&lt;p&gt;專題在 Python Solvespace 的部份在想要如何結構化，因為尚未圖形化的編譯部份比較難呈現，如果將現成的程式理論搬上報告又有點太「資訊系」和發散了些。&lt;/p&gt;
&lt;p&gt;預計報告中會包含一部分原版 Solvespace 的解說，還有 SWIG 相關的原始碼呈現。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050901.html" rel="alternate"></link><published>2016-09-01T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-01:blog/40323230ri-zhi-1050901.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些 QPainter 及 OpenGL 的資料連結&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;今天花時間在整修細節的部份（包括讀寫檔和繪圖時機），所以只有暫時將 matplotlib 的畫布隱藏到參數 &lt;code&gt;-mpl&lt;/code&gt; 裡。&lt;/p&gt;
&lt;p&gt;想要用 matplotlib 繪圖時要加上上述參數，不然只會使用 QPainter 的 Widget。&lt;/p&gt;
&lt;p&gt;不過這個地方還沒做好，還沒研究 QPainter 上的細節。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uX1kSGK.png" &gt;&lt;/p&gt;
&lt;p&gt;另外將 crank_rocker 範例存成 Pyslvs 可用的 CSV 表格，可以隨時讀進來 Demo。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ulsX1Jl.png" &gt;&lt;/p&gt;
&lt;p&gt;至於繪圖時機，採用的是 resizeEvent，當偵測到 Widget 大小改變時會觸發。&lt;/p&gt;
&lt;p&gt;原先想使用 paintEvent，但是不知道為何改用在主視窗後就會一直重新整理，很吃資源，所以只好改用相近的 resizeEvent。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;QPainter 及 OpenGL 參考資料&lt;/h1&gt;
&lt;p&gt;官方 Qt 文件： &lt;a href="http://doc.qt.io/qt-5/qpainter.html" title="doc.qt.io"&gt;http://doc.qt.io/qt-5/qpainter.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenGL 範例： &lt;a href="https://github.com/baoboa/pyqt5/tree/master/examples/opengl" title="github.com"&gt;https://github.com/baoboa/pyqt5/tree/master/examples/opengl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還沒深入看過介紹，只看過一些簡單的 QPainter 範例。&lt;/p&gt;
&lt;p&gt;另外 PyQt5 的 QOpenGLWidget 要另外安裝：&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install python3-pyqt5.qtopengl
$sudo apt-get install libqt5opengl5
&lt;/pre&gt;

&lt;p&gt;不過安裝套件一直有麻煩，已經是最新版可是 import 還是找不到，在想是不是安裝位置問題。&lt;/p&gt;
&lt;p&gt;網際應用程式方面只查到 PHP 與 OpenGL 整合的範例，Qt 的部份貌似只能在本機端執行。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050831.html" rel="alternate"></link><published>2016-08-31T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-31:blog/40323230ri-zhi-1050831.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 繪圖功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;畫布嵌入&lt;/h1&gt;
&lt;p&gt;成功嵌入畫布，使用另一個繼承自 &lt;code&gt;matplotlib&lt;/code&gt;.&lt;code&gt;backends&lt;/code&gt;.&lt;code&gt;backend_qt5agg&lt;/code&gt;.&lt;code&gt;FigureCanvasQTAgg&lt;/code&gt;（更名為&lt;code&gt;FigureCanvas&lt;/code&gt;）的 class 函式 &lt;code&gt;DynamicMplCanvas&lt;/code&gt;來繪製點座標。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lRrnk7z.png" &gt;&lt;/p&gt;
&lt;p&gt;這個 class 只包含三個功能，初始化圖形、清除畫布、更新畫布。&lt;/p&gt;
&lt;p&gt;而在主視窗的 &lt;code&gt;__init__&lt;/code&gt; 中初始在預設的 Layout 中嵌入一個 Widget（名稱為「mplWindow」），複製 &lt;code&gt;DynamicMplCanvas()&lt;/code&gt; 的格式來用。&lt;/p&gt;
&lt;p&gt;當初 &lt;code&gt;DynamicMplCanvas()&lt;/code&gt; 是參考自網站範例：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html" title="matplotlib.org"&gt;http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;後來改寫成可以匯入表格代參數的功能。&lt;/p&gt;
&lt;p&gt;目前畫布只有支援繪製節點、連桿和呆鍊，以下是繪製未約束的呆鍊。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XZfsLGI.png" &gt;&lt;/p&gt;
&lt;p&gt;而另外也修正一些程式庫帶入重疊點的問題，會自動增加偏移量。&lt;/p&gt;
&lt;p&gt;表格在畫布重新繪製時也會作修改，重新繪製的功能目前是&lt;em&gt;手動的&lt;/em&gt;，所以還待改進。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050830.html" rel="alternate"></link><published>2016-08-30T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-30:blog/40323230ri-zhi-1050830.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;寫了算點程式（&lt;code&gt;calculation.py&lt;/code&gt;）的雛型，目前只 &lt;code&gt;print&lt;/code&gt; 出來結果，還沒直接寫進表格。&lt;/p&gt;
&lt;p&gt;而以後模擬的路徑座標功能會寫在同個檔案裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SIZhCiM.png" &gt;&lt;/p&gt;
&lt;p&gt;由於 Python 在記憶體中的物件名稱不能撞名，所以如果是用 launch 腳本來帶動整個程式執行的話，若其中有部件互相 &lt;code&gt;import&lt;/code&gt; ，會造成暫存檔重疊而無法載入，這種方法只適用啟動一端的腳本。&lt;/p&gt;
&lt;p&gt;所以在 class 中寫了一條指令 &lt;code&gt;Reload_Canvas&lt;/code&gt;，讓它將表格物件代入 &lt;code&gt;calculation.py&lt;/code&gt; 的 &lt;code&gt;table_process&lt;/code&gt; 中，回傳點座標的 list 回來。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reload_Canvas&lt;/code&gt; 打算也會有判斷 Solve 成功或失敗的功能，會跳出警告，亦不會覆寫到原本的表格上。&lt;/p&gt;
&lt;p&gt;程式碼大約的樣子：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ayh1BHm.png" &gt;&lt;/p&gt;
&lt;p&gt;執行結果（加入 Point2 後回傳第三組點座標）：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/o8iA22K.png" &gt;&lt;/p&gt;
&lt;p&gt;目前加入 Link 的表單，約束距離的功能正常。&lt;/p&gt;
&lt;p&gt;不過碰到無法對重合點作距離約束的情況，可能要提前作座標修正（增加間隙）。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Reload_Canvas 函式應當是在表格增刪或是編輯後執行，不過如果顯示失敗的話相當麻煩，可能之後會做1步復原功能之類的。&lt;/p&gt;
&lt;p&gt;而繪圖功能比較沒那麼繁瑣，會拖比較後面。&lt;/p&gt;
&lt;p&gt;隔天要回虎尾搬遷宿舍，所以能利用時間較少，預計下午後做好 &lt;code&gt;table_process&lt;/code&gt; 整體功能，包括座標修正的判斷。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050829.html" rel="alternate"></link><published>2016-08-29T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-29:blog/40323230ri-zhi-1050829.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQLite 資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;新增一個類似活塞／彈簧的連結器，可以自訂最大和最小拉伸長度。&lt;/p&gt;
&lt;p&gt;造型方面應該只會改線段顏色。&lt;/p&gt;
&lt;p&gt;不過不知道程式方面怎寫，因為程式庫中沒有類似約束，可能要寫在外部，帶入最大值／最小值／範圍內（不須約束）的結果。&lt;/p&gt;
&lt;p&gt;至於彈簧的彈性效果可能作不太出來，所以目前是朝活塞桿設計。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uZrfXYx.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;SQLite 資料庫&lt;/h1&gt;
&lt;p&gt;上網找了一些有關寫入寫出 Data Base 的範例，主要是 Python 官方的解說。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/sqlite3.html" title="docs.python.org"&gt;https://docs.python.org/3.4/library/sqlite3.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.runoob.com/sqlite/sqlite-python.html" title="runoob.com"&gt;http://www.runoob.com/sqlite/sqlite-python.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/UwwvSQ5.png" &gt;&lt;/p&gt;
&lt;p&gt;不過主要還是研究 peewee 套件的功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.peewee-orm.com/en/latest/peewee/quickstart.html" title="docs.peewee-orm.com"&gt;http://docs.peewee-orm.com/en/latest/peewee/quickstart.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;peewee 的用法比較直覺化一些，畢竟不用對 C++ 資料庫下指令。&lt;/p&gt;
&lt;p&gt;不過上網找了一下 FreeCAD 的技術文件，沒有提到關於 Data Base 如何匯入 2D 圖形的解說，只有模擬材料表的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.freecadweb.org/wiki/index.php?title=Material" title="freecadweb.org"&gt;http://www.freecadweb.org/wiki/index.php?title=Material&lt;/a&gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050828.html" rel="alternate"></link><published>2016-08-28T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-28:blog/40323230ri-zhi-1050828.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試程式庫能否支援 Python 的 list 型態&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;旋轉軸及滑塊清單&lt;/h2&gt;
&lt;p&gt;和點、連桿、呆鍊一樣都有增刪功能，不過還沒支援右鍵選單。&lt;/p&gt;
&lt;p&gt;一些細節也可能還沒做好，需要一些時間修正。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rWzmiDc.png" &gt;&lt;/p&gt;
&lt;h2&gt;CSV 匯出入功能調整&lt;/h2&gt;
&lt;p&gt;現在可以支援匯出整個工作簿存檔，並能完整載入所有表格。&lt;/p&gt;
&lt;p&gt;意味著可以保留工作階段而不會遺失。&lt;/p&gt;
&lt;p&gt;在每個表格間插入的是 &lt;code&gt;Next_table&lt;/code&gt; 這個欄位來辨識。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/obOpMJz.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;算點程式測試&lt;/h1&gt;
&lt;p&gt;打算使用 Python 的 list 來存 SLVS 程式庫的 &lt;code&gt;Point&lt;/code&gt; 或 &lt;code&gt;Line&lt;/code&gt;，對迴圈的相性比較好。&lt;/p&gt;
&lt;p&gt;所以建立了一個清單物件 &lt;code&gt;draw&lt;/code&gt;，來測試看看能不能存入後提出來給約束函式用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IoRqjaT.png" &gt;&lt;/p&gt;
&lt;p&gt;結果是可行的。&lt;/p&gt;
&lt;p&gt;上面測試寫法有點累贅，應該直接用 &lt;code&gt;draw += [Point]&lt;/code&gt; 加入清單就可以了。&lt;/p&gt;
&lt;p&gt;這樣支援迴圈讀取就十分不錯了，只是在 &lt;code&gt;import&lt;/code&gt; 的部份還需要另外測試。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050827.html" rel="alternate"></link><published>2016-08-27T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-27:blog/40323230ri-zhi-1050827.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linkage 的參考心得&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;運動約束類型&lt;/h1&gt;
&lt;p&gt;打算使用主動旋轉軸和滑塊用在繪製動態圖或是移動路徑上。&lt;/p&gt;
&lt;p&gt;旋轉軸可以在定義的角度範圍中旋轉，滑塊則是一個被約束在直線上的點（至於滑動範圍不知道程式庫是否能辦得到）。&lt;/p&gt;
&lt;p&gt;在模擬選項中可以調整：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;靜態移動 - 所有旋轉軸待在某個角度時，整體機構的外觀狀態。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移動路徑 - 指定一點位置，轉動所有旋轉軸（或自訂），畫出移動路徑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前旋轉軸和滑塊的新增方式都和其他實體一樣。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;字型大小&lt;/h1&gt;
&lt;p&gt;系統會因為字型大小的問題而跑出外框，只能調整多一點的空間給太大的字。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mE1vIkO.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Linkage&lt;/h1&gt;
&lt;p&gt;參考了技術手冊的介紹和使用說明，Linkage 有一些滿複雜的功能，也支援彈簧計算之類的。&lt;/p&gt;
&lt;p&gt;應該能夠在 Pyslvs 中加入一些值得使用的優點，不過實作性要先評估。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050826.html" rel="alternate"></link><published>2016-08-26T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-26:blog/40323230ri-zhi-1050826.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些後續寫法想法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;圖層統整&lt;/h1&gt;
&lt;p&gt;重新編排了圖層，以在縮放視窗時還能對齊調整大小，不過空間判定上還需要調整參數，才能達到理想的結果。&lt;/p&gt;
&lt;p&gt;另外有研究下 PyQt 嵌入 matpoltlib 繪圖的資料，大約知道該如何嵌入繪出的結果了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DyQCMsS.png" &gt;&lt;/p&gt;
&lt;h2&gt;右鍵選單&lt;/h2&gt;
&lt;p&gt;嘗試寫了表格的右鍵選單，功能等同於叫出新增、刪除和編輯的對話方塊。&lt;/p&gt;
&lt;p&gt;不過位置無法置中，參數可能還要看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Qdu2JpG.png" &gt;&lt;/p&gt;
&lt;h2&gt;從屬項目刪除&lt;/h2&gt;
&lt;p&gt;刪除點時會將包含這個點的連桿或呆鍊一起刪除。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/viCG92Z.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;程式結構&lt;/h1&gt;
&lt;p&gt;之後大約會將 import 程式庫的程式碼放在 &lt;code&gt;main.py&lt;/code&gt; 同層的資料夾下，互相載入。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;main.py&lt;/code&gt; 中會有一個專門的 def 放在主視窗的 class 外，好讓算點的程式可以讀表格的資料。&lt;/p&gt;
&lt;p&gt;以下是原始碼結構，括弧中還待建構。&lt;/p&gt;
&lt;pre&gt;
Pyslvs
    launch_pyslvs.py（啟動檔）
    icons_rc.py（圖示資源）
    +icons（讀取用圖示）
    +core
        main.py（主程式-待加入）
        （算點程式.py）
        slvs.py
        _slvs.so
        libslvs.so
        +draw（繪圖表管理視窗-已完成）
        +info（提示與說明視窗-待加入）
        +warning（警告視窗-待加入）
        +（模擬表管理視窗）
        +（一些給使用者的設定檔）
&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;今天由於花了些時間更新 Ubuntu 版的顯示卡驅動，所以拖了一些時間。&lt;/p&gt;
&lt;p&gt;之後會快點將核心的算點功能做好。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/24</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050824.html" rel="alternate"></link><published>2016-08-24T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-24:blog/40323230ri-zhi-1050824.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;新增了管理物件（點、連線、呆鍊）的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ItXXzqt.png" &gt;&lt;/p&gt;
&lt;h2&gt;刪除物件&lt;/h2&gt;
&lt;p&gt;在選單中選取名稱即可刪除。&lt;/p&gt;
&lt;p&gt;不過還沒為刪除點的連帶影響作調整。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/83q2bA7.png" &gt;&lt;/p&gt;
&lt;h2&gt;編輯物件&lt;/h2&gt;
&lt;p&gt;可以重新複寫物件的狀態而不用刪除。&lt;/p&gt;
&lt;p&gt;包括重新調整點的位置和固定狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IUbVmBj.png" &gt;&lt;/p&gt;
&lt;h2&gt;點外觀&lt;/h2&gt;
&lt;p&gt;紀錄點的外觀，包括用環圈起來，並能讓使用者直接調整其大小和顏色。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pVwY0sP.png" &gt;&lt;/p&gt;
&lt;h2&gt;CSV匯入功能&lt;/h2&gt;
&lt;p&gt;後來有把匯出功能調整一下，可以用 &lt;code&gt;Fixed&lt;/code&gt; 和 &lt;code&gt;noFixed&lt;/code&gt; 紀錄點的固定狀態了。&lt;/p&gt;
&lt;p&gt;所以在讀值時，可以將每列的物件精準填入點的列表中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qL1OB6X.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;因為要讓其他 &lt;code&gt;.py&lt;/code&gt; 檔讀值，又要回傳回 &lt;code&gt;main.py&lt;/code&gt; 中，想要可以浮動創造 Point 並新增約束的功能，所以在思考執行的可行性。&lt;/p&gt;
&lt;p&gt;有嘗試過兩個檔案互相 &lt;code&gt;import&lt;/code&gt;，不過出錯的機率很大，上網尋找的建議是 import 兩邊的檔名就好，需要該物件才會特別指定。&lt;/p&gt;
&lt;p&gt;也就是說直接指定 def 或 class 就會出錯，之後會試試看。&lt;/p&gt;
&lt;p&gt;想要找一個比較保險的方式計算，不然只能盡量避開會衝突的地方。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/23</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050823.html" rel="alternate"></link><published>2016-08-23T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-23:blog/40323230ri-zhi-1050823.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;Pyslvs 的界面大致上完成，表單的增加功能都寫好了。&lt;/p&gt;
&lt;h2&gt;主界面&lt;/h2&gt;
&lt;p&gt;右側打算作為繪圖區，只要左邊表單有更動就會更新。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6X6JNKO.png" &gt;&lt;/p&gt;
&lt;h2&gt;增加線條選單&lt;/h2&gt;
&lt;p&gt;讀取既有兩點來規定距離，若為重複點或是點的數目不足就會警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RpYilrT.png" &gt;&lt;/p&gt;
&lt;h2&gt;增加呆鍊選單&lt;/h2&gt;
&lt;p&gt;只能新增三角形呆鍊，不過以解連桿的工具而言，三角形呆鍊已經夠實用。&lt;/p&gt;
&lt;p&gt;同樣會在違反規則時警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/m9a1JTe.png" &gt;&lt;/p&gt;
&lt;h2&gt;匯出CSV能力&lt;/h2&gt;
&lt;p&gt;成功撰寫將點座標匯出成CSV的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zziWbkn.png" &gt;&lt;/p&gt;
&lt;p&gt;在其他工作表軟體的匯入畫面。&lt;/p&gt;
&lt;p&gt;以後會在動態模擬那裡針對點座標作相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Unis1dy.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;大部分的功能由於都沒接觸過，每換一種元件都要上網搜尋它們取值、設值的用法，Qt 的相關介紹又都是以 C++ 撰寫的，為此研究了一下 Python 物件導向的說明。&lt;/p&gt;
&lt;p&gt;由於再過 2 天就要回去家裡了，所以會盡量將需要整合的工作完成，回去後仍會繼續整理資料。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050821.html" rel="alternate"></link><published>2016-08-21T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-21:blog/40323230ri-zhi-1050821.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo editor 輸入法問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;目前編譯的圖形化界面使用常見的功能表做命令設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6iqBDFs.png" &gt;&lt;/p&gt;
&lt;p&gt;不過只有外表，實際功能還需要連結。&lt;/p&gt;
&lt;p&gt;目前只有控制視窗縮放，結束執行，連結說明網頁的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Leo Editor&lt;/h1&gt;
&lt;p&gt;自從安裝過新版的 Qt 5.3 和 5.7 後 Leo Editor 就怪怪的，無法切換英文以外的輸入法，啟動時 Leo Editor 是使用 5.3 版。&lt;/p&gt;
&lt;p&gt;而使用 Python 2 啟動是使用 Qt 4，所以沒這個問題，但是就無法使用 Pelican。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050820.html" rel="alternate"></link><published>2016-08-20T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-20:blog/40323230ri-zhi-1050820.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 eric 6 成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖形介面計畫：Pyslvs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Eric 6&lt;/h1&gt;
&lt;p&gt;透過一些安裝教學的資料，成功將 Eric 6.1.8 安裝於 Ubuntu 上。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/idber/article/details/40076821" title="blog.csdn.net"&gt;http://blog.csdn.net/idber/article/details/40076821&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/t7NXOkq.png" &gt;&lt;/p&gt;
&lt;p&gt;不過由於安裝位置及主程式運作的關係，執行時必須給予 Root 權限。&lt;/p&gt;
&lt;pre&gt;
$sudo  eric6
&lt;/pre&gt;

&lt;p&gt;若是沒給予權限，會造成 Eric 顯示一系列錯誤後關閉。&lt;/p&gt;
&lt;p&gt;而透過 Eric 建立的目錄，會被轉為 Root 的所有權，所以必須改回給其他使用者使用。&lt;/p&gt;
&lt;pre&gt;
$sudo chmod -c 777 目錄名稱
mode of ‘目錄名稱’ changed from 0755 (rwxr-xr-x) to 0777 (rwxrwxrwx)
&lt;/pre&gt;

&lt;p&gt;目前還在摸索 Qt 相關的教學，發現有許多自訂功能，包括圖示界面和呼叫傳輸之類，稍作了解應該就能達成相關效果。&lt;/p&gt;
&lt;p&gt;Eric 的語言問題在於外部程式（Qt 設計師之類的），會偵測系統語言作變更，但是主程式卻不會如此，所以本體改成英文後，附屬的程式仍然是繁體中文。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Xv34qIx.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Pyslvs&lt;/h1&gt;
&lt;p&gt;將圖形化包裝的 Python Solvespace 程式暫定名為 Pyslvs，如果覺得定名不妥就之後再變更。&lt;/p&gt;
&lt;p&gt;當界面有基本雛型之後會上傳至倉儲，之後會陸續更新表單按鈕的功能連結。&lt;/p&gt;
&lt;p&gt;Pyslvs 目前在 Ubuntu 系統上開發，因為 Ubuntu 目前好像沒有一個如 Linkage 之類的模擬程式，使用 LibreCAD 或是 FreeCAD 又會太佔資源，所以想做這個工具給 Ubuntu 系統用。&lt;/p&gt;
&lt;p&gt;剛開始評估的困難點可能是如何呈現 2D 圖形在 Qt 界面上吧。其他如輸出成程式碼之類的應該用普通的 &lt;code&gt;.py&lt;/code&gt; 程式就能辦到了。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050819.html" rel="alternate"></link><published>2016-08-19T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-19:blog/40323230ri-zhi-1050819.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;紀錄 GCC 和 CMake 在 Ubuntu 上安裝的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紀錄 Ubuntu 網誌編譯環境&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;為推廣學員使用 Ubuntu 作業系統，紀錄一些安裝軟體的方式。&lt;/p&gt;
&lt;p&gt;紀錄如何建構 Ubuntu (ezgo) 的作業環境。&lt;/p&gt;
&lt;p&gt;官方版本的 Ubuntu 更新較快，已經到了 &lt;code&gt;16.04&lt;/code&gt;，教育部的 ezgo 使用 Ubuntu 14.04，使用上較多推薦工具，不用再自己尋找，不過也會安裝一些可能不會用到的套件。&lt;/p&gt;
&lt;p&gt;目前使用感想是 ezgo 的 KDE 界面還滿方便的，終端機能提供比 Windows 更多的功能，而且硬體支援度非常良好，即使使用非官方驅動程式，運作甚至會比任何版本的 Windows 更加流暢。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;GNU 工具&lt;/h1&gt;
&lt;p&gt;完整版的 ezgo 預設沒有安裝 g++，使用精簡版的 Ubuntu 亦必須自己安裝這兩套編譯工具。&lt;/p&gt;
&lt;p&gt;使用下列指令安裝 GCC。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install gcc
$sudo apt-get install g++
&lt;/pre&gt;

&lt;p&gt;使用下列指令安裝 CMake，不過由於提供者版本的問題，可以稍候安裝。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install cmake
&lt;/pre&gt;

&lt;p&gt;在沒使用其他提供者的情況下，gcc 的最新版本只會到 &lt;code&gt;4.9&lt;/code&gt;，所以想安裝 gcc 5.0 以上的版本，必須加入信任來源。&lt;/p&gt;
&lt;p&gt;同樣地，在沒使用其他提供者的情況下，CMake 的最新版本無法到 &lt;code&gt;3.x&lt;/code&gt;，也要另一個信任來源。&lt;/p&gt;
&lt;p&gt;加入信任來源後，使用 &lt;code&gt;apt-get update&lt;/code&gt; 指令或是圖形界面的 Ubuntu 管理中心時，就會將你的提供者也加入搜尋。&lt;/p&gt;
&lt;pre&gt;
$sudo add-apt-repository ppa:ubuntu-toolchain-r/test #gcc 的提供者
$sudo add-apt-repository ppa:george-edison55/cmake-3.x #cmake 的提供者
$sudo apt-get update
$sudo apt-get install gcc-5
$sudo apt-get install g++-5
$sudo apt-get install cmake
&lt;/pre&gt;

&lt;p&gt;這時只能使用 &lt;code&gt;gcc-5&lt;/code&gt; 指令啟動 gcc 5.x，使用一般的 &lt;code&gt;gcc&lt;/code&gt; 指令只會啟動最新的 &lt;code&gt;4.x&lt;/code&gt; 的版本。&lt;/p&gt;
&lt;p&gt;因此必須將指令連結過去。&lt;/p&gt;
&lt;pre&gt;
$alias gcc='gcc-5'
$alias g++='g++-5'
&lt;/pre&gt;

&lt;p&gt;下圖是完成畫面，用 &lt;code&gt;gcc --version&lt;/code&gt; 指令來檢查編譯器的版本（g++ 的版本應該也會相同）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/8Di87en.png" &gt;&lt;/p&gt;
&lt;p&gt;附註：想移除提供者也很簡單，只要加上 &lt;code&gt;--remove&lt;/code&gt; 參數就行。&lt;/p&gt;
&lt;pre&gt;
$sudo add-apt-repository --remove ppa:提供者來源
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;Leo Editor&lt;/h1&gt;
&lt;p&gt;注意：Leo Editor 在 Python 3.5 中的 Pelican 會產生錯誤，所以請使用 Python 3.4 以下的 Python3 版本。&lt;/p&gt;
&lt;p&gt;使用下列指令從官方倉儲下載 Leo Editor。&lt;/p&gt;
&lt;pre&gt;
$cd "安裝位置"
$git clone https://github.com/leo-editor/leo-editor.git
&lt;/pre&gt;

&lt;p&gt;直接使用下列指令啟動 Leo Editor。&lt;/p&gt;
&lt;p&gt;啟動後如果關閉這個終端機，將會結束 Leo Editor，請注意是否有存檔。&lt;/p&gt;
&lt;pre&gt;
$cd "安裝位置"/leo-editor
$python3 launchLeo.py
&lt;/pre&gt;

&lt;p&gt;寫網誌的必要週邊模組：&lt;/p&gt;
&lt;pre&gt;
$sudo pip3 install pelican -U
$sudo pip3 install markdown -U
$sudo pip3 install bs4 -U
&lt;/pre&gt;

&lt;p&gt;圖中是 Leo 5.3 的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7VA7EXg.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;未來若有必要軟體的特殊安裝方式，會更新在此。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050818.html" rel="alternate"></link><published>2016-08-18T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-18:blog/40323230ri-zhi-1050818.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;glibc 版本問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;GLIBC&lt;/h1&gt;
&lt;p&gt;編譯好的 CentOS 版程式庫放入 Openshift 後，回傳了錯誤：&lt;/p&gt;
&lt;pre&gt;
libc.so.6: version `GLIBC_2.14' not found
&lt;/pre&gt;

&lt;p&gt;是執行系統的 GLIBC 版本較舊所引起的，最簡單的解決方法是升級執行系統的 GLIBC，但是不知道如何命令 Openshift 的倉儲升級。&lt;/p&gt;
&lt;p&gt;用指令檢查了一下虛擬機上的 GLIBC 版本，是 &lt;code&gt;2.17&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6JSlDKG.png" &gt;&lt;/p&gt;
&lt;p&gt;不過 gcc 應該用了 &lt;code&gt;2.14&lt;/code&gt; 做編譯，而 Openshift 的版本沒到 &lt;code&gt;2.14&lt;/code&gt; 所致。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天在 &lt;code&gt;python.log&lt;/code&gt; 注意到 Openshift 使用的 Python 版本是 3.3.2，所以剛開始懷疑是小版號不合所致，但是並非如此。&lt;/p&gt;
&lt;p&gt;從官方的連結下載了 GLIBC &lt;code&gt;2.14&lt;/code&gt; 版：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ftp.gnu.org/gnu/glibc/" title="ftp.gnu.org"&gt;http://ftp.gnu.org/gnu/glibc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上網找到的方法大約都是要執行端主機下命令，但是不知道如何對 Openshift 做出要求，所以先在編譯用的虛擬機做調整。&lt;/p&gt;
&lt;p&gt;但是不知道如何在同一台電腦上取代或是安裝兩個版本的 GLIBC，而虛擬機的效能還滿不彰的。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050817.html" rel="alternate"></link><published>2016-08-17T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:blog/40323230ri-zhi-1050817.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;距離約束 Bug 解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;slvs_python.hpp&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tl8Nkk3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 標頭檔，讓 value 的值等於 0 時自動轉換成重合約束。&lt;/p&gt;
&lt;p&gt;不過點與線的重合約束還沒調整，稍後會做更新。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;CentOS 編譯&lt;/h1&gt;
&lt;p&gt;在 CentOS 上重新編譯 Python 3.3，在執行configure時添加了 &lt;code&gt;--enable-shared&lt;/code&gt; 參數，這樣make時會產生可用的共享資料庫 &lt;code&gt;libpython3.3m.so&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2d8tkYE.png" &gt;&lt;/p&gt;
&lt;p&gt;另外還把 Makefile 修正到 Python 3.3 的 &lt;code&gt;include&lt;/code&gt; 和共享資料庫的目錄。&lt;/p&gt;
&lt;p&gt;執行時會找不到 &lt;code&gt;libpython3.3m.so&lt;/code&gt;，可能是 CentOS 的 Python 3.3 是安裝在自訂的位置，所以環境變數沒對到。&lt;/p&gt;
&lt;p&gt;後來想調整，但是虛擬機因為記憶體太少而卡住了，不過 Redhat 的 Python 是原生的，應該是沒問題。&lt;/p&gt;
&lt;p&gt;目前還未搬上 Openshift 測試。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>SLVS 程式庫函式</title><link href="http://project.mde.tw/blog/slvs-cheng-shi-ku-han-shi.html" rel="alternate"></link><published>2016-08-17T12:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:blog/slvs-cheng-shi-ku-han-shi.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slvs&lt;/code&gt;程式庫（&lt;code&gt;_slvs.pyd&lt;/code&gt;或&lt;code&gt;_slvs.so&lt;/code&gt;）轉成Python後的內容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;協助Python程式使用指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;內容待勘誤&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;08/17 更新-錯誤已解決&lt;/em&gt;&lt;/p&gt;


&lt;h1&gt;&lt;strong&gt;快速尋找&lt;/strong&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;a href="#FOREWORD"&gt;簡介&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#CDemo"&gt;CDemo&lt;/a&gt;｜&lt;a href="#SLVS"&gt;程式庫簡介&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#START"&gt;使用基礎&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a href="#ENTITIES"&gt;實體&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#Point"&gt;點&lt;/a&gt;｜&lt;a href="#Workplane"&gt;工作平面&lt;/a&gt;｜&lt;a href="#Distance"&gt;距離&lt;/a&gt;｜&lt;a href="#Normal"&gt;向量法線&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#Line"&gt;線段&lt;/a&gt;｜&lt;a href="#Arc"&gt;中心點弧&lt;/a&gt;｜&lt;a href="#Circle"&gt;完整圓&lt;/a&gt;｜&lt;a href="#Cubic"&gt;貝茲曲線&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#CONSTRAINTS"&gt;約束&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#C-Distance"&gt;距離&lt;/a&gt;｜&lt;a href="#C-Ratio"&gt;線段比值&lt;/a&gt;｜&lt;a href="#C-Diameter"&gt;直徑&lt;/a&gt;｜&lt;a href="#C-Angle"&gt;角度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-On"&gt;重合&lt;/a&gt;｜&lt;a href="#C-Equal"&gt;相等&lt;/a&gt;｜&lt;a href="#C-Dragged"&gt;鎖定位置&lt;/a&gt;｜&lt;a href="#C-Midpoint"&gt;中點&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-Symmetric"&gt;對稱&lt;/a&gt;｜&lt;a href="#C-HV"&gt;水平或垂直&lt;/a&gt;｜&lt;a href="#C-Parallel"&gt;平行&lt;/a&gt;｜&lt;a href="#C-Tangent"&gt;相切&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#ADD"&gt;未支援功能&lt;/a&gt;&lt;/h2&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="FOREWORD"&gt;&lt;/a&gt;Brief Introduction&lt;/h1&gt;
&lt;p&gt;SLVS 程式庫裡面的名稱結構是使用C語言撰寫，雖然 &lt;code&gt;slvs.py&lt;/code&gt; 已經幫忙轉換了裡面的名稱，但是仍有些許函式名稱變化。&lt;/p&gt;
&lt;p&gt;所以紀錄一下在Python中如何使用這些功能，預計讓這篇文章達到易使用和易理解的功能。&lt;/p&gt;
&lt;h2&gt;&lt;a name="CDemo"&gt;&lt;/a&gt;CDemo&lt;/h2&gt;
&lt;p&gt;SolveSpace 是一款開源的 2D / 3D 電腦輔助設計繪圖軟體，從 2008 年釋出第一個版本，相容於 Windows / Mac / Linux 三個平台。&lt;/p&gt;
&lt;p&gt;有著體積小、執行快速、免費，且不用安裝的特性，支援 STEP 或 STL 開啟，或輸出成 DXF 、 PDF 、 SVG 等開放格式，也有自己的文字式格式 &lt;code&gt;*.slvs&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;更新方面，可以在 GitHub 的&lt;a href="https://github.com/solvespace/solvespace" title="github.com"&gt;官方倉儲&lt;/a&gt;或是&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;非官方倉儲&lt;/a&gt;中下載最新的原始碼後，直接利用開發者工具（如 GNU）編譯出主程式。&lt;/p&gt;
&lt;p&gt;Solvespace 在繪圖程式本身外還附帶一個名為 CDemo 的小執行檔，是利用 Solvespace 的原始碼編譯出來的。&lt;/p&gt;
&lt;p&gt;可以利用此外部程式呼叫 Solvespace 的程式庫 &lt;code&gt;libslvs.dll&lt;/code&gt; 進行 2D 或是 3D 的解題運算，而無須啟動 Solvespace 。&lt;/p&gt;
&lt;p&gt;CDemo 的概念是能夠讓外部程式使用 Solvespace 的功能，無論是利用其解開最大行程、干涉位置，都能讓應用程式免去您需要親自使用 CAD 軟體解題的困擾。&lt;/p&gt;
&lt;h2&gt;&lt;a name="SLVS"&gt;&lt;/a&gt;SLVS Library&lt;/h2&gt;
&lt;p&gt;CDemo 為 C 語言編譯而成，使用的 Solvespace 程式庫則是C++編譯的，在運算和使用上固然快速，但活用性較局限。&lt;/p&gt;
&lt;p&gt;Python 語言擁有大量自定義模組、易讀的函式，並且在網際執行方面比C語言多一片天，若將 Solvespace 程式庫轉換使用，將會使這些 Python 程式擁有線上解題的能力，在機械設計方面更是方便許多。&lt;/p&gt;
&lt;p&gt;在 Python 的連結庫中， &lt;code&gt;*.pyd&lt;/code&gt; 和 Windows 中 C 語言的動態載入庫 &lt;code&gt;*.dll&lt;/code&gt; 相仿； &lt;code&gt;*.so&lt;/code&gt; 則是大部分開放式作業系統（如為人熟知的 Ubuntu）使用的。 &lt;code&gt;*.so&lt;/code&gt; 的優點是利於共享資料，執行檔與程式庫分離，更新函式庫更為方便。&lt;/p&gt;
&lt;p&gt;Python-Solvespace 的製作概念是利用 SWIG 軟體製作一個 C++ 至 Python 的端口，使任何一個使用 Anaconda 3 (Python 3.5) 的 Python 程式都能夠使用 Solvespace 的函式庫。&lt;/p&gt;
&lt;p&gt;當 Solvespace 的函式轉換成 Python 介面時，也希望保持這個語言一貫清爽易懂的名稱，因此特別重新分類了這些指令的名稱及用法。&lt;/p&gt;
&lt;p&gt;稱號下方是原始的命令代號，用於程式庫中識別命令的類型。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="START"&gt;&lt;/a&gt;Starting Draw and Solve&lt;/h1&gt;
&lt;p&gt;若要使用SLVS程式庫，必須透過&lt;code&gt;slvs.py&lt;/code&gt;介面來轉換。&lt;/p&gt;
&lt;p&gt;在您的Python程式中使用以下指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#導入slvs.py
from slvs import *

#導入Solid Python
#沒有使用就不需要導入
import solid

#創造你的系統，以及支援單位數量
#預設單位數為50
#若是在迴圈中創造系統，將會重新洗掉記錄
sys = System(20)
...
&lt;/pre&gt;

&lt;p&gt;欲執行解題，Python必須使用下列命令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#執行解題
sys.solve()
#直接命令
Slvs_Solve(sys, g)

#結果回報的值如下
if (sys.result == SLVS_RESULT_OKAY):
    ...
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;在執行解題程式後，會出現三種結果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有約束都能滿足，會回傳&lt;code&gt;SLVS_RESULT_OKAY&lt;/code&gt;，這時就能檢查您的約束結果，沒有完全約束的項目會被移動至滿足條件的範圍中，不過可能會不符合您的期待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解題程式證明約束條件互相牴觸，會傳回&lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解題程式證明約束條件沒有互相牴觸，但定義了一些重複的約束，會傳回&lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後能調用以下值來檢查結果。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#實體結果
#格式為高精度浮點數
sys.get_param(0).val
&lt;/pre&gt;

&lt;p&gt;而過於嚴重的錯誤會回傳&lt;code&gt;SLVS_RESULT_TOO_MANY_UNKNOWNS&lt;/code&gt;，必須檢查您的 Python 程式庫或是 SLVS 函式庫是否損壞。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ENTITIES"&gt;&lt;/a&gt;Types of Entities&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_E&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;實體的類型，屬於物件的部分，Entity中還有一些子分類。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Point&lt;/kbd&gt; 此物件屬於點。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;LineSegment&lt;/kbd&gt; 此物件屬於線段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; 此物件屬於圓弧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;沒有標籤的項目屬於 &lt;kbd&gt;Entity&lt;/kbd&gt; 旗下的物件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根據這些關係，在約束時必須判斷其分類以填入。&lt;/p&gt;
&lt;p&gt;輸入值後方加入&lt;code&gt;, sys&lt;/code&gt;，以傳入系統清單&lt;code&gt;sys&lt;/code&gt;中（也許有&lt;code&gt;sys2&lt;/code&gt;或&lt;code&gt;sys3&lt;/code&gt;等等）；亦可用&lt;code&gt;sys.add_&lt;/code&gt;加入以下支援的實體，而取出的編號取決於註冊的順序。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_param( )
add_point2d( )
add_point3d( )
add_entity( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;取出時亦同（函數中加上編號就能指定）：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_Point2d( )
get_Point3d( )
get_LineSegment2d( )
get_LineSegment3d( )
get_Normal3d( )
get_Distance( )
get_Workplane( )
get_Cubic( )
get_Circle( )
get_ArcOfCircle( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Point"&gt;&lt;/a&gt;Point&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point3d(Param x, Param y, Param z)
&lt;/pre&gt;

&lt;p&gt;代表空間中的點。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point2d(Workplane workplane, Param u, Param v)
&lt;/pre&gt;

&lt;p&gt;代表工作平面上的點。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Normal"&gt;&lt;/a&gt;Normal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Param qw, Param qx, Param qy, Param qz)
&lt;/pre&gt;

&lt;p&gt;代表空間中的一條法線。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt; / &lt;kbd&gt;Normal2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;代表垂直工作平面的一條法線。&lt;/p&gt;
&lt;p&gt;在SolveSpace中，法線是由一個3x3的旋轉矩陣從基本的坐標系到一個新的架構，是由單位四元數定義的。&lt;/p&gt;
&lt;p&gt;可以想像這個四元數代表一個通過原點的平面。&lt;/p&gt;
&lt;p&gt;這個平面跟三個向量相關：基礎向量&lt;code&gt;U&lt;/code&gt;和&lt;code&gt;V&lt;/code&gt;在平面上、而法線&lt;code&gt;N&lt;/code&gt;則垂直它，相當於&lt;code&gt;[ U V N ]'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此U、N、N都有單位長度，而他們都正交，所以：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;U cross V = N
V cross N = U
N cross U = V
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;轉換函式&lt;code&gt;Slvs_Quaternion&lt;/code&gt;提供了在&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;V&lt;/code&gt;、&lt;code&gt;N&lt;/code&gt;和單位四元數之間轉換。&lt;/p&gt;
&lt;p&gt;單位四元數只有三個自由度，但是要在四個參數中指定。因此一個額外的約束產生了，就是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w^2 + x^2 + y^2 + z^2 = 1&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Make a Quaternion for a Work Plane &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;要定義一個由&lt;code&gt;U[1 0 0]&lt;/code&gt;向量（等同X軸）和&lt;code&gt;V[0 1 0]&lt;/code&gt;向量（等同Y軸）組成的平面，是需要一條3D法線的。&lt;/p&gt;
&lt;p&gt;若是不會計算四元數，可以利用下列函式達成：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#函式轉換四元數
qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0)

#帶入3D法線的函式中
normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys)

#做成工作平面
c = Point3d(Param(0.0), Param(0.0), Param(0.0))
plane = Workplane(c, normal)
&lt;/pre&gt;

&lt;p&gt;這個公式在製作2D平面時非常方便。&lt;/p&gt;
&lt;p&gt;以下是不同平面參考：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;XY平面：[1 0 0], [0 1 0]
MakeQuaternion(1, 0, 0, 0, 1, 0)

YZ平面：[0 1 0], [0 0 1]
MakeQuaternion(0, 1, 0, 0, 0, 1)

XZ平面：[1 0 0], [0 0 1]
MakeQuaternion(1, 0, 0, 0, 0, 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Distance"&gt;&lt;/a&gt;Distance&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Distance&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Distance(Workplane wrkpl, Param distance)
&lt;/pre&gt;

&lt;p&gt;代表與工作平面平行的距離。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Workplane"&gt;&lt;/a&gt;Work Plane&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Workplane&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_WORKPLANE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Workplane(Point3d origin, Normal3d normal)
&lt;/pre&gt;

&lt;p&gt;代表通過原點，與法線垂直的工作平面。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Line"&gt;&lt;/a&gt;Line Segment&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_LINE_SEGMENT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment3d(Point3d a, Point3d b)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment2d(Workplane wrkpl, Point2d a, Point2d b)
&lt;/pre&gt;

&lt;p&gt;在兩個&lt;code&gt;Point2d/3d&lt;/code&gt;之間繪出直線條。&lt;/p&gt;
&lt;p&gt;代表兩個點之間的連線。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Cubic"&gt;&lt;/a&gt;Cubic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CUBIC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Cubic&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3)
&lt;/pre&gt;

&lt;p&gt;四個點構成的貝茲曲線，無論是用2D還是3D建構，都會視為3D物件。&lt;/p&gt;
&lt;p&gt;四個點的公式如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;公式（t從0積分到1）
p(t) = P0*(1 - t)^3 + 3*P1*(1 - t)^2*t + 3*P2*(1 - t)*t^2 + P3*t^3&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name="Circle"&gt;&lt;/a&gt;Circle&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;Circle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius)
&lt;/pre&gt;

&lt;p&gt;與一條&lt;code&gt;Normal3d&lt;/code&gt;法線垂直，與一個&lt;code&gt;Workplane&lt;/code&gt;平面平行，由&lt;code&gt;Point2d&lt;/code&gt;圓心和&lt;code&gt;Distance&lt;/code&gt;半徑構成的完整圓。&lt;/p&gt;
&lt;p&gt;這個圓無法使用相切約束，除非給定切點，並使圓心距離永遠和切線保持半徑長度。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Arc"&gt;&lt;/a&gt;Arc of Circle&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_ARC_OF_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;ArcOfCircle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end)
&lt;/pre&gt;

&lt;p&gt;與一條&lt;code&gt;Normal3d&lt;/code&gt;法線垂直，與一個&lt;code&gt;Workplane&lt;/code&gt;平面平行，由&lt;code&gt;Point2d&lt;/code&gt;圓心和兩個&lt;code&gt;Point2d&lt;/code&gt;點構成的三點弧。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="CONSTRAINTS"&gt;&lt;/a&gt;Types of Constrains&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;約束的類型，大部分的指令都會自動判斷狀況。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 此種約束只能用在3D或投影到平面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 此種約束只能用在平面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Val&lt;/kbd&gt; 此種約束必須設定額外的參考值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;輸入值最後端加入群組編號可以規定群組（預設值&lt;code&gt;Slvs_hGroup group = USE_DEFAULT_GROUP&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;約束的直接命令（必須在空白項目中填入 &lt;code&gt;0&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Slvs_MakeConstraint((h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB,  entityC,  entityD, other, other2)
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="C-Distance"&gt;&lt;/a&gt;Distance &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;約束兩個&lt;code&gt;Point2d/3d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PROJ_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;約束兩個&lt;code&gt;Point3d&lt;/code&gt;的投影到&lt;code&gt;Workplane&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PLANE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;從一個&lt;code&gt;Point3d&lt;/code&gt;到一個&lt;code&gt;Workplane&lt;/code&gt;的距離。&lt;/p&gt;
&lt;p&gt;距離值的正負會規定點在平面之上或之下。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_LINE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;從一個&lt;code&gt;Point2d/3d&lt;/code&gt;到一條&lt;code&gt;LineSegment2d/3d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;p&gt;距離值的正負會規定點在線段之上或之下。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-On"&gt;&lt;/a&gt;On&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_POINTS_COINCIDENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;兩個&lt;code&gt;Point2d/3d&lt;/code&gt;的座標相等。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_IN_PLANE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;一個&lt;code&gt;Point3d&lt;/code&gt;會被固定在一個&lt;code&gt;Workplane&lt;/code&gt;上。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;一個&lt;code&gt;Point2d/3d&lt;/code&gt;會被固定在一條&lt;code&gt;LineSegment2d/3d&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;注意此約束會在2D時移除一個自由度；而在3D空間時變成兩個。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_CIRCLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, Circle circle)
&lt;/pre&gt;

&lt;p&gt;一個&lt;code&gt;Point2d&lt;/code&gt;會被固定在一個&lt;code&gt;Circle&lt;/code&gt;上。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Equal"&gt;&lt;/a&gt;Equal&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LENGTH_LINES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;LineSegment2d&lt;/code&gt;的長度等長。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_LEN_PT_LINE_D&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, Point2d p, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;第一條&lt;code&gt;LineSegment2d&lt;/code&gt;長度等於一個&lt;code&gt;Point2d&lt;/code&gt;到第二條&lt;code&gt;LineSegment2d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_PT_LN_DISTANCES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;第一個&lt;code&gt;Point2d&lt;/code&gt;到第一條&lt;code&gt;LineSegment2d&lt;/code&gt;的距離等於第二個&lt;code&gt;Point2d&lt;/code&gt;到第二條&lt;code&gt;LineSegment2d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_angle(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, LineSegment2d line3, LineSegment2d line4)
&lt;/pre&gt;

&lt;p&gt;第一條&lt;code&gt;LineSegment2d&lt;/code&gt;和第二條&lt;code&gt;LineSegment2d&lt;/code&gt;的夾角等於第三條&lt;code&gt;LineSegment2d&lt;/code&gt;和第四條&lt;code&gt;LineSegment2d&lt;/code&gt;的夾角。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LINE_ARC_LEN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line, Circular c)
&lt;/pre&gt;

&lt;p&gt;一條&lt;code&gt;LineSegment2d&lt;/code&gt;線段長度和另一段&lt;code&gt;Circular&lt;/code&gt;長度相等。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_RADIUS&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;Circular&lt;/code&gt;的半徑相等。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SAME_ORIENTATION&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.orientation(Normal3d nrml1, Normal3d nrml2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;Normal3d&lt;/code&gt;法線的方向相等。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Ratio"&gt;&lt;/a&gt;Ratio of Length &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_LENGTH_RATIO&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.ratio(double value, Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;第一條&lt;code&gt;LineSegment2d&lt;/code&gt;長度對上第二條&lt;code&gt;LineSegment2d&lt;/code&gt;長度的比值。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Symmetric"&gt;&lt;/a&gt;Symmetric&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;第一個&lt;code&gt;Point2d/3d&lt;/code&gt;會和第二個&lt;code&gt;Point2d/3d&lt;/code&gt;對稱於一個工作平面。&lt;/p&gt;
&lt;p&gt;意味著兩個點到平面的距離都相等，而兩點的連線可以做為平面的法線。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_HORIZ&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;兩個&lt;code&gt;Point2d&lt;/code&gt;會鎖定在相同的水平座標。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_VERT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;兩個&lt;code&gt;Point2d&lt;/code&gt;會鎖定在相同的垂直座標。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;規定兩個&lt;code&gt;Point2d&lt;/code&gt;，對稱&lt;code&gt;LineSegment2d&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Midpoint"&gt;&lt;/a&gt;Middle point&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_AT_MIDPOINT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;讓一個&lt;code&gt;Point2d/3d&lt;/code&gt;位於一條&lt;code&gt;LineSegment2d&lt;/code&gt;的中點。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-HV"&gt;&lt;/a&gt;Horizontal &amp;amp; Vertical&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_HORIZONTAL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.horizontal(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SLVS_C_VERTICAL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.vertical(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;規定一條&lt;code&gt;LineSegment2d&lt;/code&gt;水平或垂直。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Diameter"&gt;&lt;/a&gt;Diameter &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_DIAMETER&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.diameter(double diameter, Workplane wrkpl, Circular c)
&lt;/pre&gt;

&lt;p&gt;一段&lt;code&gt;Circular&lt;/code&gt;的直徑。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Angle"&gt;&lt;/a&gt;Angle &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.angle(Workplane wrkpl, double value, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;LineSegment2d&lt;/code&gt;的夾角，定義值單位為度。&lt;/p&gt;
&lt;p&gt;公式如下（&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;為兩條線的向量）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(A dot B)/(|A||B|) = cos(valA)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意這裡的值定義比較不明確，無論正負90度都會是相同的結果。&lt;/p&gt;
&lt;p&gt;所以必須使用&lt;code&gt;other&lt;/code&gt;布林值來判斷正負。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PERPENDICULAR&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.perpendicular(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;源自約束&lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這個約束是定義角度約束為90度的情況。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Parallel"&gt;&lt;/a&gt;Parallel&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PARALLEL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(LineSegment3d line1, LineSegment3d line2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;LineSegment2d/3d&lt;/code&gt;互相平行。&lt;/p&gt;
&lt;p&gt;注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Tangent"&gt;&lt;/a&gt;Tangent &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ARC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle arc, LineSegment2d line, bool other)
&lt;/pre&gt;

&lt;p&gt;一段&lt;code&gt;ArcOfCircle&lt;/code&gt;和一條&lt;code&gt;LineSegment2d&lt;/code&gt;相切。&lt;/p&gt;
&lt;p&gt;若布林值是&lt;code&gt;False&lt;/code&gt;，則圓弧的切點會位於它的起點&lt;code&gt;s&lt;/code&gt;；反之若為&lt;code&gt;True&lt;/code&gt;，則會位於它的終點&lt;code&gt;e&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CUBIC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(Cubic c, LineSegment3d l, bool other)
&lt;/pre&gt;

&lt;p&gt;一條&lt;code&gt;Cubic&lt;/code&gt;和一條&lt;code&gt;LineSegment3d&lt;/code&gt;相切。&lt;/p&gt;
&lt;p&gt;若布林值是&lt;code&gt;False&lt;/code&gt;，則貝茲曲線的切點會位於它的起點&lt;code&gt;p0&lt;/code&gt;；反之若為&lt;code&gt;True&lt;/code&gt;，則會位於它的終點&lt;code&gt;p3&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CURVE_CURVE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle c1, ArcOfCircle c2, bool other, bool other2)
Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2)
Constraint.tangent(ArcOfCircle c1, Cubic c2, bool other, bool other2)
Constraint.tangent(Cubic c1, ArcOfCircle c2, bool other, bool other2)
&lt;/pre&gt;

&lt;p&gt;兩條曲線的相切組合。&lt;/p&gt;
&lt;p&gt;若布林值是&lt;code&gt;False&lt;/code&gt;，則圓弧的切點會位於它的起點&lt;code&gt;s&lt;/code&gt;，貝茲曲線的切點會位於它的起點&lt;code&gt;p0&lt;/code&gt;；反之若為&lt;code&gt;True&lt;/code&gt;，則會位於它的終點&lt;code&gt;e&lt;/code&gt;或&lt;code&gt;p3&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Dragged"&gt;&lt;/a&gt;Dragged&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Point3d p)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Workplane wrkpl, Point2d p)
&lt;/pre&gt;

&lt;p&gt;永久鎖定這個&lt;code&gt;Point2d/3d&lt;/code&gt;的座標在目前計算的座標上，再也不會改變。&lt;/p&gt;
&lt;p&gt;在2D平面上，會移除兩個自由度；在3D空間中，是三個自由度。&lt;/p&gt;
&lt;h2&gt;Set Dragged &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;關於鎖定位置，另一個系統的約束如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sys.set_dragged(Point p)
&lt;/pre&gt;

&lt;p&gt;是命令約束盡量固定這個&lt;code&gt;Point2d/3d&lt;/code&gt;點，取而代之的是移動周遭的項目。&lt;/p&gt;
&lt;p&gt;這個點被固定後移動量會較小。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ADD"&gt;&lt;/a&gt;Additional Types of Constrains&lt;/h1&gt;
&lt;p&gt;一些額外的約束條件，目前沒有對應實體項目可用。&lt;/p&gt;
&lt;h2&gt;Point and Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_FACE_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#這個功能尚未建構
&lt;/pre&gt;

&lt;h2&gt;Point on Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_ON_FACE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#這個功能尚未建構
&lt;/pre&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>SLVS Library Functions</title><link href="http://project.mde.tw/blog/slvs-library-functions.html" rel="alternate"></link><published>2016-08-17T12:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:blog/slvs-library-functions.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slvs&lt;/code&gt; library（&lt;code&gt;_slvs.pyd&lt;/code&gt;or &lt;code&gt;_slvs.so&lt;/code&gt;）for Python.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Retrieve for Python Programing Design.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Content to be amended&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;08/17 Updated&lt;/em&gt;&lt;/p&gt;


&lt;h1&gt;&lt;strong&gt;Quick Search&lt;/strong&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;a href="#FOREWORD"&gt;Brief introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#CDemo"&gt;CDemo&lt;/a&gt;｜&lt;a href="#SLVS"&gt;SLVS Library&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#START"&gt;How to start&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a href="#ENTITIES"&gt;Entities&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#Point"&gt;Point&lt;/a&gt;｜&lt;a href="#Workplane"&gt;Work Plane&lt;/a&gt;｜&lt;a href="#Distance"&gt;Distance&lt;/a&gt;｜&lt;a href="#Normal"&gt;Normal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#Line"&gt;Line Segment&lt;/a&gt;｜&lt;a href="#Arc"&gt;Arc (have a center)&lt;/a&gt;｜&lt;a href="#Circle"&gt;Circle&lt;/a&gt;｜&lt;a href="#Cubic"&gt;Bezier curve&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#CONSTRAINTS"&gt;Constraints&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#C-Distance"&gt;Distance&lt;/a&gt;｜&lt;a href="#C-Ratio"&gt;Ratio of Line Segment&lt;/a&gt;｜&lt;a href="#C-Diameter"&gt;Diameter&lt;/a&gt;｜&lt;a href="#C-Angle"&gt;Angle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-On"&gt;Coincide&lt;/a&gt;｜&lt;a href="#C-Equal"&gt;Equal&lt;/a&gt;｜&lt;a href="#C-Dragged"&gt;Locked position&lt;/a&gt;｜&lt;a href="#C-Midpoint"&gt;Middle point&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-Symmetric"&gt;Symmetric&lt;/a&gt;｜&lt;a href="#C-HV"&gt;Horizontal &amp;amp; Vertical&lt;/a&gt;｜&lt;a href="#C-Parallel"&gt;Parallel&lt;/a&gt;｜&lt;a href="#C-Tangent"&gt;Tangent&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#ADD"&gt;Functions that not in use&lt;/a&gt;&lt;/h2&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="FOREWORD"&gt;&lt;/a&gt;Brief Introduction&lt;/h1&gt;
&lt;p&gt;SLVS Library is compose by C language, Although &lt;code&gt;slvs.py&lt;/code&gt; was translate to Python interface, but some function names has change.&lt;/p&gt;
&lt;p&gt;So I record these function, that how to use in Python program.&lt;/p&gt;
&lt;h2&gt;&lt;a name="CDemo"&gt;&lt;/a&gt;CDemo&lt;/h2&gt;
&lt;p&gt;SolveSpace is an open source 2D / 3D computer-aided design and drafting software, from 2008 released the first version, compatible with Windows / Mac / Linux three platforms.&lt;/p&gt;
&lt;p&gt;Has a small size, perform fast, free, and no installation features, STEP or STL support open, or exported into DXF, PDF, SVG and other open formats, also has its own text-based format &lt;code&gt;*.slvs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For updating, you can go to GitHub's &lt;a href="https://github.com/solvespace/solvespace" title="github.com"&gt;official storage&lt;/a&gt; or &lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;unofficial storage&lt;/a&gt; to download the latest source code, the direct use of developer tools (such as GNU) compile the main program.&lt;/p&gt;
&lt;p&gt;Solvespace has another small executable file named CDemo, compiled with source code of Solvespace.&lt;/p&gt;
&lt;p&gt;You can use this external program call library of Solvespace &lt;code&gt;libslvs.dll&lt;/code&gt; be 2D or 3D computing problem-solving, and without startup Solvespace.&lt;/p&gt;
&lt;p&gt;The concept of CDemo is be able to use an external program to call functions from Solvespace, whether it is using its maximum travel untied, the interference position. You can use this app without need to use CAD software to personally solving problems by you self.&lt;/p&gt;
&lt;h2&gt;&lt;a name="SLVS"&gt;&lt;/a&gt;SLVS Library&lt;/h2&gt;
&lt;p&gt;CDemo compiled from C language. Solvespace database using the C++ compiler is useful and fast of course, but the utilization of more limited.&lt;/p&gt;
&lt;p&gt;Python language has a lot of custom modules, easy-reading function, and has another scopes in the Internet than the C language, if Solvespace use database conversion, will make these Python programs have online problem-solving ability, mechanical design in particular it is a lot easier.&lt;/p&gt;
&lt;p&gt;In Python link library, &lt;code&gt;*.pyd&lt;/code&gt; is similar to C language dynamic load library &lt;code&gt;*.dll&lt;/code&gt; in Windows; &lt;code&gt;*.so&lt;/code&gt; is the most open operating systems (such as Ubuntu) in use. Advantage of &lt;code&gt;*.so&lt;/code&gt; is beneficial to share information, perform file and database separation, updated library more convenient.&lt;/p&gt;
&lt;p&gt;Concept of the production Python-Solvespace is using SWIG to create a C ++ to Python port to make any use of Anaconda 3 (Python 3.5) of Python programs are able to use the library of Solvespace.&lt;/p&gt;
&lt;p&gt;When Solvespace the function is converted into when Python interface, but also want to keep consistently fresh and understandable names for this language, so I especially reclassified these names and usage instructions.&lt;/p&gt;
&lt;p&gt;Below the title is original name of the command code, the database using to identify the type of command.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="START"&gt;&lt;/a&gt;Starting Draw and Solve&lt;/h1&gt;
&lt;p&gt;To use SLVS database must be converted through the &lt;code&gt;slvs.py&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;Use the following command in your Python program:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Import "slvs.py".
from slvs import *

#Import Solid Python.
#If not using Solid Python, don't need to do this.
import solid

#Your system, and it's supporting number of params.
#Default Units 50
#If your system is in a loop, it's params will be re-clear.
sys = System(20)
...
&lt;/pre&gt;

&lt;p&gt;For the implementation of problem-solving, Python program must use the following command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Implementation of problem-solving.
sys.solve()
#Another command.
Slvs_Solve(sys, g)

#Return result value as follows.
if (sys.result == SLVS_RESULT_OKAY):
    ...
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;After the execution of problem-solving program, there will be three results:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;All constraints were satisfied to within our numerical tolerance (i.e., success). The result is equal to &lt;code&gt;SLVS_RESULT_OKAY&lt;/code&gt;, entities that not fully constrained will be moved to meet the conditions of, but may not meet your expectations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The solver can prove that two constraints are inconsistent (for example, if a line with nonzero length is constrained both horizontal and vertical). The result is equal to &lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The solver cannot prove that two constraints are inconsistent, but it cannot find a solution. The result is equal to &lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, the following function can call to check the results.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Entities result.
#Precision floating-point format.
sys.get_param(0).val
&lt;/pre&gt;

&lt;p&gt;And too serious error will return &lt;code&gt;SLVS_RESULT_TOO_MANY_UNKNOWNS&lt;/code&gt;. You must checkout your Python library or SLVS library is damaged or not.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ENTITIES"&gt;&lt;/a&gt;Types of Entities&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_E&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Entity type, object parts for problem-solving. Entity has some sub-categories.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Point&lt;/kbd&gt; This object belongs to Point.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;LineSegment&lt;/kbd&gt; This object belongs to Line Segment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; This object belongs to Circular.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No label items belonging to sub-categories of &lt;kbd&gt;Entity&lt;/kbd&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;According to these relations, in the constraint must determine its classification to fill.&lt;/p&gt;
&lt;p&gt;When function input "&lt;code&gt;, sys&lt;/code&gt;" after value, it can record into &lt;code&gt;sys&lt;/code&gt; (There maybe exist &lt;code&gt;sys2&lt;/code&gt; or &lt;code&gt;sys3&lt;/code&gt;). It can also use &lt;code&gt;sys.add_&lt;/code&gt; to input to current system.&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_param( )
add_point2d( )
add_point3d( )
add_entity( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As same as take them out (Add the specified number).&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_Point2d( )
get_Point3d( )
get_LineSegment2d( )
get_LineSegment3d( )
get_Normal3d( )
get_Distance( )
get_Workplane( )
get_Cubic( )
get_Circle( )
get_ArcOfCircle( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Point"&gt;&lt;/a&gt;Point&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point3d(Param x, Param y, Param z)
&lt;/pre&gt;

&lt;p&gt;Representative of a point in space.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point2d(Workplane workplane, Param u, Param v)
&lt;/pre&gt;

&lt;p&gt;Representative a point on a work plane.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Normal"&gt;&lt;/a&gt;Normal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Param qw, Param qx, Param qy, Param qz)
&lt;/pre&gt;

&lt;p&gt;Representative of a normal in space.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt; / &lt;kbd&gt;Normal2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;Representative of a normal line perpendicular to the work plane.&lt;/p&gt;
&lt;p&gt;In SolveSpace, "normals" represent a 3x3 rotation matrix from our base coordinate system to a new frame. Defined by the unit quaternion w, x, y, z.&lt;/p&gt;
&lt;p&gt;It is useful to think of this quaternion as representing a plane through the origin. This plane has three associated vectors: basis vectors U, V that lie within the plane, and normal N that is perpendicular to it. This means that&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    [ U V N ]&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;defines a 3x3 rotation matrix. So U, V, and N all have unit length, and are orthogonal so that&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;U cross V = N
V cross N = U
N cross U = V
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Convenience functions &lt;code&gt;Slvs_Quaternion&lt;/code&gt; are provided to convert between this representation as vectors U, V, N and the unit quaternion.&lt;/p&gt;
&lt;p&gt;A unit quaternion has only 3 degrees of freedom, but is specified in terms of 4 parameters. An extra constraint is therefore generatedimplicitly, that&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w^2 + x^2 + y^2 + z^2 = 1&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Make a Quaternion for a Work Plane &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;To define a plane consisting by the &lt;code&gt;U [1 0 0]&lt;/code&gt; vector (equivalent X-axis) and &lt;code&gt;V [0 1 0]&lt;/code&gt; vector (equivalent Y axis) need for 3D normals.&lt;/p&gt;
&lt;p&gt;If you don't know how to calculated quaternion, can be reached using the following functions:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Conversion quaternion
qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0)

#Take into the 3D normal function
normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys)

#Make a working plane
c = Point3d(Param(0.0), Param(0.0), Param(0.0))
plane = Workplane(c, normal)
&lt;/pre&gt;

&lt;p&gt;When creating 2D plane, using this formula is very convenient.&lt;/p&gt;
&lt;p&gt;The following are the different planes reference:&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;XY plane: [1 0 0], [0 1 0]
MakeQuaternion(1, 0, 0, 0, 1, 0)

YZ plane: [0 1 0], [0 0 1]
MakeQuaternion(0, 1, 0, 0, 0, 1)

XZ plane: [1 0 0], [0 0 1]
MakeQuaternion(1, 0, 0, 0, 0, 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Distance"&gt;&lt;/a&gt;Distance&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Distance&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Distance(Workplane wrkpl, Param distance)
&lt;/pre&gt;

&lt;p&gt;Representative of a distance parallel a work plane.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Workplane"&gt;&lt;/a&gt;Work Plane&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Workplane&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_WORKPLANE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Workplane(Point3d origin, Normal3d normal)
&lt;/pre&gt;

&lt;p&gt;Representative of a work plane through the origin, perpendicular to a normal.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Line"&gt;&lt;/a&gt;Line Segment&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_LINE_SEGMENT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment3d(Point3d a, Point3d b)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment2d(Workplane wrkpl, Point2d a, Point2d b)
&lt;/pre&gt;

&lt;p&gt;Draw a straight line between two &lt;code&gt;Point2d / 3d&lt;/code&gt; point.&lt;/p&gt;
&lt;p&gt;Representative of a connection between two points.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Cubic"&gt;&lt;/a&gt;Cubic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CUBIC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Cubic&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3)
&lt;/pre&gt;

&lt;p&gt;Bezier curve consisting of four points, whether it be 2D or 3D construction, will be treated as 3D objects.&lt;/p&gt;
&lt;p&gt;Four point formula is as follows:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Equation (t from 0 to 1 points)
p(t) = P0*(1 - t)^3 + 3*P1*(1 - t)^2*t + 3*P2*(1 - t)*t^2 + P3*t^3&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name="Circle"&gt;&lt;/a&gt;Circle&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;Circle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius)
&lt;/pre&gt;

&lt;p&gt;Representative of a circle perpendicular with a &lt;code&gt;Normal3d&lt;/code&gt; normal, parallel with a &lt;code&gt;Workplane&lt;/code&gt; plane, constitute by a &lt;code&gt;Point2d&lt;/code&gt; center and a &lt;code&gt;Distance&lt;/code&gt; radius.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Arc"&gt;&lt;/a&gt;Arc of Circle&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_ARC_OF_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;ArcOfCircle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end)
&lt;/pre&gt;

&lt;p&gt;Representative of an arc perpendicular with a &lt;code&gt;Normal3d&lt;/code&gt; normal, parallel with a &lt;code&gt;Workplane&lt;/code&gt; plane, constitute by a &lt;code&gt;Point2d&lt;/code&gt; center, a &lt;code&gt;Point2d&lt;/code&gt; start point, and a &lt;code&gt;Point2d&lt;/code&gt; endpoint.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="CONSTRAINTS"&gt;&lt;/a&gt;Types of Constrains&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Constraints type. Most of the instruction will automatically determine the situation.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Such constraints can only be used in 3D or projected onto a plane.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Such constraints can only be used in a 2D plane.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Val&lt;/kbd&gt; Such constraints must be set additional reference value.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Enter the value of the last side to join the group numbers can be specified group (Default &lt;code&gt;Slvs_hGroup group = USE_DEFAULT_GROUP&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Direct command constraint(But you should filled zero in empty entry):&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Slvs_MakeConstraint((h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB,  entityC,  entityD, other, other2)
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="C-Distance"&gt;&lt;/a&gt;Distance &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;Constraints two &lt;code&gt;Point 2d / 3d&lt;/code&gt; distance.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PROJ_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;Constraints two &lt;code&gt;Point 3d&lt;/code&gt; projected to&lt;code&gt;Workplane&lt;/code&gt; distance.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PLANE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;Distance from a &lt;code&gt;Point3d&lt;/code&gt; to a &lt;code&gt;Workplane&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Positive and negative values will be predetermined distance above or below the plane.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_LINE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Distance from a &lt;code&gt;Point 2d/3d&lt;/code&gt; to a&lt;code&gt;LineSegment2d/3d&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Positive and negative values will be predetermined distance above or below the line segment.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-On"&gt;&lt;/a&gt;On&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_POINTS_COINCIDENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d/3d&lt;/code&gt; coordinates equal.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_IN_PLANE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Point3d&lt;/code&gt; will be fixed on a &lt;code&gt;Workplane&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Point2d/3d&lt;/code&gt; will be fixed on a &lt;code&gt;LineSegment2d/3d&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that this constraint removes one degree of freedom when projected in to the plane, but two degrees of freedom in 3d.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_CIRCLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, Circle circle)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Point2d&lt;/code&gt; will be fixed on a &lt;code&gt;Circle&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Equal"&gt;&lt;/a&gt;Equal&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LENGTH_LINES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;Two length of &lt;code&gt;LineSegment2d&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_LEN_PT_LINE_D&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, Point2d p, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;Length of first &lt;code&gt;LineSegment2d&lt;/code&gt; will as same as a distance of a &lt;code&gt;Point2d&lt;/code&gt; to second &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_PT_LN_DISTANCES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;Distance of first &lt;code&gt;Point2d&lt;/code&gt; to first &lt;code&gt;LineSegment2d&lt;/code&gt; will as same as next distance of second &lt;code&gt;Point2d&lt;/code&gt;to second &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_angle(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, LineSegment2d line3, LineSegment2d line4)
&lt;/pre&gt;

&lt;p&gt;Angle of first &lt;code&gt;LineSegment2d&lt;/code&gt; to second &lt;code&gt;LineSegment2d&lt;/code&gt; will as same as next angle of third &lt;code&gt;LineSegment2d&lt;/code&gt;to fourth &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LINE_ARC_LEN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line, Circular c)
&lt;/pre&gt;

&lt;p&gt;Length of a &lt;code&gt;LineSegment2d&lt;/code&gt; and Arc length of a &lt;code&gt;Circular&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_RADIUS&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2)
&lt;/pre&gt;

&lt;p&gt;Two radius of &lt;code&gt;Circular&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SAME_ORIENTATION&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.orientation(Normal3d nrml1, Normal3d nrml2)
&lt;/pre&gt;

&lt;p&gt;Two direction of &lt;code&gt;Normal3d&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Ratio"&gt;&lt;/a&gt;Ratio of Length &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_LENGTH_RATIO&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.ratio(double value, Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;The ratio of first &lt;code&gt;LineSegment2d&lt;/code&gt; to second &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Symmetric"&gt;&lt;/a&gt;Symmetric&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d/3d&lt;/code&gt; will symmetric to a work plane.&lt;/p&gt;
&lt;p&gt;This means that they are on opposite sides of the plane and at equal distances from the plane, and that the line connecting ptA and ptB is normal to the plane.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_HORIZ&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d&lt;/code&gt; will be locked in the same horizontal coordinate.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_VERT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d&lt;/code&gt;will be locked in the same vertical coordinate.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d&lt;/code&gt; will symmetric to the &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Midpoint"&gt;&lt;/a&gt;Middle point&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_AT_MIDPOINT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Let a &lt;code&gt;Point2d/3d&lt;/code&gt; locate on a middle point of the &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-HV"&gt;&lt;/a&gt;Horizontal &amp;amp; Vertical&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_HORIZONTAL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.horizontal(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SLVS_C_VERTICAL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.vertical(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Let a &lt;code&gt;LineSegment2d&lt;/code&gt; to horizontal or vertical.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Diameter"&gt;&lt;/a&gt;Diameter &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_DIAMETER&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.diameter(double diameter, Workplane wrkpl, Circular c)
&lt;/pre&gt;

&lt;p&gt;Diameter of a &lt;code&gt;Circular&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Angle"&gt;&lt;/a&gt;Angle &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.angle(Workplane wrkpl, double value, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;Angle of two &lt;code&gt;LineSegment2d&lt;/code&gt;. In degrees.&lt;/p&gt;
&lt;p&gt;The following formula (&lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are vector of two lines):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(A dot B)/(|A||B|) = cos(valA)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;where A and B are vectors in the directions of lines A and B. This equation does not specify the angle unambiguously; for example, note that valA = +/- 90 degrees will produce the same equation.&lt;/p&gt;
&lt;p&gt;If other is true, then the constraint is instead that&lt;/p&gt;
&lt;p&gt;(A dot B)/(|A||B|) = -cos(valA)&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PERPENDICULAR&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.perpendicular(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;From constraint &lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This constraint is defined angle constraint when it is 90 degrees.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Parallel"&gt;&lt;/a&gt;Parallel&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PARALLEL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(LineSegment3d line1, LineSegment3d line2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;LineSegment2d/3d&lt;/code&gt; are parallel each other.&lt;/p&gt;
&lt;p&gt;Note that this constraint removes one degree of freedom when projected in to the plane, but two degrees of freedom in 3d.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Tangent"&gt;&lt;/a&gt;Tangent &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ARC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle arc, LineSegment2d line, bool other)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;ArcOfCircle&lt;/code&gt; and a &lt;code&gt;LineSegment2d&lt;/code&gt; are tangent.&lt;/p&gt;
&lt;p&gt;If the bool value is &lt;code&gt;False&lt;/code&gt;, than it will tangent at its beginning &lt;code&gt;s&lt;/code&gt;. If other is &lt;code&gt;True&lt;/code&gt;, then the arc is tangent at its end &lt;code&gt;e&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CUBIC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(Cubic c, LineSegment3d l, bool other)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Cubic&lt;/code&gt; and a &lt;code&gt;LineSegment3d&lt;/code&gt; are tangent.&lt;/p&gt;
&lt;p&gt;If the bool value is &lt;code&gt;False&lt;/code&gt;, than it will tangent at its beginning &lt;code&gt;p0&lt;/code&gt;. If other is &lt;code&gt;True&lt;/code&gt;, then the arc is tangent at its end &lt;code&gt;p3&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CURVE_CURVE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; &lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle c1, ArcOfCircle c2, bool other, bool other2)
Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2)
Constraint.tangent(ArcOfCircle c1, Cubic c2, bool other, bool other2)
Constraint.tangent(Cubic c1, ArcOfCircle c2, bool other, bool other2)
&lt;/pre&gt;

&lt;p&gt;Tangent combination of two curves.&lt;/p&gt;
&lt;p&gt;If the bool value is &lt;code&gt;False&lt;/code&gt;, than it will tangent at its beginning &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;p0&lt;/code&gt;. If other is &lt;code&gt;True&lt;/code&gt;, then the arc is tangent at its end &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;p3&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Dragged"&gt;&lt;/a&gt;Dragged&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Point3d p)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Workplane wrkpl, Point2d p)
&lt;/pre&gt;

&lt;p&gt;Permanently lock the &lt;code&gt;Point2d/3d&lt;/code&gt; point coordinates in the current calculation of the coordinates, never change.&lt;/p&gt;
&lt;p&gt;This constrains two degrees of freedom in a workplane, and three in free space.&lt;/p&gt;
&lt;h2&gt;Set Dragged &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;About lock the position,  another constraint of system as follows:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sys.set_dragged(Point p)
&lt;/pre&gt;

&lt;p&gt;It is command that try to fix the &lt;code&gt;Point2d/3d&lt;/code&gt;, instead to move other entities.&lt;/p&gt;
&lt;p&gt;This point will get a little of movement.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ADD"&gt;&lt;/a&gt;Additional Types of Constrains&lt;/h1&gt;
&lt;p&gt;Some additional constraints, there is no corresponding entity items available for them.&lt;/p&gt;
&lt;h2&gt;Point and Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_FACE_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#This feature is not Construction
&lt;/pre&gt;

&lt;h2&gt;Point on Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_ON_FACE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#This feature is not Construction
&lt;/pre&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050816.html" rel="alternate"></link><published>2016-08-16T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-16:blog/40323230ri-zhi-1050816.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖 - 漸開線範例（已儲存8888.kmol.info）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 安裝 Python 3.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;漸開線範例&lt;/h1&gt;
&lt;p&gt;嘗試使用純 &lt;code&gt;slvs&lt;/code&gt; 程式庫（而非使用 matlab 的公式）的方式畫出漸開線。&lt;/p&gt;
&lt;p&gt;雖然程式庫中有比較弧長和線段長的公式，但是無法因應多圈的狀況，所以使用內建math的 &lt;code&gt;pi&lt;/code&gt; 來計算弧長。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dgdmbxm.jpg" &gt;&lt;/p&gt;
&lt;p&gt;越多圈的漸開線計算越久，角度參照是基圓而非漸開線尾。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
%matplotlib inline
#漸開線解題
#由端點Point3畫出圖形
from slvs import *
import matplotlib.pyplot as plt
from math import *

#參數
r = 10.0#基圓半徑

def Involute(degree):
    #角度換算：degree去除重複圈數
    d = r*(degree*pi/180)
    n = degree//360
    degree -= 360*n

    #開始繪圖
    sys = System(500)
    g = 1

    #3D原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #2D原點Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #Point2繞行圓周，距離r
    p9 = sys.add_param(0.0)
    p10 = sys.add_param(10.0*other)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.distance(r, Workplane1, Point1, Point2)
    Line1 = LineSegment2d(Workplane1, Point1, Point2)

    #Point3距離Point2為目前圓周長
    #並且連線d會垂直半徑連線r
    p11 = sys.add_param(10.0*other)
    p12 = sys.add_param(10.0*other)
    Point3 = Point2d(Workplane1, p11, p12)
    if d == 0:
        Constraint.on(Workplane1, Point2, Point3)
    else:
        Line2 = LineSegment2d(Workplane1, Point2, Point3)
        Constraint.distance(d, Workplane1, Point2, Point3)
        Constraint.perpendicular(Workplane1, Line1, Line2, False)

    #輔助基線Line0
    p13 = sys.add_param(10.0)
    p14 = sys.add_param(0.0)
    Point4 = Point2d(Workplane1, p13, p14)
    Constraint.dragged(Workplane1, Point4)
    Line0 = LineSegment2d(Workplane1, Point1, Point4)

    #約束角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題
    sys.solve()
    if (sys.result == SLVS_RESULT_OKAY):
        #回傳Point7
        x = sys.get_param(11).val
        y = sys.get_param(12).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []
degree = 720
for i in range(0, degree+1, 1):
    x, y = Involute(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.title("Involute - "+str(degree)+" deg")
plt.show()
&lt;/pre&gt;

&lt;p&gt;由於 &lt;code&gt;Point2&lt;/code&gt; 是逆時針旋轉，必須保持 &lt;code&gt;Point3&lt;/code&gt; 在它的後方，之間的連線也必須相切基圓，即與其半徑垂直。&lt;/p&gt;
&lt;p&gt;然而 &lt;code&gt;slvs&lt;/code&gt; 程式庫無法解決距離為 &lt;code&gt;0&lt;/code&gt; 的情況，必須自己改成重合約束，目前在程式庫說明中加上註解，不過應該有辦法透過原始碼的標頭檔避開這個問題，晚點會修正這個情況，如果情況順利，明天的網誌中會更新。&lt;/p&gt;
&lt;p&gt;結果圖形：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nbCrMjE.png" &gt;&lt;/p&gt;
&lt;p&gt;Jupyter 運行結果（計算時間較長）：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QjE2qEl.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;CentOS 7&lt;/h1&gt;
&lt;p&gt;為虛擬機（研究室的電腦）安裝官方的 Everything 版本（ISO映像檔），但是電腦效能只能同時跑一個程式，所以安裝很緩慢。&lt;/p&gt;
&lt;p&gt;最後還是灌好了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BfVtw6K.png" &gt;&lt;/p&gt;
&lt;p&gt;但是安裝完後之前選的 Python 工具包中竟然只有 Python 2.7，所以上網找了一下資料，用手動make的方式安裝 Python 3.3.6。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/" title="tecadmin.net"&gt;http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OVS9mZ2.png" &gt;&lt;/p&gt;
&lt;p&gt;CentOS 相較於 Ubuntu 操作方式不太一樣，而雖然安裝畫面是寫 KDE 圖形介面，但卻是 GNOME 包著 KDE 的附屬程式，而且它們的介面還比 Ubuntu 陽春。&lt;/p&gt;
&lt;p&gt;慶幸的是 CentOS 的開發者工具包十分完善，應該是不用 Netbeans 了，可以直接用終端機make。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050815.html" rel="alternate"></link><published>2016-08-15T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-15:blog/40323230ri-zhi-1050815.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多連桿機構的程式及註解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Jupyterhub&lt;/h1&gt;
&lt;p&gt;用學校 Gmail 登入後用 notebook 進行運算，程式碼開頭只要加上 &lt;code&gt;%matplotlib inline&lt;/code&gt; 就能使用 matplotlib 了。&lt;/p&gt;
&lt;p&gt;不過 notebook 目前是唯獨模式，無法建立檔案或是編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MyRvGoJ.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;程式碼&lt;/h1&gt;
&lt;p&gt;這次將畫圖順序統整了一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/s8rsywg.jpg" &gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
%matplotlib inline
#多連桿機構端點（Point7）路徑圖形
#主動軸為［曲柄］Point1-Point2
#圖形將在程式中解釋
from slvs import *
import matplotlib.pyplot as plt

def Multi_link(degree):
    #開始繪圖
    sys = System(500)
    g = 1

    #3D原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #2D原點Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #［曲柄］Point1-Point2長15mm
    p9 = sys.add_param(0.0)
    p10 = sys.add_param(20.0*other)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.distance(15.0, Workplane1, Point1, Point2)
    Line1 = LineSegment2d(Workplane1, Point1, Point2)

    #第一組［呆鍊］Point3-Point4-Point5（Point3固定）
    #長度41.5-55.8-40.1mm
    p11 = sys.add_param(-38.0)
    p12 = sys.add_param(-7.8)
    Point3 = Point2d(Workplane1, p11, p12)
    Constraint.dragged(Workplane1, Point3)
    p13 = sys.add_param(-50.0)
    p14 = sys.add_param(30.0)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(-70.0)
    p16 = sys.add_param(-15.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(41.5, Workplane1, Point3, Point4)
    Constraint.distance(55.8, Workplane1, Point4, Point5)
    Constraint.distance(40.1, Workplane1, Point3, Point5)

    #第二組［呆鍊］Point6-Point7-Point8
    #長度65.7-49.0-36.7mm
    p17 = sys.add_param(-50.0)
    p18 = sys.add_param(-50.0)
    Point6 = Point2d(Workplane1, p17, p18)
    p19 = sys.add_param(-10.0)
    p20 = sys.add_param(-90.0)
    Point7 = Point2d(Workplane1, p19, p20)
    p21 = sys.add_param(-20.0)
    p22 = sys.add_param(-40.0)
    Point8 = Point2d(Workplane1, p21, p22)
    Constraint.distance(65.7, Workplane1, Point6, Point7)
    Constraint.distance(49.0, Workplane1, Point7, Point8)
    Constraint.distance(36.7, Workplane1, Point6, Point8)

    #兩段［呆鍊-呆鍊］連接桿
    #Point5-Point6長39.4mm
    #Point3-Point8長39.3mm
    Constraint.distance(39.4, Workplane1, Point5, Point6)
    Constraint.distance(39.3, Workplane1, Point3, Point8)

    #兩段［區柄-呆鍊］連接桿
    #Point2-Point4長50.0mm
    #Point2-Point8長61.9mm
    Constraint.distance(50.0, Workplane1, Point2, Point4)
    Constraint.distance(61.9, Workplane1, Point2, Point8)

    #水平輔助Line0
    p23 = sys.add_param(20.0)
    p24 = sys.add_param(0.0)
    Point9 = Point2d(Workplane1, p23, p24)
    Constraint.dragged(Workplane1, Point9)
    Line0 = LineSegment2d(Workplane1, Point1, Point9)

    #區柄角度（手動項目務必放最後）
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題
    sys.solve()
    if (sys.result == SLVS_RESULT_OKAY):
        #回傳Point7
        x = sys.get_param(19).val
        y = sys.get_param(20).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []

for i in range(0, 361, 1):
    x, y = Multi_link(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.show()
&lt;/pre&gt;

&lt;p&gt;因為是變速機構，如果將精度調成5度的話，圖形會比較粗糙，目前用1度的精度會比較平滑，不過相對運算時間會比較久。&lt;/p&gt;
&lt;h2&gt;執行結果（5度）&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CvjRTBI.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;執行結果（1度）&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xHnFqdE.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;經過多次範例，若要使用 slvs 程式庫畫圖，要先看一下機構節點的大約位置，尤其是運動範圍跨象限的主動節點（即參數控制約束的點）。&lt;/p&gt;
&lt;p&gt;機構中會360度繞軸旋轉的區柄端點，起始位置要定在90度（輸入值在0～180）或-90度（輸入值在181～359），要用 &lt;code&gt;if&lt;/code&gt; 函式判斷。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050814.html" rel="alternate"></link><published>2016-08-14T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-14:blog/40323230ri-zhi-1050814.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用研究室網路設定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架站問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3.3 版本製作中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;網路設定&lt;/h1&gt;
&lt;p&gt;由於之前上網是用手機網路，為了取得固定IP，使用的是原本給新電腦用的網路 &lt;code&gt;140.130.17.117&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Su0D9Oc.png" &gt;&lt;/p&gt;
&lt;p&gt;Windows 和 Ubuntu 中的設定是一樣的，兩個OS都能連到網際網路。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Oauthenticator&lt;/h1&gt;
&lt;p&gt;參考 Cadlab 有關 Jupyterhub 的安裝，在 Python 中安裝了 jupyterhub、notebook 和 oauthenticator。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html" title="cadlab.mde.tw"&gt;http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html" title="cadlab.mde.tw"&gt;http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用指令產生 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;crt&lt;/code&gt; 兩個憑證檔案。&lt;/p&gt;
&lt;pre&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt&lt;/pre&gt;

&lt;p&gt;起動指令是：&lt;/p&gt;
&lt;pre&gt;jupyterhub --ip 140.130.17.117 --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/pre&gt;

&lt;p&gt;從&lt;a href="https://github.com/jupyterhub/oauthenticator/tree/master/example" title="github.com"&gt;https://github.com/jupyterhub/oauthenticator/tree/master/example&lt;/a&gt;下載了範例資料夾，不過 &lt;code&gt;jupyterhub_config.py&lt;/code&gt; 結構跟說明不太一樣，所以把他的指令碼改成 Cadlab 的方式，只是白名單和使用者清單的檔案可能不一樣，改一下資料夾或連結名稱就能對應。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AkO0IE6.png" &gt;&lt;/p&gt;
&lt;p&gt;接著進 Github 註冊新的app，取得 Client ID 和 Client Secret，不過不知道網域名稱該填甚麼，只能填上電腦IP名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l4FqQ1c.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而 Google 方面也是一樣，但是重新導向 callback 的方面要使用頂層網域，就是包含 &lt;code&gt;.com&lt;/code&gt; 或 &lt;code&gt;.org&lt;/code&gt; 的名稱，這樣就沒辦法導向給 IP 名稱的網站用了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5TFwgH.png" &gt;&lt;/p&gt;
&lt;p&gt;另外就是檔案瀏覽器沒有權限在 &lt;code&gt;etc&lt;/code&gt; 或 &lt;code&gt;srv&lt;/code&gt; 目錄裡編輯或是建立檔案，要自動啟動就必須用終端機設定了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;pyenv&lt;/h1&gt;
&lt;p&gt;裝了 pyenv 來管理 Python 版本。&lt;/p&gt;
&lt;p&gt;安裝時還需要 Mercurial。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yZbLONl.png" &gt;&lt;/p&gt;
&lt;p&gt;Python 3.3 dev 下載和安裝時都比較久，等了一段時間才弄好。&lt;/p&gt;
&lt;p&gt;接下來會編譯 3.3 的版本來測試。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;由於對網路方面不熟悉，所以可能設定方面有所缺失，還要花一些時間檢查。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050813.html" rel="alternate"></link><published>2016-08-13T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-13:blog/40323230ri-zhi-1050813.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本與 Openshift 不合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Openshift 的 cartridge 自訂？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;版本不合&lt;/h1&gt;
&lt;p&gt;後來發現為何找不到 &lt;code&gt;_slvs.so&lt;/code&gt; 的檔案了，因為 &lt;code&gt;.gitignore&lt;/code&gt; 中包含了 &lt;code&gt;*.so&lt;/code&gt;，而不會上傳這兩個檔案，註解掉就行了。&lt;/p&gt;
&lt;p&gt;但是上傳後仍無法執行，回報的訊息為：&lt;/p&gt;
&lt;pre&gt;
Traceback (most recent call last):
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/wsgi.py", line 5, in &lt;module&gt;
    import myflaskapp
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/myflaskapp.py", line 18, in &lt;module&gt;
    import users.b.g9.bg9_40323230
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/users/b/g9/bg9_40323230.py", line 2, in &lt;module&gt;
    from slvs import *
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py", line 28, in &lt;module&gt;
    _slvs = swig_import_helper()
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py", line 24, in swig_import_helper
    _mod = imp.load_module('_slvs', fp, pathname, description)
  File "/opt/rh/python33/root/usr/lib64/python3.3/imp.py", line 183, in load_module
    return load_dynamic(name, filename, file)
ImportError: libpython3.4m.so.1.0: cannot open shared object file: No such file or directory
&lt;/pre&gt;

&lt;p&gt;看來開發時使用 Python 3.4 dev 會造成 Python 3.3 無法讀取。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jUsRUi4.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Openshift custom cartridge&lt;/h1&gt;
&lt;p&gt;上網找了一下文章，找到有人問能不能建立其他版本的 cartridge。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4" title="stackoverflow.com"&gt;http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而回應的是如果使用 s2i-python-container 這個工具，可以建立一個名為 Python 3.3 的其他版本 Python 鏡像檔，甚至有支援 Python 3.5。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/sclorg/s2i-python-container" title="github.com"&gt;https://github.com/sclorg/s2i-python-container&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不過這個工具只能給 Fedora 類型的 Linux 作業系統使用，看起來是沒有 Debian 的版本。&lt;/p&gt;
&lt;p&gt;要解決 Linux 相容的問題，Ubuntu 上可能要裝 3.3 版本的 Python 了，會先研究看看 Openshift 方可以安裝和執行的指令。&lt;/p&gt;
&lt;p&gt;不知道如果其他 Ubuntu 沒安裝 Python-dev（或版本不同）的話能不能執行這些檔案。&lt;/p&gt;
&lt;p&gt;Windows 的 Python 連結庫是自己做的，而非安裝 Python-dev，所以沒這個問題。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050812.html" rel="alternate"></link><published>2016-08-12T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-12:blog/40323230ri-zhi-1050812.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯完畢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Ubuntu 執行成功&lt;/h1&gt;
&lt;p&gt;後來將 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 的 &lt;code&gt;__mingw_vasprintf&lt;/code&gt; 暫時改為 &lt;code&gt;vasprintf&lt;/code&gt; 就沒問題了，不過若要使用MinGW編譯的話要再改回來。&lt;/p&gt;
&lt;p&gt;編譯出來的檔案名稱為 &lt;code&gt;_slvs.so&lt;/code&gt;，類型是共享連結庫。&lt;/p&gt;
&lt;p&gt;在終端機中使用python3執行所有範例檔都沒問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/gcEM8h0.png" &gt;&lt;/p&gt;
&lt;p&gt;Windows 用的 &lt;code&gt;_slvs.pyd&lt;/code&gt; ，在檔案瀏覽器中被視為 Windows 可執行檔，而非共享連結庫。&lt;/p&gt;
&lt;p&gt;將 Makefile 存成兩個版本（加上次檔名），不同平台間用 &lt;code&gt;-f&lt;/code&gt; 參數切換make就行了。&lt;/p&gt;
&lt;p&gt;不過目前手邊沒有虛擬機，所以還沒測試是否所有使用 Python 3.4 的 Ubuntu 都能使用程式庫。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;倉儲更新&lt;/h1&gt;
&lt;p&gt;統一將make完畢的 Library 放在 Windows 和 Ubuntu 資料夾。&lt;/p&gt;
&lt;p&gt;將倉儲清理了一下，讓原始碼回到 make clean 狀態。&lt;/p&gt;
&lt;p&gt;將原本 Windows 的範例code複製一份到 Ubuntu 資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nIY73qM.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;不過將 &lt;code&gt;_slvs.so&lt;/code&gt; 和編譯好的附屬文件上傳到 Openshift 後仍然找不到 &lt;code&gt;_slvs&lt;/code&gt; 模組。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/juGSqv4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著會測試看看小型的pyd能不能用。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050811.html" rel="alternate"></link><published>2016-08-11T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-11:blog/40323230ri-zhi-1050811.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Linux 版工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;工作環境&lt;/h1&gt;
&lt;p&gt;用以前安裝的雙系統做 Ubuntu 版本的編譯。&lt;/p&gt;
&lt;p&gt;作業系統是基於 Ubuntu 14.04 的 ezgo 12，圖形介面為KDE。&lt;/p&gt;
&lt;p&gt;原本 ezgo 中的python3版本為 3.4.0，安裝python3.4-dev後升級到最新的3.4.5。&lt;/p&gt;
&lt;p&gt;而原版的GNU工具沒有裝入g++，所以就用apt安裝了。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 上運行 Netbeans 和 gcc 比 Windows 流暢，make的速度更快。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;產生問題&lt;/h1&gt;
&lt;p&gt;因為作業系統換了環境，所以Makefile的位置研究並調整了一下。&lt;/p&gt;
&lt;p&gt;不過在編譯&lt;code&gt;slvs_python.hpp&lt;/code&gt;時出現&lt;code&gt;‘__mingw_vasprintf’ was not declared in this scope&lt;/code&gt;的訊息。&lt;/p&gt;
&lt;p&gt;這個函式應該是&lt;code&gt;stdio.h&lt;/code&gt;的，不知道為何無法找到它。&lt;/p&gt;
&lt;p&gt;檢查了系統目錄，這個檔案應該都在&lt;code&gt;include&lt;/code&gt;的範圍內，所以應該是使用GNU和原本MinGW兩種版本gcc的問題。&lt;/p&gt;
&lt;p&gt;不過這次並非在虛擬機測試，所以使用上會更小心。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050810.html" rel="alternate"></link><published>2016-08-10T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-10:blog/40323230ri-zhi-1050810.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;檢視python.log的錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace 的介紹圖&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;FileZilla 登入&lt;/h1&gt;
&lt;p&gt;用FileZilla進入網站查看和下載檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oXaiwCp.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Openshift的網頁中按下"Want to log in to your application?"連結，能取得一個字串，形式如下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh 使用者名稱@主機&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dpua4rp.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將其內容填入FileZilla的站台設定中，協定選擇SFTP，登入形式選擇交談式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nmtCVUg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後連線後，在&lt;code&gt;/var/lib/openshift/使用者名稱/app-root/logs&lt;/code&gt;資料夾中可以找到python.log，下載後開啟。&lt;/p&gt;
&lt;p&gt;最下方是最新的執行紀錄和連線紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l8Xoe0b.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看到問題是錯在模組導入錯誤，雖然訊息跟之前模組匯入的問題一樣，但是造成原因應該不一樣。&lt;/p&gt;
&lt;p&gt;不知道是python版本還是openshift不使用anaconda的關係。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slvs.py&lt;/code&gt;無法像先前一般將&lt;code&gt;_slvs.pyd&lt;/code&gt;的名稱傳給python用。&lt;/p&gt;
&lt;h1&gt;介紹圖&lt;/h1&gt;
&lt;p&gt;用免費軟體XMind做兩張Python Solvespace的概念圖。&lt;/p&gt;
&lt;p&gt;軟體中不能調整解析度，目前的比例還能符合網頁或文件中的說明。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;製作過程&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/e6JWCWW.png" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;利用規劃&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/62SVuDT.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;在想是否要將slvs的檔案做成模組的方式裝入Python，再裝到Openshift的python上。&lt;/p&gt;
&lt;p&gt;做成模組後用途應該會增加。&lt;/p&gt;
&lt;p&gt;近期將整理網誌內容改成書面格式，先存成Markdown檔，再另外參照學長的目錄做分類排序成章節。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050808.html" rel="alternate"></link><published>2016-08-08T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-08:blog/40323230ri-zhi-1050808.html</id><summary type="html">&lt;p&gt;將bokeh繪圖搬入Flask，使用的是上學期的倉儲。&lt;/p&gt;


&lt;h1&gt;bokeh網頁原始碼&lt;/h1&gt;
&lt;p&gt;bokeh在使用後，可以不選擇存檔，而是變成網頁原始碼的型態，讓程式利用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#不使用from bokeh.plotting import figure, output_file, show, save

#而導入：
from bokeh.plotting import figure
from bokeh.resources import CDN
from bokeh.embed import file_html

#照常畫圖
plot = figure(...)
plot.line(...)

#最後傳出給outstring
outstring = str(file_html(plot, CDN, "網頁視窗標題"))
&lt;/pre&gt;

&lt;p&gt;變成這樣的形態後，會先讓SLVS程式庫和bokeh計算完原始碼後才使用，算是靜態結果，這樣會產生一個缺點，稍後會提到。&lt;/p&gt;
&lt;p&gt;bokeh也有自己的附加功能"JavaScript Callbacks"，屬於動態運算，讓圖形能及時更新，不用重新整理。&lt;/p&gt;
&lt;p&gt;參考連結：&lt;a href="http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;試過了範例Slider的方法（最接近需求：給角度求機構當前狀態），在JavaScript中卻不知所以然，不知道要如何把callback的內容帶入我的函式中。&lt;/p&gt;
&lt;p&gt;上網看過別人的範例，不同利用方式都不一樣，但是不知道如何修改JS迴圈中的內容。因為機構的圖形要回傳所有的點，可能要了解一下這些物件的關係。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Flask&lt;/h1&gt;
&lt;p&gt;和上學期的專案一樣，用&lt;code&gt;python wsgi.py&lt;/code&gt;啟動後就能呼叫程式並帶入變數求解。&lt;/p&gt;
&lt;p&gt;不同的是用到新模組和自己的程式庫。&lt;/p&gt;
&lt;p&gt;在自己的檔案中再插入一段&lt;code&gt;Mango(k)&lt;/code&gt;來嵌入bokeh的圖形，並希望能控制機構的角度狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jTqqiDg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;稍微調整了bokeh的選項，隱藏工具、取消預設工具、不可拖移、放大介面等等。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@bg9_40323230.route('/crank_rock/＜k&gt;')
def Mango(k):
    outstring = ""
    #相關參數
    d0 = 90 #基線長度(mm)
    n1 = 35 #短連桿長度(mm)
    n2 = 70 #長連桿長度(mm)
    t1 = 40 #三角形第一邊(mm)
    t2 = 40 #三角形第二邊(mm)
    t3 = 70 #三角形第三邊(mm)

    #迴圈求路徑用
    def crank_rock(degree):
        ...
    #當前機構狀態用
    def crank_rock_M(degree):
        ...
    #主程式
    X1val  = []
    Y1val  = []
    for i in range(0, 361):
        x, y = crank_rock(i)
        X1val += [x]
        Y1val += [y]
    x1, y1, x2, y2, x3, y3, x4, y4, x5, y5 = crank_rock_M(float(k))
    X2val = [x1, x4, x3, x5, x4, x5, x2]
    Y2val = [y1, y4, y3, y5, y4, y5, y2]
    X3val = [x1, x2]
    Y3val = [y1, y2]
    #bokeh
    plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y', toolbar_location=None, plot_width=700, plot_height=700)
    plot.line(X1val, Y1val, legend="Path.", line_width=2, line_color="blue")
    plot.line(X2val, Y2val, legend="Mechanism.", line_width=4, line_color="red")
    plot.line(X3val, Y3val, line_width=3, line_dash=[4, 4], line_color="orange")
    plot.toolbar.active_drag = None

    outstring = str(file_html(plot, CDN, "Crank Rocker: "+str(k)+" degree"))

    return outstring
&lt;/pre&gt;

&lt;p&gt;這樣子程式會計算出HTML的原始碼給網頁，而bokeh的網頁中不會用到python程式。&lt;/p&gt;
&lt;p&gt;在這裡&lt;code&gt;k&lt;/code&gt;是以&lt;strong&gt;字串&lt;/strong&gt;的方式帶進來的，所以必須轉成Float才能計算。&lt;/p&gt;
&lt;p&gt;但是如果預先設置了&lt;code&gt;defaults&lt;/code&gt;值時（例如&lt;code&gt;120&lt;/code&gt;），這裡的&lt;code&gt;120&lt;/code&gt;可以代表字串或整數或浮點數，python會搶先認定&lt;code&gt;defaults&lt;/code&gt;值能用，儘管自訂的&lt;code&gt;k&lt;/code&gt;值後來轉成浮點數，結果仍然會是&lt;code&gt;defaults&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;所以最後不得以把&lt;code&gt;defaults&lt;/code&gt;值捨棄。&lt;/p&gt;
&lt;p&gt;最後結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kuaUOnR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;建立了一支Openshift程式，但是上傳後卻無法使用，不知道是Python 3.3還是其他的問題，整個程式都跑不了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tSmySff.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;最近因為有點感冒，研究bokeh的互動功能函式滿久的。&lt;/p&gt;
&lt;p&gt;嘗試過用3D的方式解手臂極限範圍，但是程式庫有些盲點。&lt;/p&gt;
&lt;p&gt;SLVS似乎會認定4個約束在同平面的3D點，他們之間的2條連線如果約束為平行，是重複約束，目前不知道要怎麼辦。&lt;/p&gt;</summary><category term="Kmol"></category><category term="bokeh"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050805.html" rel="alternate"></link><published>2016-08-05T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-05:blog/40323230ri-zhi-1050805.html</id><summary type="html">&lt;p&gt;使用bokeh繪圖&lt;/p&gt;


&lt;h1&gt;bokeh&lt;/h1&gt;
&lt;p&gt;由於mpld3沒有支援Python 3.5，測試過執行產生的頁面是空白頁，所以選擇使用bokeh來繪製，但是後者不支援3D繪圖。&lt;/p&gt;
&lt;p&gt;使用Anaconda的指令安裝bokeh。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ana install bokeh
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/mjv0nNb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;參照了一下官方的說明頁：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/installation.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/installation.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/reference/io.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/reference/io.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

&lt;h1&gt;Exercise&lt;/h1&gt;
&lt;p&gt;將之前的Crank Rocker改寫一下。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。
#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
from slvs import *
from math import *
from bokeh.plotting import figure, output_file, show

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):

    sys = System(500)
    g = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題

    sys.solve()

    if (sys.result == SLVS_RESULT_OKAY):
        x = sys.get_param(11).val
        y = sys.get_param(12).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []

for i in range(0, 361):
    x, y = crank_rock(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

#bokeh
output_file("mango.html")
plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y')
plot.line(Xval, Yval, legend="Temp.", line_width=2)
show(plot)
&lt;/pre&gt;

&lt;p&gt;使用的是簡單的show指令，會產生一個&lt;code&gt;html&lt;/code&gt;的檔案。&lt;/p&gt;
&lt;p&gt;內容是和matplotlib一樣的圖形。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/05kAM03.png" &gt;&lt;/p&gt;
&lt;p&gt;另外bokeh也可以在Jupyter notebook上使用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from tmp.workplace.exposed.slvs import *
from math import *
from bokeh.plotting import figure, output_notebook, show

d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):
    ...

#主程式
Xval  = []
Yval  = []

for i in range(0, 361):
    x, y = crank_rock(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

#bokeh
output_notebook()
plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y')
plot.line(Xval, Yval, legend="Temp.", line_width=2)
show(plot)
&lt;/pre&gt;

&lt;p&gt;程式庫名稱必須改為&lt;code&gt;tmp.workplace.exposed.slvs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;執行結果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WHoVdrV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一支跑手臂極限範圍的程式：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dQM4kck.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;有找到另一個套件Vispy可以畫3D物件，也可以在Jupyter notebook上執行。&lt;/p&gt;
&lt;p&gt;另外Solvespace的運算方面無法同時計算2D和3D的物件，儲存的項目也不一樣。&lt;/p&gt;
&lt;p&gt;不知道能不能用球座標系或圓柱坐標系轉換的方式，做一個將3D點鎖定到2D點的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="bokeh"></category></entry><entry><title>40323230日誌 - 105/08/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050803.html" rel="alternate"></link><published>2016-08-03T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-03:blog/40323230ri-zhi-1050803.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;研究Scoop的使用方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檢查錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://scoop.readthedocs.io/en/latest/usage.html" title="scoop.readthedocs.io"&gt;http://scoop.readthedocs.io/en/latest/usage.html&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;啟動Scoop&lt;/h1&gt;
&lt;p&gt;為了讓自己製作的函式庫能進行分工運算，想要用一些工具讓SLVS Library能夠支援平行運算功能。&lt;/p&gt;
&lt;p&gt;用pip安裝scoop。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install scoop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scoop的需求：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Distribute &amp;gt;= 0.6.2 or setuptools &amp;gt;= 0.7
Greenlet &amp;gt;= 0.3.4
pyzmq &amp;gt;= 13.1.0 and libzmq &amp;gt;= 3.2.0
ssh for remote execution
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;上述的套件Anaconda都有安裝了，不過在連線方面還不知道如何設定。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;python -m scoop&lt;/code&gt;啟動後會顯示［WinError 10022］，上網找資料發現是沒有指定特定目標。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9SKyqDY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Scoop的Help指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XjVDlDJ.jpg" &gt;&lt;/p&gt;
&lt;h1&gt;Scoop函式&lt;/h1&gt;
&lt;p&gt;啟動後，在python程式中導入scoop。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from scoop import futures, shared

def myParallelFunc(inValue):
    myValue = shared.getConst('myValue')
    return inValue + myValue

if __name__ == '__main__':
    shared.setConst(myValue=5)
    print(list(futures.map(myParallelFunc, range(10))))
&lt;/pre&gt;

&lt;p&gt;或是使用指令執行單一檔案也可以。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python -m scoop --hostfile hosts -vv -n 6 your_program.py [your arguments]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scoop可以分享函式給其他電腦，並在同時間回饋相同訊息。&lt;/p&gt;
&lt;p&gt;而每台電腦可以平均分配需要運算的項目，達成多工的目的。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天花太多時間檢查ZeroMQ (libzmq)的安裝狀態，因為不同語言的需求好像都不一樣，Python已經包含在pyzmq中（Windows版本應該是如此，但是Linux要另外裝和設定lib位置）；而C語言是安裝後從安裝位置include。&lt;/p&gt;
&lt;p&gt;而ZeroMQ也能導入Python中，不過Scoop給的指令更方便。&lt;/p&gt;
&lt;p&gt;關於Scoop的說明和介紹資料好像滿少的，而網路方面不知道如何架設。&lt;/p&gt;</summary><category term="Kmol"></category><category term="pyScoop"></category></entry><entry><title>40323231日誌 - 指令(G碼、M碼...)</title><link href="http://project.mde.tw/blog/40323231ri-zhi-zhi-ling-gma-mma.html" rel="alternate"></link><published>2016-08-02T14:00:00+08:00</published><author><name>40323231</name></author><id>tag:project.mde.tw,2016-08-02:blog/40323231ri-zhi-zhi-ling-gma-mma.html</id><summary type="html">&lt;p&gt;常用指令與解說&lt;/p&gt;


&lt;h3&gt;常用指令&lt;/h3&gt;

&lt;h4&gt;G28 : 原點複歸&lt;/h4&gt;

&lt;h4&gt;G29 : 自動校正&lt;/h4&gt;

&lt;h4&gt;G01 X70 Y60 Z5 : 快速定位  X70 Y60 高度5&lt;/h4&gt;

&lt;h4&gt;M104 : 設定噴頭溫度&lt;/h4&gt;

&lt;h4&gt;M105 : 查詢溫度(噴頭和熱床)&lt;/h4&gt;

&lt;h4&gt;M106 : 開啟風扇&lt;/h4&gt;

&lt;h4&gt;M107 : 關閉風扇&lt;/h4&gt;

&lt;h4&gt;M114 : 查詢目前位置(例如:X40 Y50 Z5)&lt;/h4&gt;

&lt;h4&gt;M119 : 查詢限位開關目前狀態&lt;/h4&gt;

&lt;h4&gt;M500 : 儲存參數&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;字母定義&lt;/h3&gt;
&lt;h4&gt;G:範例說明&lt;/h4&gt;
&lt;h4&gt;M:範例說明&lt;/h4&gt;
&lt;h4&gt;T:選擇工具，單一噴頭所以無用&lt;/h4&gt;
&lt;h4&gt;S:命令參數，如電壓，控制轉速、溫度等等&lt;/h4&gt;
&lt;h4&gt;P:命令參數，多少毫秒&lt;/h4&gt;
&lt;h4&gt;F:每分鐘進給(毫米)&lt;/h4&gt;
&lt;h4&gt;E:擠出材料的長度(毫米)&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;其他指令說明&lt;/h3&gt;
&lt;h4&gt;G4的：暫停&lt;/h4&gt;
&lt;h4&gt;例如：G4 P200&lt;/h4&gt;
&lt;h4&gt;在這種狀態下暫停200秒不工作。在延時時的機器狀態下(例如:擠出機溫度)仍然會被保留和控制。&lt;/h4&gt;
&lt;h4&gt;G20 設定從現在開始為英寸&lt;/h4&gt;
&lt;h4&gt;G21 設定從現在開始為毫米&lt;/h4&gt;
&lt;h4&gt;G90 從現在開始，所有的座標都是絕對座標&lt;/h4&gt;
&lt;h4&gt;G91 設定現在位置為原點，之後的都為相對座標&lt;/h4&gt;&lt;/p&gt;
&lt;h4&gt;M0 停止&lt;/h4&gt;

&lt;h4&gt;M18 禁止所有步進馬達&lt;/h4&gt;

&lt;h4&gt;M20：列出SD卡&lt;/h4&gt;

&lt;h4&gt;M21：初始化SD卡&lt;/h4&gt;

&lt;h4&gt;M22：釋放SD卡&lt;/h4&gt;

&lt;h4&gt;M23：選擇SD文件&lt;/h4&gt;

&lt;h4&gt;M24：啟動/恢復SD列印&lt;/h4&gt;

&lt;h4&gt;M25：暫停SD列印&lt;/h4&gt;

&lt;h4&gt;M26：設置的SD位置&lt;/h4&gt;

&lt;h4&gt;M27：報告SD列印狀態&lt;/h4&gt;

&lt;h4&gt;M28：開始寫入到SD卡&lt;/h4&gt;

&lt;h4&gt;M29：停止向SD卡寫入&lt;/h4&gt;

&lt;h4&gt;M42：用盡材料時停止(XY回歸原點但Z沒有，關閉所有電器和加熱器，要重新開始必須複歸，之後繼續列印)&lt;/h4&gt;

&lt;h4&gt;M43: 用盡材料時等待(與M42相似，可是M43還可以下指令如G碼和M碼)&lt;/h4&gt;

&lt;h4&gt;M101:正轉啟動擠出馬達&lt;/h4&gt;

&lt;h4&gt;M102:逆向啟動擠出馬達&lt;/h4&gt;

&lt;h4&gt;M109:設定擠出溫度&lt;/h4&gt;

&lt;h4&gt;M112：緊急停止(全部動作停止包括電器關閉)&lt;/h4&gt;

&lt;h4&gt;M113：設定擠出機的的PWM，例如:M113 S0.7，設定為擠出機70%速度，未用過猜測與軟體內的流量設定相同功用&lt;/h4&gt;

&lt;h4&gt;M303 S200 C8 : 設定目標溫度200，並做8次震盪&lt;/h4&gt;

&lt;p&gt;&lt;a href = "http://www.simplyalt.com/atom/viewthread.php?tid=1560&amp;highlight=PID"&gt; 震盪參考 &lt;/a&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323250日誌 - v-rep實做心得</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-repshi-zuo-xin-de.html" rel="alternate"></link><published>2016-08-02T11:15:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-08-02:blog/40323250ri-zhi-v-repshi-zuo-xin-de.html</id><summary type="html">&lt;p&gt;V-rep 與 Solvespace的結合應用&lt;/p&gt;


&lt;h3&gt;最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 &lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_solvespace.png" &gt;
&lt;h3&gt;(檔案位於solvespace官網的 tutorial : linkages)
&lt;/h3&gt;&lt;p&gt;&lt;a href="http://solvespace.com/dl/mechanisms.zip "&gt;壓縮檔載點&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3&gt;由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep.png"&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;軸都放好了 ,只是從屬關係還是不太清楚要如何放置&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep_allaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結果我又弄了一個圖 ,試圖從這邊學習從屬設定&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前只會讓它亂轉&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.gif"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;感覺和各個旋轉軸速度也有關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test2.gif"&gt;
&lt;hr&gt;
&lt;h3&gt;105 - 07/10更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;現在能夠讓連桿旋轉了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;想要測試能否以固定角度來回旋轉 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間...&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_types.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前先以控單軸為主 ,但是遇到以下狀況&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_control2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/example_code1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/code_error1.png" &gt;
&lt;h3&gt;如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;參考 :&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm "&gt;Joint types and operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded "&gt;Child Scripts&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/11更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Joint 種類分成以下4種 :&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/joint-types.png" &gt;
&lt;/br&gt;
&lt;h4&gt;1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。&lt;/h4&gt;
&lt;h4&gt;2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 &lt;/h4&gt;
&lt;h4&gt;3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。&lt;/h4&gt;
&lt;h4&gt;4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;Control the joint :&lt;/h3&gt;
&lt;h4&gt;1.simSetJointPosition : when your joint is not in force/torque mode&lt;/h4&gt;
&lt;h4&gt;2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled&lt;/h4&gt;
&lt;h4&gt;3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試:&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/12更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... &lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/little_car.ttt?raw=true"&gt;little_car.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/little_car.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/14更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Printer_new.png" &gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new.ttt?raw=true"&gt;printer_new.ttt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new_2.ttt?raw=true"&gt;printer_new_2.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/15更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天開始研究Inverse Kinematic 逆向運動學(IK) ,透過矩正及向量運算 ,就可以得到參數 ,且恰巧有學長論文和此相關 ,從中學到了不少 ,但還沒能弄懂 ,最後要結合進V-rep模擬中 ,腳步要加快了&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/17更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace測試連桿運動方式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_tutorial.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;旋轉軸定義&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_pic.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;子屬關係設定 (測試) ,加上dummy固定&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/relation_test.png" &gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;經過一番波折 ,終於和同學弄出來了 ,只要無法封閉的部分利用dummy固定就可以了 ,至於實體轉軸部分要搭接在桿子上才可以&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/solvespace_successful.ttt?raw=true"&gt;solvespace_successful&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/18更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;嘗試幫第一組 組裝手臂, 除了夾爪部分外 ,其餘都組裝好了 ,過程發現部分零件拆解後會有座標不對的問題 ,只要將做標調整和world相同就比較容易了&lt;/h3&gt;
&lt;h3&gt;(參照範例: 7 DoF manipulator 設定ik值)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/24更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天預計要測試馬達控制 ,但是沒有多的12V power supply ,所以先把Onshape ,printer的細部畫一畫 ,現在大概有300個特徵 ,本來可以輕鬆的拉動滑塊 ,現在要用箭頭才能拉動了 ,估計不會畫電路板部分 ,戲偶衣服穿太多了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_top.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_bottom.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/printer.stl"width="300"height="300"&gt;&lt;/script&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/28更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;暫時利用可變電阻取代步進馬達 ,並加入馬達轉軸 ,控制加熱頭移動&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_control.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Nsgt8YPSDpU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 08/02更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;V-rep定位&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在繪圖時 ,需要有一個對稱零件(輔助零件)在vrep內訂定位置 ,在定位之前 ,座標系要先調整&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後將主體設為此零件子屬&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos3.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;定位完之後就可以設為一個群組了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos4.png" &gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="solvespace&amp;v-rep"></category></entry><entry><title>40323231日誌 - 105/08/01</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050801.html" rel="alternate"></link><published>2016-08-01T19:00:00+08:00</published><author><name>40323231</name></author><id>tag:project.mde.tw,2016-08-01:blog/40323231ri-zhi-1050801.html</id><summary type="html">&lt;p&gt;網誌更新，列印組合件，觀看新軟體&lt;/p&gt;


&lt;h4&gt;今天把問題那篇網誌做新增和整理 ，並整理出常用指令一篇。&lt;/h4&gt;

&lt;h4&gt;列印組合件時，孔和外型的公差不太穩定，多次列印出來的公差也都不太一樣，有時會差到20條，還需要做改進和調整。&lt;/h4&gt;

&lt;h4&gt;今天列印需要支撐材的物件時，發現cura會生成很多不必要的支撐材，導致浪費，所以去尋找很多方法，其中有看到新的軟體Meshmixer，它的操作方式很獨特，跟其他3D繪圖軟體不一樣。網路教學讓軟體很多變，像是製作卡扣、拆解物件、填補漏洞、手動生成支撐材......等等，很多好用的功能，可是滿複雜的，還在學習。因為是新的軟體，所以花了比較多時間觀看，明天會把重心拉回來，繼續製作。&lt;/h4&gt;</summary><category term="3DP"></category></entry><entry><title>40323230日誌 - 105/07/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050731.html" rel="alternate"></link><published>2016-07-31T21:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-31:blog/40323230ri-zhi-1050731.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Crank Rocker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;準備整理函式庫內容，再製作英文版副本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Crank Rocker範例&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/EeRYe4H.jpg" &gt;&lt;/p&gt;
&lt;p&gt;模仿三角形呆鍊的圖形解題。&lt;/p&gt;
&lt;p&gt;用迴圈方式旋轉短連桿，讓三角形頂點畫出點座標。&lt;/p&gt;
&lt;p&gt;以下程式將輸出每一度畫出的點座標。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。
#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
from slvs import *
from math import *
import unittest

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):
    sys = System(500)
    g = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題

    sys.solve()

    if (sys.result == SLVS_RESULT_OKAY):
        print ("點座標：")
        print(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
        print(("P4(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
for i in range(0, 360):
    print ("Degree: %3s deg"%(i))
    crank_rock(i)
    print ("=======")
print ("Solve Completed")
&lt;/pre&gt;

&lt;p&gt;輸出結果圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/r6qocmD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;圖解法：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LfDHVAi.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這次旋轉的時候，角度約束似乎無法支援超過180度的角度，而會使用正值，讓原本在第一二象限的點&lt;code&gt;Point4&lt;/code&gt;座標無法移動至第三四象限。&lt;/p&gt;
&lt;p&gt;因此在起始定點時的象限位置非常重要，加入了&lt;code&gt;if&lt;/code&gt;判斷式讓&lt;code&gt;Point4&lt;/code&gt;更改初始位置，就解決了這個問題。&lt;/p&gt;
&lt;p&gt;只有用來畫線，且線段有約束角度的點座標有限制。&lt;/p&gt;
&lt;p&gt;另一個要注意的是，要約束成三角形的三個點不可以共線。&lt;/p&gt;
&lt;p&gt;以下是正確值比對：&lt;/p&gt;
&lt;h2&gt;0&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L9IQWoY.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;45&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FQRIlkm.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;135&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TTFfRil.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;180&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iA1lXcy.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;225&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jZNqz0W.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;解了多個圖形題目後，發現之前寫的那篇還滿不容易查詢資料，而且前作者的內容有些錯誤。&lt;/p&gt;
&lt;p&gt;由於當初紀錄是靠&lt;code&gt;DOC.txt&lt;/code&gt;的順序寫的，所以要自己重新閱讀多次，將使用比例分配一下。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323231 -3DP注意事項</title><link href="http://project.mde.tw/blog/40323231-3dpzhu-yi-shi-xiang.html" rel="alternate"></link><published>2016-07-31T16:00:00+08:00</published><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-31:blog/40323231-3dpzhu-yi-shi-xiang.html</id><summary type="html">&lt;p&gt;注意事項&lt;/p&gt;


&lt;h3&gt;一.固件安裝 :&lt;/h3&gt;

&lt;h4&gt;1.鎖固個螺絲時請依循鎖固方向(對角或順逆時鐘)，而且不要一次就鎖緊，分兩次至三次，避免不平或無法微調&lt;/h4&gt;

&lt;h4&gt;2.安裝滑塊時請勿推出滑軌外，避免滑塊內的滾珠掉出&lt;/h4&gt;

&lt;h4&gt;3.鎖固滑塊上用來控制限位的螺絲時，不要鎖太裡面，避免限位開關接收不到訊號，導致撞機，或者校機時無法做調整(圖.A)&lt;/h4&gt;

&lt;h4&gt;4.安裝喉管和噴頭塊以及噴嘴時一定要確定鎖緊，不然可能會有液料或漏料的問題(圖.B)&lt;/h4&gt;

&lt;h4&gt;5.安裝噴頭塊時不要直接接觸噴頭座，避免噴頭座過熱(圖.C)&lt;/h4&gt;

&lt;h4&gt;6.安裝擠出機時不要將料壓得太緊，避免進料不順&lt;/h4&gt;

&lt;h4&gt;7.安裝位於噴頭座上方的鐵氟龍管時，要量測插入的深度，以免列印時喉管堵塞&lt;/h4&gt;

&lt;h4&gt;8.安裝料和鐵氟龍管時可將前端剪成斜狀，方便安裝和進料&lt;/h4&gt;

&lt;h4&gt;9.安裝加熱棒時，請置中洞中，勿太裡面或太外面，以免加熱不確實，或加熱到其他地方(圖.D)&lt;/h4&gt;

&lt;h4&gt;10.安裝皮帶上面的固定鎖時勿一開始就鎖到緊，避免皮帶太鬆時無法做調整(圖.E)&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://i.imgur.com/zGKlktf.jpg" &gt;
&lt;h4&gt;(圖.A)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/hNHGnCJ.jpg" &gt;
&lt;h4&gt;(圖.B)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/iPPgmVk.jpg" &gt;
&lt;h4&gt;(圖.C)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/hidvXCI.jpg" &gt;
&lt;h4&gt;(圖.D)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/xDtP6BW.jpg" &gt;
&lt;h4&gt;(圖.E)&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;二.配電 :&lt;/h3&gt;
&lt;h4&gt;1.裸露的線要用熱縮管(套到需要的地方後用打火機讓館子收縮即可)或者PVC電氣絕緣膠帶包覆&lt;/h4&gt;
&lt;h4&gt;2.delta機型的噴頭上所有的線用捲束管包覆，避免電線纏繞打結或扯斷&lt;/h4&gt;
&lt;h4&gt;3.鐵氟龍管以及噴頭上方的電線長度要夠長，避免噴頭到最下方時被扯斷或撞機&lt;/h4&gt;
&lt;h4&gt;4.控制板上所有電線都需整線，避免內部過熱燒毀&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;三.測機 :&lt;/h3&gt;
&lt;br&gt;
&lt;h4&gt;切記:如發生意外，請迅速切斷電源，切斷後不要立即開啟電源，請先關閉軟體的訊號，之後再做開電的動作，避免開電後訊號依
舊在，導致機台繼續損壞。&lt;/h4&gt;
&lt;h4&gt;切記:要跑動X、Y方向時噴頭高度不能在最高點，不然機台可能損壞&lt;/h4&gt;
&lt;h4&gt;切記:列印機與電腦操控軟體(如:pronterface)連接後務必G28原點複歸&lt;/h4&gt;
&lt;br&gt;
&lt;h4&gt;1.要確定三軸速度不要太高，避免回歸或者移動速度太快&lt;/h4&gt;
&lt;h4&gt;2.確定訊號為多少(250000或其他)&lt;/h4&gt;
&lt;h4&gt;3.確定噴頭高度(程式)&lt;/h4&gt;
&lt;h4&gt;4.不要把列印範圍(平台大小)設最大，因為噴頭座可能會撞到各軸，或跑出外面導致列印品質低&lt;/h4&gt;
&lt;h4&gt;5.要確定限位開關是否有作用&lt;/h4&gt;
&lt;h4&gt;6.要下降Z方向時要注意高度，G1 Z20，避免撞機&lt;/h4&gt;
&lt;h4&gt;7.確定XYZ和擠出軸轉向是否正常&lt;/h4&gt;
&lt;h4&gt;8.跑動X、Y方向時噴頭高度不要靠近熱床，因為跑動時可能是碗公型，可能會撞擊熱床&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;四.列印 :&lt;/h3&gt;
&lt;h4&gt;1.務必檢查列印成品是否超過列印大小&lt;/h4&gt;
&lt;h4&gt;2.列印前請用口紅膠或特定膠帶弄在熱床上，可避免列印時材料不能貼緊熱床&lt;/h4&gt;
&lt;h4&gt;3.前幾次列印請注意列印狀況以及擠料狀況(跳線、擠不進去等等)&lt;/h4&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323250日誌 - V-rep &amp; 3D-Printer</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-3d-printer.html" rel="alternate"></link><published>2016-07-30T22:10:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-30:blog/40323250ri-zhi-v-rep-3d-printer.html</id><summary type="html">&lt;p&gt;之後的 V-rep模擬Printer都整理於本文章中&lt;/p&gt;


&lt;h3&gt;透過Tkinter介面及remote api 控制printer參數&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;程式碼&lt;/h3&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;

from tkinter import *
import serial
import sys
import numpy as np
from matplotlib import pyplot, rcParams
import vrep
import math



class printer(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.grid()
        self.createWidgets()

    def createWidgets(self):



        Label(pri, text="Axis").grid(column=0, row=0)
        Label(pri, text="").grid(column=0, row=1)
        Label(pri, text="X").grid(column=0, row=2)
        Label(pri, text="").grid(column=0, row=3)
        Label(pri, text="Y").grid(column=0, row=4)
        Label(pri, text="").grid(column=0, row=5)
        Label(pri, text="Z").grid(column=0, row=6)

        Label(pri, text="Position").grid(column=1, row=0)
        Label(pri, text="-125&lt;=X&lt;=125").grid(column=1, row=1)
        Label(pri, text="-125&lt;=Y&lt;=125").grid(column=1, row=3)
        Label(pri, text="0&lt;=Z&lt;=400").grid(column=1, row=5)

        a = Entry(pri, width=12, justify=RIGHT)
        b = Entry(pri, width=12, justify=RIGHT)
        c = Entry(pri, width=12, justify=RIGHT)
                #x.delete(0,END)
                #y.delete(0,END)
        a.grid(row=2, column=1)
        b.grid(row=4, column=1)
        c.grid(row=6, column=1)


        def show_entry_fields():

            deg = math.pi/180

            x = a.get()
            y = b.get()
            z = c.get()

            if x =='' or y==''or z =='':
                x = 0
                y = 0
                z = 0
                print("Error")

            else:
                x = float(a.get())
                y = float(b.get())
                z = float(c.get())


                if float(x) &gt;= 125:
                    x = 125
                    print("X_axis is out of range")
                if float(y) &gt;= 125:
                    y = 125
                    print("Y_axis is out of range")
                if float(z) &gt;= 400:
                    z = 400     
                    print("Z_axis is out of range")
                if float(x) &lt;= -125:
                    x = -125
                    print("X_axis is out of range")
                if float(y) &lt;= -125:
                    y = -125
                    print("Y_axis is out of range")
                if float(z) &lt; 0:
                    z = 0
                    print("Z_axis is out of range")

                if (float(x) &lt;= -125*math.sin(30*deg)) &amp; (float(y) &gt;= 125*math.cos(30*deg)):
                    x = -125*math.sin(30*deg)
                    y = 125*math.cos(30*deg)

                if (float(x) &lt;= -125*math.sin(30*deg)) &amp; (float(y) &lt;= -125*math.cos(30*deg)):
                    x = -125*math.sin(30*deg)
                    y = -125*math.cos(30*deg)

                if (float(x) &gt;= 125*math.sin(30*deg)) &amp; (float(y) &gt;= 125*math.cos(30*deg)):
                    x = 125*math.sin(30*deg)
                    y = 125*math.cos(30*deg)

                if (float(x) &gt;= -125*math.sin(30*deg)) &amp; (float(y) &lt;= -125*math.cos(30*deg)):
                    x = 125*math.sin(30*deg)
                    y = -125*math.cos(30*deg)


                e=x/1000
                r=y/1000
                t=z/889
                if t &lt;= 0.11656:
                    t = t+0.11656


                vrep.simxFinish(-1)
                clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
                if clientID!= -1:
                    print("Connected to remote server")
                else:
                    print('Connection not successful')
                    sys.exit('Could not connect')
                errorCode,plate=vrep.simxGetObjectHandle(clientID,'plate',vrep.simx_opmode_oneshot_wait)
                if errorCode == -1:
                    print('Can not find left or right motor')
                    sys.exit()                
                errorCode=vrep.simxSetObjectPosition(clientID,plate,-1,[e,r,t], vrep.simx_opmode_oneshot)
                print(x,y,z)


                #print("%s,%s,%s" % (x, y, z))


        Button(pri, text='Quit', width=5, command=pri.quit).grid(row=8, column=2, sticky=W, pady=4)
        Button(pri, text='Go', width=5, command=show_entry_fields).grid(row=8, column=0, sticky=W, pady=4)



if __name__ == '__main__':
    pri = Tk()
    pri.title("Printer")
    pri.geometry('180x220');  #設定視窗大小
    pri.resizable(0, 0) #鎖定視窗大小
    app = printer(master=pri)

    app.mainloop()


#print(x,y,z)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_final.ttt?raw=true"&gt;printer_final.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/UhC2eP_vbrA" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="v-rep&amp;tkinter"></category></entry><entry><title>40323231日誌 - 105/07/30</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050730.html" rel="alternate"></link><published>2016-07-30T21:00:00+08:00</published><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-30:blog/40323231ri-zhi-1050730.html</id><summary type="html">&lt;p&gt;3DP維修&lt;/p&gt;


&lt;h4&gt;今天維修3DP，因為3DP擠出的料變得非常的少，導致成品稀疏和脆弱，而且還發現進料馬達有在旋轉，可是料卻擠不進去。&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;一開始先加熱之後開始清理喉管，清完後校機重新印製，可是情況還是一樣，再來我改變進料速度(80%.60%)，可是依舊如此。&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;再來將噴頭座整組拔出，測量鐵氟龍管插入喉管的深度和全新的做比較，發現深度差很多因此用燈照進去，發現有整塊白色的硬塊堵住，所以又加熱再拿尖銳物將裡面清空，並重新測量鐵氟龍管插入深度，確定可以後校機再重新印製，情況還是一樣，之後加熱更換噴頭，弄完校機後再印製，情況有所改善，可是進料有時候料會擠不進去，所以更改進料速度(最新值:65%)，現在情況已經穩定，印出的公差也調整過，公差在+4條。&lt;/h4&gt;
&lt;h4&gt;列印兩次後發現噴頭座有部分地方會有液料情況，重新鎖固鎖緊後就OK。(重組後須檢查是否鎖緊。)&lt;/h4&gt;&lt;/p&gt;
&lt;h4&gt;拆卸下來的噴頭需要用0.3大小的鑽頭去清理，還需要討論要怎麼處理噴頭。&lt;/h4&gt;</summary><category term="3DP"></category></entry><entry><title>40323230日誌 - 105/07/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050730.html" rel="alternate"></link><published>2016-07-30T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-30:blog/40323230ri-zhi-1050730.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Nutcraker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Nutcraker範例&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OlGMGj4.jpg" &gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#行程解題解題：兩個長1.5mm、2.3mm的連桿，在一直線上作動。
#原點的基座塊比工作路徑高0.5mm，寬0.75mm（占用0.38mm）。
#底線距離基座面3.25mm。
#2.3mm的連桿寬0.25mm，半圓頭。
#求最小行程（2.3mm的連桿與基座接觸）。
#求最大行程（半圓頭與底線接觸）。
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
h0 = 0.5 #基塊高度(mm)
b0 = 0.75 #基塊寬度(mm)
n1 = 1.5 #後連桿長度(mm)
n2 = 2.3 #前連桿長度(mm)
R0 = 0.25 #半圓頭半徑(mm)
L0 = 3.25 #底線距離(mm)

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)

#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)

#連桿中繼點Point2和行程點Point3
p9 = sys.add_param(2.0)
p10 = sys.add_param(2.0)
Point2 = Point2d(Workplane1, p9, p10)
p11 = sys.add_param(2.0)
p12 = sys.add_param(0.0)
Point3 = Point2d(Workplane1, p11, p12)
Line0 = LineSegment2d(Workplane1, Point1, Point3)
Constraint.horizontal(Workplane1, Line0)

#前連桿碰到基座
Line1 = LineSegment2d(Workplane1, Point2, Point3)
p13 = sys.add_param(b0/2)
p14 = sys.add_param(h0)
Point4 = Point2d(Workplane1, p13, p14)
Constraint.dragged(Workplane1, Point4) #必須鎖住已知點
Constraint.distance(R0, Workplane1, Point4, Line1)
Constraint.distance(n1, Workplane1, Point1, Point2)
Constraint.distance(n2, Workplane1, Point2, Point3)

#以下解題

sys.solve()

Ansmin = sys.get_param(11).val - b0/2
Ansmax = L0 - R0 - b0/2

if (sys.result == SLVS_RESULT_OKAY):
    print ("點座標：")
    print(("P1(%.3f %.3f %.3f)")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val))
    print("P1(0.000 0.000 0.000)")
    print(("P2(%.3f %.3f %.3f)")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val))
    print("P2(-0.400 1.450 0.000)")
    print(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print("P4(1.390 0.000 0.000)\n")
    print("Min:")
    print(("(%.3f)")%(Ansmin))
    print("Max:")
    print(("(%.3f)")%(Ansmax))
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;解題結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TQjsd3C.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Nutcracker只有單純的連桿，非常簡單。&lt;/p&gt;
&lt;p&gt;而之前的題目有相切約束，Solvespace解這種會有極限的約束都十分不便，常常會出現約束衝突或是正負不分的狀況。&lt;/p&gt;
&lt;p&gt;目前還不知道如何解決，只能多注意圓弧曲線的地方，可以用距離約束取代的地方就盡量不用額外輔助線。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;倉儲中嵌入副模組&lt;/h1&gt;
&lt;p&gt;在倉儲中加入了BBBSnowball的模組SolidPython，不過不知道怎麼用。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
git submodule add https://github.com/BBBSnowball/SolidPython.git solid-python
&lt;/pre&gt;

&lt;p&gt;應該只是單純放著支援功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QBhyKgH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;之前"SLVS資料庫函式"那篇還需要檢查一下，或是做一個英文版副本連結到倉儲Readme。&lt;/p&gt;
&lt;p&gt;雖然轉到Python介面中不只那些指令，但是只靠這些指令就能解題目了。&lt;/p&gt;
&lt;p&gt;進階應用如切換群組等，稍微看一下原本的範例code或CDemo的原始碼應該就能瞭解。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050729.html" rel="alternate"></link><published>2016-07-29T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-29:blog/40323230ri-zhi-1050729.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料庫解題成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;修復內容&lt;/h1&gt;
&lt;p&gt;使用修復過的資料庫內容解題，新增將近三分之一的對應函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7iQxUpJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這些函式中也包括需要的相切約束。&lt;/p&gt;
&lt;p&gt;由於這些函式都未有對應名稱，所以都是自己編名的，例如&lt;code&gt;equal_angle( )&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;解題成功&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XddGS1n.jpg" &gt;&lt;/p&gt;
&lt;p&gt;使用的是下列程式碼，在SciTE中解題成功：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#鍊條解題：18齒與30齒的鏈條，上下外切線長為200。
#小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
n0 = 20 #鍊條長度(mm)
n1 = 18 #小輪齒數(t)
n2 = 30 #大輪齒數(t)
#邊長為a的的正n邊形外接圓半徑為：
#R=a/(2*sin(pi/n)) or R=(a/2)*csc(pi/n)
R1 = n0/(2*sin(pi/n1))
R2 = n0/(2*sin(pi/n2))

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)


#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)

#Point2
p9 = sys.add_param(0.0)
p10 = sys.add_param(200.0)
Point2 = Point2d(Workplane1, p9, p10)

#上端外切線的兩個點Point3和Point4
p11 = sys.add_param(0.0)
p12 = sys.add_param(500.0)
Point3 = Point2d(Workplane1, p11, p12)
p13 = sys.add_param(500.0)
p14 = sys.add_param(500.0)
Point4 = Point2d(Workplane1, p13, p14)

#下端外切線的兩個點Point5和Point6
p15 = sys.add_param(0.0)
p16 = sys.add_param(-500.0)
Point5 = Point2d(Workplane1, p15, p16)
p17 = sys.add_param(500.0)
p18 = sys.add_param(-500.0)
Point6 = Point2d(Workplane1, p17, p18)

#外切線
Line1 = LineSegment2d(Workplane1, Point3, Point4)
Line2 = LineSegment2d(Workplane1, Point5, Point6)

#圓弧
Arc1 = ArcOfCircle(Workplane1, Normal1, Point1, Point3, Point5)
Constraint.diameter(R1*2, Workplane1, Arc1)
Arc2 = ArcOfCircle(Workplane1, Normal1, Point2, Point6, Point4)
Constraint.diameter(R2*2, Workplane1, Arc2)

#X軸Line0
Line0 = LineSegment2d(Workplane1, Point1, Point2)
Constraint.horizontal(Workplane1, Line0)

#約束
Constraint.tangent(Arc1, Line1, False)
Constraint.tangent(Arc2, Line1, False)
Constraint.tangent(Arc2, Line2, True)
Constraint.distance(200.0, Workplane1, Point3, Point4)

#以下解題

sys.solve()

if (sys.result == SLVS_RESULT_OKAY):
    print ("兩點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val))
    print ("上切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print("(-10.770 56.570 0.000)")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
    print("(185.700 93.980 0.000)\n")
    print ("下切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val))
    print("(-10.770 -56.570 0.000)")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val))
    print("(185.700 -93.98 0.000)\n")
    print ("導入函數測試：")
    print ("R1：")
    print(R1)
    print ("R2：")
    print(R2)
    print ("pi：")
    print(pi)
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;弧與直線相切的函式只能鎖住一頭（布林值調整鎖住頭或尾），所以要下兩次。&lt;/p&gt;
&lt;p&gt;不過由於Solvespace對約束的要求十分嚴謹，所以只要下了衝突約束或是重複約束，前者會顯示&lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;，後者會顯示&lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;，就得重新檢查寫的程式。&lt;/p&gt;
&lt;p&gt;以下是圖解法比對（其實已經記錄在上面的程式中供比對），兩者使用的資料庫函式應該是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FWVqdhW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;結果是零誤差。&lt;/p&gt;
&lt;p&gt;以下是SciTE的顯示結果，較上方的是Python運算的結果。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iqkIH4L.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用這個函式庫非常簡單，跟在Solvespace上畫圖一樣。&lt;/p&gt;
&lt;p&gt;先設定起始值後，利用約束調整這些值（而且可以將固定值鎖住），確定之後就能算出答案。&lt;/p&gt;
&lt;p&gt;第一次使用自己寫的介面，由於以熟悉它們的從屬關係和解題公式，所以用起來十分上手。&lt;/p&gt;
&lt;p&gt;這個函式庫最大的缺點應該是取值不太方便吧，雖然仍可以使用自己命名或是直接內嵌進函式中，可是取值時是按照註冊順序取的，所以養成輸入值時給編號比較不容易亂掉。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050728.html" rel="alternate"></link><published>2016-07-28T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-28:blog/40323230ri-zhi-1050728.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;未支援項目&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;＊某些項目未紀錄於DOC.exe中&lt;/em&gt;&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SLVS_C_PT_FACE_DISTANCE
SLVS_C_PT_ON_FACE
SLVS_C_LENGTH_RATIO
SLVS_C_EQ_LEN_PT_LINE_D
SLVS_C_EQ_PT_LN_DISTANCES
SLVS_C_EQUAL_ANGLE
SLVS_C_EQUAL_LINE_ARC_LEN
SLVS_C_SYMMETRIC
SLVS_C_SYMMETRIC_HORIZ
SLVS_C_SYMMETRIC_VERT
SLVS_C_SYMMETRIC_LINE
SLVS_C_AT_MIDPOINT
SLVS_C_SAME_ORIENTATION
SLVS_C_ANGLE
SLVS_C_PARALLEL
SLVS_C_PERPENDICULAR
SLVS_C_ARC_LINE_TANGENT
SLVS_C_CUBIC_LINE_TANGENT
SLVS_C_PROJ_PT_DISTANCE
SLVS_C_WHERE_DRAGGED
SLVS_C_CURVE_CURVE_TANGENT
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;今天編譯完&lt;code&gt;slvs_python.hpp&lt;/code&gt;，並推送至倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因為大部分都是強硬約束的關係，只測試過部分功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;編譯流程&lt;/h1&gt;
&lt;p&gt;使用Netbeans編譯&lt;code&gt;slvs_python.hpp&lt;/code&gt;和&lt;code&gt;slvs.i&lt;/code&gt;，旁邊的&lt;code&gt;constrainteq.cpp&lt;/code&gt;供參考函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zjppe0U.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;slvs.i&lt;/em&gt;&lt;/h2&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
    Constraint();
public:
...
    static Constraint some_other_constraint(
            System* system,
            int type, Workplane workplane, double value,
            Point ptA, Point ptB, Entity entityA, Entity entityB,
            Slvs_hGroup group = USE_DEFAULT_GROUP);
&lt;/pre&gt;

&lt;p&gt;標準的約束條件格式如上，其實所有的約束函式都是透過&lt;code&gt;slvs_python.hpp&lt;/code&gt;輸入&lt;code&gt;constrainteq.cpp&lt;/code&gt;的約束做計算。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;slvs_python.hpp&lt;/em&gt;&lt;/h2&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
...
public:
static Constraint some_other_constraint(
            System* system,
            int type, Workplane workplane, double value,
            Point ptA, Point ptB, Entity entityA, Entity entityB,
            Slvs_hGroup group = USE_DEFAULT_GROUP) {
        return init(system, Slvs_MakeConstraint(
            0, group,
            type,
            workplane.handle(),
            value,
            ptA.handle(), ptB.handle(),
            entityA.handle(), entityB.handle()));
    }
...
&lt;/pre&gt;

&lt;p&gt;但是由於約束&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;會用到四個Entity，預設只有開啟2個，另外的&lt;code&gt;EntityC&lt;/code&gt;、&lt;code&gt;EntityD&lt;/code&gt;沒有開啟，而相切約束需要的布林值&lt;code&gt;other&lt;/code&gt;和&lt;code&gt;other2&lt;/code&gt;亦沒有加入。&lt;/p&gt;
&lt;p&gt;所以只能從&lt;code&gt;slvs.h&lt;/code&gt;添加這4個值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cV0HyKc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其他項目也要加上4個空位，以免出錯。&lt;/p&gt;
&lt;p&gt;對照&lt;code&gt;constrainteq.cpp&lt;/code&gt;中需要的項目，在&lt;code&gt;slvs_python.hpp&lt;/code&gt;中填上需要的值的類型，應該就可以運作了。&lt;/p&gt;
&lt;p&gt;測試了一些新加入的約束，如果&lt;code&gt;slvs_python.hpp&lt;/code&gt;中填上的類型正確，就會解題，不過「重複約束」的結果似乎是歸類在「過度約束」裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ej4JQHF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而如果本身類型填錯，就會回傳錯誤碼&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/n3iIuhW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是函式庫中只有&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;會抓住點（而且還是有移動量），還要研究一下如何鎖住這些點的位置。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天幫忙編寫CDemo，使其擁有Solvespace全部約束的功能。&lt;/p&gt;
&lt;p&gt;會找時間翻修一下之前的紀錄。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050727.html" rel="alternate"></link><published>2016-07-27T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-27:blog/40323230ri-zhi-1050727.html</id><summary type="html">&lt;p&gt;規劃解題與檢驗函式&lt;/p&gt;
&lt;p&gt;&lt;em&gt;檢驗出功能缺損&lt;/em&gt;&lt;/p&gt;


&lt;h2&gt;規劃解題 :&lt;/h2&gt;

&lt;p&gt;計算題目，並一邊利用SciTE的偵錯窗來檢查之前寫的函式資料。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tfgUIVX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;之前的題目：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html" title="chiamingyen.github.io"&gt;http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;規劃了一支程式來計算鍊輪的點座標（半成品）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#鍊條解題：18齒與30齒的鏈條，上下外切線長為200。
#小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
n0 = 20 #鍊條長度(mm)
n1 = 18 #小輪齒數(t)
n2 = 30 #大輪齒數(t)
#邊長為a的的正n邊形外接圓半徑為：
#R=a/(2*sin(pi/n)) or R=(a/2)*csc(pi/n)
R1 = n0/(2*sin(pi/n1))
R2 = n0/(2*sin(pi/n2))

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)

#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6, sys)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
Point1 = Point2d(Workplane1, p0, p1)

#小圓
p7 = sys.add_param(R1)
Distance1 = Distance(Workplane1, p7)
Circle1 = Circle(Workplane1, Normal1, Point1, Distance1)

#Point2
p8 = sys.add_param(500.0)
p9 = sys.add_param(0.0)
Point2 = Point2d(Workplane1, p7, p8)

#大圓
p10 = sys.add_param(R2)
Distance2 = Distance(Workplane1, p10)
Circle2 = Circle(Workplane1, Normal1, Point2, Distance2)

#上端外切線的兩個點Point3和Point4
p11 = sys.add_param(300.0)
p12 = sys.add_param(500.0)
Point3 = Point2d(Workplane1, p11, p12)
p13 = sys.add_param(500.0)
p14 = sys.add_param(500.0)
Point4 = Point2d(Workplane1, p13, p14)

#下端外切線的兩個點Point5和Point6
p15 = sys.add_param(300.0)
p16 = sys.add_param(-500.0)
Point5 = Point2d(Workplane1, p15, p16)
p17 = sys.add_param(500.0)
p18 = sys.add_param(-500.0)
Point6 = Point2d(Workplane1, p17, p18)

...

#以下解題

sys.solve()

if (sys.result == SLVS_RESULT_OKAY):
    print ("兩點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(0).val, sys.get_param(1).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(8).val, sys.get_param(9).val, sys.get_param(2).val))
    print ("上切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
    print ("下切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val))
    print ("導入函數測試：")
    print(pi)
    print ("%d DOF" % sys.dof)
else:
    print ("solve failed")
&lt;/pre&gt;

&lt;p&gt;但是在使用畫線並約束與圓相切的指令時，之前臆測的程式碼卻沒有這個功能，於是去倉儲搜尋函式名稱。&lt;/p&gt;
&lt;p&gt;發現某些Solvespace的功能並沒有轉給CDemo使用，之前&lt;code&gt;DOC.txt&lt;/code&gt;簡介只是說明出本體支援的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;在&lt;code&gt;h++&lt;/code&gt;的標頭檔&lt;code&gt;slvs_python.hpp&lt;/code&gt;中，有以下項目：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
...
public:
    // This constructor can be used to make arbitrary
    // constraints. It has a very ugly name to discourage
    // its use. If you need a constraint that the library
    // doesn't support, you should implement it.
//以下是所有約束函式
...
&lt;/pre&gt;

&lt;p&gt;而那些沒做出的功能都用註解的方式放在這些做好的函式之間，所以看來好像是要自己做了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/3x4fBiB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;目前瞭解需要編寫的檔案為&lt;code&gt;slvs.i&lt;/code&gt;的Interface檔、&lt;code&gt;slvs_python.hpp&lt;/code&gt;標頭檔、&lt;code&gt;constrainteq.cpp&lt;/code&gt;約束方程式的函式。&lt;/p&gt;
&lt;p&gt;畢竟是用別人寫好的架構，自己修改應該沒甚麼太大的障礙，以一個Python模組而言，拓展所需才是協同作業重要之處。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323231日誌 - 105/07/25</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050725.html" rel="alternate"></link><published>2016-07-25T21:00:00+08:00</published><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-25:blog/40323231ri-zhi-1050725.html</id><summary type="html">&lt;p&gt;3DP問題、測試、解決方法&lt;/p&gt;


&lt;h3&gt;固件組裝時的問題 : &lt;/h3&gt;

&lt;h4&gt;1.熱床的安裝較不容易，因為它是暗孔所以比較難對齊，鎖固的時間較長，之後有要組一台的話要考慮是否改換成明孔&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;配電的問題 : &lt;/h3&gt;
&lt;h4&gt;1.限位開關的接法，因為限位開關有分兩種，一種是機械式微動開關，一種是光學限位開關，要怎麼接?
接法和注意事項:&lt;/h4&gt;
&lt;h4&gt;  a. 機械微動開關接法
機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;h4&gt;  b. 光學限位開關接法(我們的)
光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;h4&gt;  c.程式碼也需要改(由於我們的是光學限位所以都改成false)&lt;/h4&gt;
&lt;h4&gt;const bool X_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;h4&gt;const bool Y_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;h4&gt;const bool Z_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;測機問題 : &lt;/h3&gt;
&lt;h4&gt;1.用arduino燒入韌體時會說缺少東西，這時用(u8glib_arduino_v1.16)壓縮檔即可。&lt;/h4&gt;
&lt;h4&gt;操作方法是 : &lt;/h4&gt;
&lt;h4&gt;     a.先到網站下載u8glib_arduino_v1.16這包壓縮檔&lt;/h4&gt;
&lt;h4&gt;     b.點開arduino&lt;/h4&gt;
&lt;h4&gt;     c.點選Sketch  &lt;/h4&gt;
&lt;h4&gt;     d.點選Include Library &lt;/h4&gt;
&lt;h4&gt;     e.點選Add .ZIP Library...&lt;/h4&gt;
&lt;h4&gt;     f.選擇u8glib_arduino_v1.16&lt;/h4&gt;
&lt;h4&gt;     g.完成&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.擠出馬達不能運作,其他xyz馬達皆能動&lt;/h4&gt;
&lt;h4&gt;測試方法:&lt;/h4&gt;
&lt;h4&gt;    a.將擠出馬達的訊號線接到X軸的訊號端(馬達是否正常)，測試馬達正常&lt;/h4&gt;
&lt;h4&gt;    b.將擠出軸的訊號線由E0接到E1(測試控制板和韌體是否正常)，測試結果無法作動&lt;/h4&gt;
&lt;h4&gt;    c.將電源線和擠出訊號線接到ramps1.4和arduino上(測試控制板是否正常)，測試結果無法作動&lt;/h4&gt;
&lt;h4&gt;解決方法:因為程式碼中有保護措施，保護措施為噴頭溫度要先加熱到指定的溫度後才能啟動，怕擠料不正常。可修改此程式碼define MIN_EXTRUDER_TEMP 170&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;3.馬達旋轉方向不符&lt;/h4&gt;
&lt;h4&gt;解決方法:調整程式碼&lt;/h4&gt;
&lt;h4&gt;Repetier(0、1為正反轉)&lt;/h4&gt;
&lt;h4&gt;#define INVERT_X_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Y_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Z_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define EXT0_INVERSE 0&lt;/h4&gt;
&lt;h4&gt;Marlin(true、false為正反轉)&lt;/h4&gt;
&lt;h4&gt;#define INVERT_X_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Y_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Z_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_E0_DIR true&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;4.G28回歸的時候，Z軸不動其他兩軸馬達回歸，導致噴頭座往外跑出&lt;/h4&gt;
&lt;h4&gt;測試方法 : &lt;/h4&gt;
&lt;h4&gt;    a.打指令M119檢查限位開關是否有開，測試結果有開&lt;/h4&gt;
&lt;h4&gt;    b.用手讓限位器偵測是否會感應，測試結果有感應&lt;/h4&gt;
&lt;h4&gt;    c.檢查程式碼true/false是否正確，正確(有說明此功能的一篇)&lt;/h4&gt;
&lt;h4&gt;解決方法:更換新的杜邦端子，因為測量多次後發現時好時壞，所以猜測是訊號接收不正常，更換後能夠順利回歸&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;5.軟體關掉訊號後滑軌依然鎖住&lt;/h4&gt;
&lt;h4&gt;解決方法:關掉訊號後再連接(connect)，之後再斷掉，就可以解鎖了&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;使用韌體Repetier所碰到的問題 : &lt;/h3&gt;
&lt;h4&gt;1.噴嘴高度不管怎麼改都是319.2mm不知道為什麼?&lt;/h4&gt;
&lt;h4&gt;解決方法(還未真正找到解決方法)&lt;/h4&gt;
&lt;h4&gt;    a.修改程式碼中噴頭最大高度，可是不管怎麼改依然都是319.2mm&lt;/h4&gt;
&lt;h4&gt;    b.修改程式碼中噴頭最小高度，可是依然319.2mm&lt;/h4&gt;
&lt;h4&gt;    c.修改3軸的補正值，依然不變&lt;/h4&gt;
&lt;h4&gt;    d.修改xyz軸的最大值，發現xyz軸會超出設定的最大值，發現好像是code燒不進去，而且有看到RAM大小所以猜測是空間不足&lt;/h4&gt;
&lt;h4&gt;    e.將空白的arduino燒進控制板後，機器不能運轉表示燒入成功，之後再把修改過的韌體在燒進去，可是依然還是319.2mm&lt;/h4&gt;
&lt;h4&gt;    f.用軟體Repetier-Host直接修改高度，可是一樣還是319.2mm&lt;/h4&gt;
&lt;h4&gt;    g.改用韌體Marlin，可是Marlin卻有更多的不穩定&lt;/h4&gt;
&lt;h4&gt;    h.用Cura_15.04特別版，才成功修改，並能順利列印&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;使用韌體Marlin所碰到的問題 : &lt;/h3&gt;
&lt;h4&gt;1.G28回歸後，只能單軸單軸進行復歸補正，導致速度較慢，而且有時候複歸的途中會停下來，之後單軸複歸導致噴頭座跑出機台外。(備註:機台斷電後，軟體也要切斷訊號，不然機台重新開電後還是會繼續執行)&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.執行G28時個軸的速度，寫法與Repetier不太一樣，所以一開始沒注意到，導致速度過快差點撞機。&lt;/h4&gt;
&lt;h4&gt;#define HOMING_FEEDRATE {50&lt;em&gt;60, 50&lt;/em&gt;60, 50*60, 0}&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;列印時碰到的問題 : &lt;h3&gt;
&lt;h4&gt;1.翹邊&lt;/h4&gt;
&lt;h4&gt;解決方法:塗口紅膠在平台上，以及再加熱期間把溢出來的料弄掉，因為溢出來的料會把底層弄掀，導致沒有地基、材料高低不平&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.列印出來的東西很稀疏，而且一捏就碎&lt;/h4&gt;
&lt;h4&gt;解決方法:&lt;/h4&gt;
&lt;h4&gt;a.先加熱，之後用細的鐵絲或夾子將堵塞住的料全部清除(清理時要注意不要直接觸摸噴頭組，請用工具夾持，夾持時勿將熱敏電阻和加熱棒弄壞)，清完後用鐵氟龍管測試深度(避免之後再裝鐵氟龍管時無法到達最深部，導致又回流堵料)&lt;/h4&gt;
&lt;h4&gt;b.如果上述不行，再清理噴頭，或直接更換，我是清理完喉管後還是不行，直接更換噴頭，之後就改善了&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;3.擠出馬達持續轉動，料則是斷斷續續的進料，有時甚至完全停止&lt;/h4&gt;
&lt;h4&gt;解決方法:&lt;/h4&gt;
&lt;h4&gt;a.進入軟體(cura)的基本 -&amp;gt; 列印材料(Filament) -&amp;gt; 流量(Flow)(%) -&amp;gt;更改此數值(擠料速度會降低)&lt;/h4&gt;
&lt;h4&gt;b.還是未改善請依循:列印時碰到的問題2進行改善&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;4.列印時噴頭和熱床無法同時加熱&lt;/h4&gt;
&lt;h4&gt;還未解決&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;5.噴頭液料(部位有噴頭、喉管的鎖固部分)&lt;/h4&gt;
&lt;h4&gt;解決方法:重新鎖固，或者鎖緊即可&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;6.口紅膠的殘留，以及要拿下產品時要用刮刀拆下，導致平板會有刮傷&lt;/h4&gt;
&lt;h4&gt;還未解決，有看到網路上有人是購買專用的膠帶，不知道實不實用&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;7.馬達很燙&lt;/h4&gt;
&lt;h4&gt;還未解決，有想要在熱床下加裝風扇&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;8.如何放置料桶&lt;/h4&gt;
&lt;h4&gt;還未解決，想要製作料座，然後用軸承放置兩邊讓他能順利進料&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;持續更新&lt;/h4&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323230紀錄 - Python-Solvespace編譯完畢</title><link href="http://project.mde.tw/blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html" rel="alternate"></link><published>2016-07-24T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows執行成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu執行失敗（需重生&lt;code&gt;_slvs.so&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/E4PEUbR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後編譯時把&lt;code&gt;_slvs.so&lt;/code&gt;改成了&lt;code&gt;_slvs.pyd&lt;/code&gt;就能使用了。&lt;/p&gt;
&lt;p&gt;有測試過改成&lt;code&gt;.dll&lt;/code&gt;的方式，但是反而不能使用，可能是Windows平台Python辨認的問題。&lt;/p&gt;
&lt;p&gt;不過由於&lt;code&gt;_slvs.pyd&lt;/code&gt;是參照&lt;code&gt;libslvs.so&lt;/code&gt;的內容生成的，所以這四個檔案必須放在同一個資料夾：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;solvespace/exposed/_slvs.pyd
solvespace/exposed/libslvs.so
solvespace/exposed/slvs.py
solvespace/exposed/Usage.py
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;倉儲的Readme也做了一下說明。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;test.py&lt;/code&gt;執行結果中，偵測到&lt;code&gt;long&lt;/code&gt;還沒定義，所以資料庫還需要修理一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ejc5KDo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搬到新電腦虛擬機的Ubuntu上測試時，使用的是&lt;code&gt;_slvs.so&lt;/code&gt;的樣式。&lt;/p&gt;
&lt;p&gt;會顯示ELF標頭檔錯誤，而無法執行，應該是因為在Windows上生成的關係，重新在Ubuntu上編譯應該就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jolKcHW.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;另外在新電腦虛擬機的Ubuntu上裝了一下Git、Netbeans和GNU工具包，可以正常運作，不過可能是跨系統模擬的關係，反應還滿慢的。&lt;/p&gt;
&lt;p&gt;然後Python3不知道怎麼更新，一直在3.4.2沒辦法升上去。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/23</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050723.html" rel="alternate"></link><published>2016-07-23T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-23:blog/40323218ri-zhi-1050723.html</id><summary type="html">&lt;p&gt;V-rep   printer_control&lt;/p&gt;


&lt;h2&gt;嘗試組裝3Dprinter&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;現在已嘗試兩種方式操控&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;分別是：&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_position_control.ttt?raw=true"&gt;Printer_position_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控position(需用滑鼠移動)&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/position.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_motor_control.ttt?raw=true"&gt;Printer_motor_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控motor(需用參數移動)&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/motor.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;
&lt;h3&gt;串列通訊：&lt;/h3&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/1-CW00QXwwk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/y1vbxmeJ4M0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230紀錄 - C語言資料庫格式</title><link href="http://project.mde.tw/blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html" rel="alternate"></link><published>2016-07-23T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-23:blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html</id><summary type="html">&lt;p&gt;關於各平台程式使用之連結庫類型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Static libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shared libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically loaded libraries&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://terrycslife.blogspot.tw/2010/07/so.html" title="terrycslife.blogspot.tw"&gt;http://terrycslife.blogspot.tw/2010/07/so.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/" title="kaineshu.wordpress.com"&gt;https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.jianshu.com/p/09994c9d8489" title="jianshu.com"&gt;http://www.jianshu.com/p/09994c9d8489&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Object File :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.o&lt;/code&gt;或是&lt;code&gt;.obj&lt;/code&gt;，後者為Windows使用的格式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpxnXLj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將&lt;code&gt;.c&lt;/code&gt;或&lt;code&gt;.cpp&lt;/code&gt;、&lt;code&gt;.cxx&lt;/code&gt;的C語言程式碼包裝成的物件檔，無法直接使用。&lt;/p&gt;
&lt;p&gt;使用編譯工具的"Link"功能可以將這些單獨的物件檔合併成連結庫或是可執行檔。&lt;/p&gt;
&lt;h2&gt;Static libraries - 靜態資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作用方式：將連結庫包入程式中執行，處理效率高，缺點是檔案大且不易更新。&lt;/p&gt;
&lt;p&gt;若要建立一個靜態資料庫，可以使用DllTool從&lt;code&gt;.dll&lt;/code&gt;檔解出或是用GNU的&lt;code&gt;ar&lt;/code&gt;工具連結物件檔編譯。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar&lt;/code&gt;的指令中，&lt;code&gt;rcs&lt;/code&gt;或是&lt;code&gt;-r&lt;/code&gt;後接上輸出的檔案名稱，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar rcs libmylib.a first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生靜態資料庫後，可以使用gcc的&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;指令連結，對象包含程式碼、物件檔和其他靜態資料庫。&lt;/p&gt;
&lt;h2&gt;Shared libraries - 共用資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.so&lt;/code&gt;，後面可加掛版本編號。&lt;/p&gt;
&lt;p&gt;作用方式：資料庫和執行檔是分離的，剛開始就要載入，並且資料庫必須一直和執行檔待在一起，優點是修改方便。&lt;/p&gt;
&lt;p&gt;gcc在產生物件檔時必須加上&lt;code&gt;-fPIC&lt;/code&gt;參數，紀錄"position-independent code"，就是獨立位置碼，以紀錄存取位置的資訊。沒有使用的話只會用相對位置，不利於共享內容。&lt;/p&gt;
&lt;p&gt;再來將物件檔合併成資料庫時，加上&lt;code&gt;-shared&lt;/code&gt;參數，接著要自訂義"soname"、"real name"、"linker name"。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;soname是資料庫的名稱，通常以&lt;code&gt;lib&lt;/code&gt;開頭，包含附檔名和大版號，如&lt;code&gt;libexample.so.1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;real name是真正使用程式的資料庫名稱，包含小版號，如&lt;code&gt;libexample.so.1.0.0&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linker name是連結時的資料庫名稱，不包含版號，如&lt;code&gt;libexample.so&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;gcc使用&lt;code&gt;-Wl&lt;/code&gt;參數向內建的Link工具"ln"傳入資訊，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcc -shared -Wl,-soname,libexample.so.1 -o libexample.so.1.0.0 first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-Wl,-soname&lt;/code&gt;定義soname；輸出的檔案名稱為real name；使用&lt;code&gt;-l&lt;/code&gt;或&lt;code&gt;-l:&lt;/code&gt;連結的名稱為linker name。&lt;/p&gt;
&lt;p&gt;尋找了下&lt;a href="https://en.wikipedia.org/wiki/Soname" title="https://en.wikipedia.org/wiki/Soname"&gt;維基百科&lt;/a&gt;，似乎也能使用&lt;code&gt;-h&lt;/code&gt;和&lt;code&gt;-soname=&lt;/code&gt;來定義soname的名稱。&lt;/p&gt;
&lt;p&gt;資料庫連結時使用&lt;code&gt;ln&lt;/code&gt;指令連結兩個&lt;code&gt;.so&lt;/code&gt;檔。使用&lt;code&gt;-s&lt;/code&gt;參數為軟連結，類似捷徑式的參照；使用&lt;code&gt;-d&lt;/code&gt;參數為硬連結，類似副本的備份。&lt;/p&gt;
&lt;p&gt;最後必須用以下指令為real name創造linker name和soname的檔案（使用&lt;code&gt;-s&lt;/code&gt;或&lt;code&gt;-d&lt;/code&gt;就隨喜好了）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;linker name&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;soname&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之後可以用GNU的另一個工具"objdump"檢查連結。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objdump -p libexample.so.1.3 | grep SONAME&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生共用資料庫後，可以像靜態資料庫一樣包裝，也可以用程式呼叫。&lt;/p&gt;
&lt;p&gt;連結時有同名資料庫時會以共用資料庫優先，加上&lt;code&gt;-static&lt;/code&gt;參數可以指定靜態資料庫。&lt;/p&gt;
&lt;p&gt;而調用資料庫時是先找soname的檔案，否則會尋找linker name的檔案，可執行檔亦同。&lt;/p&gt;
&lt;h2&gt;Dynamically loaded libraries - 動態載入庫 :&lt;/h2&gt;

&lt;p&gt;為Windows中&lt;code&gt;.dll&lt;/code&gt;檔標準的模式，不過並非所有&lt;code&gt;.dll&lt;/code&gt;都是如此。&lt;/p&gt;
&lt;p&gt;作用方式：使用時才會載入，編譯時不須要相關資料庫檔案，因此常用於附加元件。&lt;/p&gt;
&lt;p&gt;使用一套DLL function來處理，標頭檔和編譯的程式碼中都會使用來傳遞訊息。&lt;/p&gt;
&lt;p&gt;gcc編譯時要加上&lt;code&gt;-ldl&lt;/code&gt;參數連結。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;後來發現gcc有時編譯「成功」的樣子可能包含著錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Pk6DJDw.jpg" &gt;&lt;/p&gt;
&lt;p&gt;今天測試了一些方法，但是明明CDemo和Python的&lt;code&gt;.so&lt;/code&gt;都是差不多的參數，編譯出的結果卻不如預期。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;libslvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o libslvs.so ../obj/util.obj ... ../obj/w32util.obj
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;_slvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o _slvs.so ../obj/util.obj ... ../obj/slvs_wrap.o -LW:/Anaconda3/libs -lPython35 -L. -l:libslvs.so
&lt;/pre&gt;

&lt;p&gt;如果編譯&lt;code&gt;_slvs.so&lt;/code&gt;時不加上後面的&lt;code&gt;-LW:/Anaconda3/libs&lt;/code&gt;、&lt;code&gt;-lPython35&lt;/code&gt;等等就會因為&lt;code&gt;slvs_wrap.o&lt;/code&gt;的&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;出問題，但是沒加上就和&lt;code&gt;libslvs.so&lt;/code&gt;一樣了。&lt;/p&gt;
&lt;p&gt;但是這樣另一個問題就產生了，因為編出來的&lt;code&gt;_slvs.so&lt;/code&gt;是「可執行檔」，不指定&lt;code&gt;-o _slvs.so&lt;/code&gt;的話就會編譯成&lt;code&gt;a.exe&lt;/code&gt;，所以其他Python程式碼都找不到（有搬到虛擬機的Ubuntu測試，也找不到）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/A9ITgDd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;想過學範例用&lt;code&gt;.c&lt;/code&gt;跳過Object File的階段直接轉成&lt;code&gt;.so&lt;/code&gt;檔，但是只有&lt;code&gt;libslvs.so&lt;/code&gt;成功，&lt;code&gt;_slvs.so&lt;/code&gt;反而在系統暫存檔Temp資料夾中找不到Python連結。&lt;/p&gt;
&lt;p&gt;之後稍微看了一下SWIG轉出的&lt;code&gt;slvs.py&lt;/code&gt;結構，呼叫的&lt;code&gt;.py&lt;/code&gt;檔必須先導入&lt;code&gt;slvs.py&lt;/code&gt;後，&lt;code&gt;slvs.py&lt;/code&gt;會視Python版本取用&lt;code&gt;_slvs.so&lt;/code&gt;的內容，再傳給需要的&lt;code&gt;.py&lt;/code&gt;檔，所以&lt;code&gt;slvs.py&lt;/code&gt;和&lt;code&gt;_slvs.so&lt;/code&gt;都必須和撰寫的&lt;code&gt;.py&lt;/code&gt;檔放在一起。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050722.html" rel="alternate"></link><published>2016-07-22T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-22:blog/40323230ri-zhi-1050722.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python-Solvespace編譯完畢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進行&lt;code&gt;_slvs.so&lt;/code&gt;呼叫測試。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已推送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯成功 :&lt;/h2&gt;

&lt;p&gt;上次編譯時一直找不到&lt;code&gt;Slvs_&lt;/code&gt;相關名稱的問題。&lt;/p&gt;
&lt;p&gt;最後發現編譯&lt;code&gt;_slvs.so&lt;/code&gt;時加入參照&lt;code&gt;libslvs.so&lt;/code&gt;資料庫的指令（&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;），就成功編譯了。&lt;/p&gt;
&lt;p&gt;結束編譯時，Makefile執行了CDemo.exe證明C語言調用&lt;code&gt;libslvs.so&lt;/code&gt;是完全沒問題的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M7G0AH3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著要試著執行Python調用&lt;code&gt;_slvs.so&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;測試test.py和Usage.py :&lt;/h2&gt;

&lt;p&gt;作者提供了2個範例使用，將它們和&lt;code&gt;_slvs.so&lt;/code&gt;放在相同目錄中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Usage.py&lt;/code&gt;是參照Readme的說明，將範例code抓下來存在&lt;code&gt;exposed&lt;/code&gt;資料夾的程式檔。&lt;/p&gt;
&lt;p&gt;然而若直接執行會出下列錯誤：&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;test.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dp86EeP.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;Usage.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/goKX3du.jpg" &gt;&lt;/p&gt;
&lt;p&gt;意思是Python無法調用&lt;code&gt;_slvs&lt;/code&gt;這個模組，大部分的原因是名稱錯誤或是沒有導入。&lt;/p&gt;
&lt;p&gt;SWIG手冊的"Using distutils"之後的幾章是講導出模組後的應用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xm3XyRs.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看了一下內容，Python導出後的模組可以作為Python的附加元件、直接呼叫、動態模組、靜態連結之類的。&lt;/p&gt;
&lt;p&gt;不過沒有解答一些例外的錯誤。&lt;/p&gt;
&lt;p&gt;但是一直找不到&lt;code&gt;_slvs.so&lt;/code&gt;，不知道是出了甚麼問題，會繼續尋找資料。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;公開倉儲 :&lt;/h2&gt;

&lt;p&gt;把目前進度推到了自己的&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;倉儲，在&lt;code&gt;exposed&lt;/code&gt;資料夾中的Makefile編輯工具位置，就能Make和Clean。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5OAbuX.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323250日誌 - V-rep 功能 (持續更新中)</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html" rel="alternate"></link><published>2016-07-20T20:37:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-20:blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html</id><summary type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;


&lt;p&gt;&lt;/br&gt;
&lt;h2&gt;Onshape繪製V-rep零件 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在Onshape新增一個零件檔 ,選擇隱私或者公開 ,目前每個人擁有的容量為10mb。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在part studio部分選擇平面當作草圖繪圖 ,功能和大多繪圖軟體相同。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;單位設置 :&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_units.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;功能表有一個(x)函數圖示 ,能夠設定變數值 ,方便用於零件設計 ,若新增一個x ,命名為a且值為10的值 ,之後在填入尺寸部分輸入#a ,則該尺寸為10。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_a.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;零件繪製好之後 ,在Assembly中引入零件。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_insert.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;先按右鍵將底座設定為fix(固定) ,組裝零件須注意 ,因為使用V-rep模擬 ,組裝時零件和零件設定小段距離(offset) ,不要完全貼合(在V-rep較易拆解零件) ,旋轉軸先透過cylindrical_mate和孔配合 ,再利用planar_mate讓軸偏移小段距離。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_offset.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;組合完畢後 ,在Assembly點選右鍵 ,輸出成stl格式檔案。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_export.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;V-rep 教學 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;導入stl檔案 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選左上方工具列File ,import ,mesh ,選取繪製的stl檔案後 ,就可以看到零件了。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;調整座標 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;若只看到零件的一部分 ,就是零件倒過來了 ,這時候點選左方零件圖示 ,再選上方工具列 ,將零件座標系設定成V-rep內(World)座標 ,最後點選上方旋轉功能 ,旋轉零件至理想角度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;轉好角度之後 ,點選上方平移功能 ,並調整Z軸高度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若零件被地板遮住 ,看不到零件 ,可先使用選平移功能 。&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;拆解零件 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在V-rep導入的stl檔都會變成一個整體零件 ,而在Onshape先組好是因為零件拆解後較容易定位 ,且座標較容易設定等等。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選欲拆解之零件後 ,點選工具列 ,編輯 ,Grouping/Merging ,Divide select shapes。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若有照上方Onshape繪製零件方式 ,零件就可以順利拆開。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入旋轉軸 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在右側視窗點選右鍵 , Add → Joint → Revolute
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;新增完成 ,快點兩下圖示 ,可以設定相關性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;橘色框框為旋轉軸長度及直徑 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;如果相關參數都設定好了 ,點選右鍵→Edit→使旋轉軸與零件結合成一物件(也可以直接用滑鼠拖曳)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結合後的從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_parent.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;旋轉軸(馬達)設定 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;先將各部位組立完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_pin.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定底座Dynamic性質 , ( X = 不打勾 )&lt;/h3&gt;
&lt;h3&gt;Body is respondable 指 是否實體化 ,若兩個實體化物件互相碰撞 ,會依照物理設定做相對反應。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定Revolute_joint(馬達)性質 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉軸Dynamic性質 ,設為動態物件
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉桿Dynamic性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在Assciated object選擇STL_Imported_sub(主體) &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後打開左方script ,並加入下面那行程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/child_script.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定完之後就可以按start ,跑老師的python範例了&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入攝影機&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;vision_sensor類型可分為 :
a.為orthographic type  及  b.為perspective type&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_types.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 ,
綠色框框為範圍內的解析度 (2^n ,2~256) ,棕色框框為攝影機大小&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將旋轉桿和攝影機結合並設定從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/add_2views.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/first_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/second_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;啟動程式來跑看看囉~&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision.gif"&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;dummy ( 虛擬座標 ) :&lt;/h3&gt;
&lt;h3&gt;dummy 能夠讓不是從屬性質的物件做相對移動, 常用於close chain, 以irb360範例來說 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;a. b.桿為示範物件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將a.及b.桿實體隱藏之後 ,能夠看到從屬於a、b桿下的dummy為重疊狀態 ,並且為互相對應(target)  &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目的是因為 ,若a桿做出任何動作(移動) ,在它從屬下的dummy會隨著target的dummy做相對運動 ,因此兩桿距離始終會保持固定 &lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件大小 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;size factor 為 目前模型的 比例 ,透過下方 Scaling 可以設定模型倍率 ,若Scaling factor 設為2 ,上方的size factor 會變成2 ,就是原始模型的2倍大&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/size_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件座標系 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;導入零件後 ,拆解發現零件的角度與V-rep右下角(World)的座標不同 ,有時對於joint的放置會變得不方便 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選要改變座標的零件後 ,在edit選單下點選Reorient bounding box→with reference frame of world 即可&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;利用三角建構零件放入joint :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;因為手臂有個齒輪 ,且有傾斜角度 ,所以需要透過零件轉換 ,並插入一個圓軸來輔助joint&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選零件後右鍵選取 Edit→Decimate selected shape後 ,選擇三角形數量 (太少圓形會變多角形 ,太多運算會變慢) ,之後點選左方 Toggle shape edit mode&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;全選所有三角形 ,並點選Extract cylinder後按OK&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後就可以順利放上joint了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape_2.png"&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050720.html" rel="alternate"></link><published>2016-07-20T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-20:blog/40323230ri-zhi-1050720.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;gcc的&lt;code&gt;-M&lt;/code&gt;類型參數問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;math.h與pyconfig.h衝突修正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用libpython35.a解決_wrap.cxx找不到函式的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Solvespace Makefile :&lt;/h2&gt;

&lt;p&gt;目前發現obj檔案無法辨識的原因是原始Makefile中加上了&lt;code&gt;-MT&lt;/code&gt;這個參數，然而沒有這個參數，只能改用&lt;code&gt;-MD&lt;/code&gt;來取代。&lt;/p&gt;
&lt;p&gt;直到Link這些obj檔時才發現，這些obj檔竟然是文字文件，而另一個Makefile導出的obj檔都相當正常。&lt;/p&gt;
&lt;p&gt;最後決定把Makefile中gcc的參數統一化，剩下才發現&lt;code&gt;-M&lt;/code&gt;系的參數會輸出信息檔，而不是物件。&lt;/p&gt;
&lt;p&gt;但是將obj檔重新連結成&lt;code&gt;solvespace.exe&lt;/code&gt;時就開始顯示大大小小的錯誤了，而且並非&lt;code&gt;-W&lt;/code&gt;的普通警告。相反的另一邊exposed資料夾就沒出現過警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/fnQrcS8.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以要成功編譯就必須將錯誤修正，看一些關於C++的資料。這些錯誤貌似都是物件繼承、指標項的用法問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2dtnGX0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過今天專注在如何克服exposed資料夾的錯誤。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;MinGW的math.h和Python的pyconfig.h :&lt;/h2&gt;

&lt;p&gt;上網搜尋了許多文章，大部分的人使用MinGW編譯C轉Python的文件時，同時導入&lt;code&gt;cmath&lt;/code&gt;和&lt;code&gt;Python.h&lt;/code&gt;都會遇到這個衝突。&lt;/p&gt;
&lt;p&gt;主要原因是＜math.h＞中有一段&lt;code&gt;_hypot(double _X, double _Y)&lt;/code&gt;的函式，而它的名稱剛好與&lt;code&gt;pyconfig.h&lt;/code&gt;中的&lt;code&gt;define hypot _hypot&lt;/code&gt;衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xdCKbBE.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網搜尋時找到一系列2013年的信件：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html" title="vtk.org"&gt;http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要是討論如何處理這個問題，信中曾建議在自己的程式碼的&lt;code&gt;include ＜Python.h＞&lt;/code&gt;下加上這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜cmath＞
#include ＜Python.h＞
#ifdef hypot
#undef hypot
#endif
&lt;/pre&gt;

&lt;p&gt;但是這樣根本不可行，因為導入&lt;code&gt;Python.h&lt;/code&gt;時就會同時導入&lt;code&gt;pyconfig.h&lt;/code&gt;，一旦導入&lt;code&gt;pyconfig.h&lt;/code&gt;就會產生衝突，後面再undefine也不會有用。&lt;/p&gt;
&lt;p&gt;所以根本的問題就是修改&lt;code&gt;pyconfig.h&lt;/code&gt;，變成這一段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef _MATH_H_
#define hypot _hypot
#endif
&lt;/pre&gt;

&lt;p&gt;讓它只能在沒有&lt;code&gt;math.h&lt;/code&gt;的時候才能使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4OWuZG1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;更改後編譯就沒有問題了。&lt;/p&gt;
&lt;p&gt;不過不知道這樣更改會不會讓Anaconda的Python衍生其他狀況。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;libpython35.a :&lt;/h2&gt;

&lt;p&gt;出現了&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;匯入函式的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
slvs_wrap.o: In function `_SWIG_Py_None':
slvs_wrap.cxx:1446: undefined reference to `__imp__Py_RefTotal'
...
&lt;/pre&gt;

&lt;p&gt;這些是SWIG自動產生的，interface無法修改。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，應該是軟體位元問題，找到了類似的問題。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/" title="gdomc.com"&gt;http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著參考另一篇文章生成&lt;code&gt;libpython35.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows" title="github.com"&gt;https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，將Python的DLL檔複製一份進Python的libs資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6CGP2VW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下載&lt;code&gt;gendef.exe&lt;/code&gt;，它也是MinGW的工具之一，從下列網址下載&lt;code&gt;gendef-1.0.1346-1-mingw32-bin.tar.lzma&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/" title="sourceforge.net"&gt;https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮進MinGW的bin資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CsH45V5.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著用CMD進入Python的libs資料夾中使用以下命令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
gendef python35.dll
dlltool --dllname python35.dll --def python35.def --output libpython35.a
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/nMybQmX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dlltool&lt;/code&gt;是GNU內建的工具，有安裝過安裝版的GNU工具包就能在本機端環境使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wAdo8A1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;做完後就會產生&lt;code&gt;libpython35.a&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;然後到Python的include資料夾開啟&lt;code&gt;pyconfig.h&lt;/code&gt;這個檔案編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oSfNLI9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋並將以下內容剪下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _WIN64
#define MS_WIN64
#endif
&lt;/pre&gt;

&lt;p&gt;貼到以下內容的「上方」：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _MSC_VER
...
&lt;/pre&gt;

&lt;p&gt;再到Python的&lt;code&gt;Lib\distutils&lt;/code&gt;資料夾中，開啟&lt;code&gt;cygwinccompiler.py&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XwvABHb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋以下內容並註解掉：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
self.dll_libraries = get_msvcr()
&lt;/pre&gt;

&lt;p&gt;注意四周會有相似的內容，不要弄錯註解。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xfY1FU0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;範例在編譯&lt;code&gt;slvs_wrap.o&lt;/code&gt;時加上&lt;code&gt;-DMS_WIN64&lt;/code&gt;參數。&lt;/p&gt;
&lt;p&gt;不過這時因為已經修改過&lt;code&gt;pyconfig.h&lt;/code&gt;的內容，會自動宣告&lt;code&gt;MS_WIN64&lt;/code&gt;，所以加上會提示說重複宣告。&lt;/p&gt;
&lt;p&gt;最後編譯用的指令如下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -IW:/Anaconda3/include -Wno-unused-but-set-variable -c -o ../obj/slvs_wrap.o slvs_wrap.cxx
g++ -shared -fPIC -o _slvs.so ... ../extlib/si/siapp.lib  -LW:/Anaconda3/libs -lPython35
&lt;/pre&gt;

&lt;p&gt;但是最後還是出現一點錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ie05RYb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;應該是內部的導入問題。&lt;/p&gt;
&lt;p&gt;由於時間不多，所以這個部分之後再解決。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天有稍微比較下Whitequark的原始碼，不過用法已經完全不一樣，相同的變數也改變了型態，更有系統性，但是也更難判讀，所以&lt;code&gt;.cpp&lt;/code&gt;的部分還得熟悉相關的知識。&lt;/p&gt;
&lt;p&gt;Solvespace Makefile的部分是編譯&lt;code&gt;solvespace.exe&lt;/code&gt;的部分，不過Python呼叫的部分應該是不用那麼多，畢竟那些大部分都是介面檔，真正的本體只需要判斷是否衝突。&lt;/p&gt;
&lt;p&gt;所以Solvespace Makefile的部分才做得漫不經心吧。&lt;/p&gt;
&lt;p&gt;exposed Makefile部分的&lt;code&gt;all&lt;/code&gt;為三個目標：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
all: cdemo _slvs.so slvs.py
    LD_LIBRARY_PATH=. ./cdemo
&lt;/pre&gt;

&lt;p&gt;CDemo的部分已經成功轉出可執行檔；&lt;code&gt;_slvs.so&lt;/code&gt;還在最後階段的編譯中；&lt;code&gt;slvs.py&lt;/code&gt;則是原作者撰寫好的（不過是Python 2）。&lt;/p&gt;
&lt;p&gt;預計不久後就能夠測試&lt;code&gt;_slvs.so&lt;/code&gt;的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050719.html" rel="alternate"></link><published>2016-07-19T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-19:blog/40323218ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;V-rep 翻譯 Inverse kinematics&lt;/p&gt;


&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK1.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Inverse kinematics enabled:   啟用或禁用所有IK計算。&lt;br&gt;
&lt;br&gt;&lt;br&gt;
•  Add new IK group: &lt;br&gt;&lt;br&gt;新增一個空的 IK group. IK groups 可以包含一個或多個 IK elements.&lt;br&gt;&lt;br&gt; IK elements 是基本運動學綁著IK任務, IK groups可以組合他們來同時運行.&lt;br&gt;&lt;br&gt; 當需要時只使用同時運行(比依序運算花較長的計算時間).&lt;br&gt;&lt;br&gt; 一個IK element 總必須被一個IK group連結，而且不能單獨存在. &lt;br&gt;&lt;br&gt;在按鈕下方的列表中顯示所有的IK groups將會在IK計算時被運行.&lt;br&gt;&lt;br&gt; 在列表中一個 IK group需要被選擇，為了顯現它的參數在剩餘的對話框中.&lt;br&gt;&lt;br&gt; 在列表中的順序很重要(IK group 1的結果可能被IK group 2需要來正確地或更快的執行).&lt;br&gt;&lt;br&gt; 在列表旁的兩個按鈕可以改變被選擇的IK group的位置.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  IK group is active:     允許啟動這個IK groups.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Explicit handling: &lt;br&gt;&lt;br&gt;表示被選擇的IK group 是否應該被明確地處理. &lt;br&gt;&lt;br&gt;如果打勾, 當呼叫simHandleIkGroup(sim_handle_all_except_explicit)時，&lt;br&gt;&lt;br&gt;在IK 計算這個IK group將不會被處理，但只有當&lt;br&gt;&lt;br&gt;simHandleIkGroup(sim_handle_all) or&lt;br&gt;&lt;br&gt; simHandleIkGroup(ikGroupHandle) 呼叫時除外. &lt;br&gt;&lt;br&gt;這是非常有用的當如果用戶希望在  child script 而不是在  main script&lt;br&gt;&lt;br&gt;處理IK group裡的kinematics  (如果沒有打勾, IK計算將會被執行兩次,一次是在&lt;br&gt;&lt;br&gt;main script呼叫simHandleIkGroup(sim_handle_all_except_explicit) 時, &lt;br&gt;&lt;br&gt;另一次是在child script 呼叫simHandleIkGroup(ikGroupHandle)時. &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Mechanism is redundant: &lt;br&gt;&lt;br&gt;當被打勾時, 在IK解析時joint限制校正將被啟用. &lt;br&gt;&lt;br&gt;否則，joint limits 將會簡單地被強制執行在IK 解析之後，可能導致不穩定.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Ignore max. step sizes:   如果被勾選，在  joint properties 裡的maximum step sizes 將會被忽略.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Calc. method: &lt;br&gt;&lt;br&gt;具體說明IK group 決定使用的計算方式. &lt;br&gt;&lt;br&gt; Pseudo inverse  是最快的方式但可能不穩定當目標與 tip lie 距離太遠, 當一個運動鏈超過限制或當機構靠近一個單一組態 或 超出目標.&lt;br&gt;&lt;br&gt;  DLS 是較慢但更穩定因為它是一個阻尼分析方式(阻尼因子可以被指定（阻尼）). &lt;br&gt;&lt;br&gt;這是一個好的選擇當  pseudo inverse可能失敗.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Damping: &lt;br&gt;&lt;br&gt;阻尼因子當使用DLS.  較大的值導致更穩定的分辨率，但速度很慢。適當地調整值是重要的。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Max. iterations: &lt;br&gt;&lt;br&gt;重複的最大數值可以被指定. 這是計算經過的最大數量對於給予的IK group，直到它指定的結果精度到達. DLS 經常需要比  Pseudo inverse更多的重複.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limits (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用在 joint limitation constraints &lt;br&gt;&lt;br&gt;(joint limitation constraints 是被指定在  joint properties &lt;br&gt;&lt;br&gt;(position minimum andposition range).&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Obstacle avoidance (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用對於 obstacle avoidance(避開障礙物) constraints.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limit thresholds:   線性和角度的臨界值應該和joint limitation constraints 一起被使用.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit conditional parameters:   調整選擇的IK group裡附加的參數 .&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK2.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;•  Perform if... : &lt;br&gt;&lt;br&gt;這是有條件的分析部分. &lt;br&gt;&lt;br&gt;使用者可以選擇下拉一個在列表中的IK group，&lt;br&gt;&lt;br&gt;這個IK分析結果將會決定當前IK group是否會被解決。&lt;br&gt;&lt;br&gt;被認為是成功的IK group計算的IK elements都位於指定的線性/角度精度內。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Restore if... : &lt;br&gt;&lt;br&gt;允許恢復初始IK group配置（goint values）如果分析沒有成功 (位置和/或定向精度沒有達到).&lt;br&gt;&lt;br&gt; 與上述條件的解結合時，用戶可以例如結合兩個不同的計算方法。&lt;br&gt;&lt;br&gt;這是有用的如果在操作者的目標可能超出範圍或靠近一個單一組態: &lt;br&gt;&lt;br&gt;第一次分析嘗試將試著求解IK group與non-damped resolution method (pseudo inverse, fast), &lt;br&gt;&lt;br&gt;而且如果不成功, 第二次嘗試將會試著解決它與damped resolution method (DLS, slower). &lt;br&gt;&lt;br&gt;使用者也當然可以自由手動地處理IK resolution 從script, plugin, 等.&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Edit obstacle avoidance parameters: &lt;br&gt;&lt;br&gt;允許調整避障參數。&lt;br&gt;&lt;br&gt;請注意，這只是對熟練的操作者有意義, &lt;br&gt;&lt;br&gt;而且模擬速度會大幅度地放緩。&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK3.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Select avoidance entities / Remove avoidance constraint: &lt;br&gt;&lt;br&gt;允許選擇/移除avoidance entities. &lt;br&gt;&lt;br&gt;一個整體通常是機器人，其他實體是障礙物。&lt;br&gt;&lt;br&gt; 使用簡單地measurable objects 來快速分析.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Distance threshold: &lt;br&gt;&lt;br&gt;在兩個avoidance entities 之間應該保持最小的距離.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit IK elements: &lt;br&gt;&lt;br&gt;允許編輯各種被選擇的IK group有關聯的IK elements.
&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050719.html" rel="alternate"></link><published>2016-07-19T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-19:blog/40323230ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;Python-Solvespace編譯除錯中。&lt;/p&gt;


&lt;h2&gt;Netbeans的版次管理與自訂工具列 :&lt;/h2&gt;

&lt;p&gt;Netbeans有內建檔案版本紀錄的功能，只要在檔案左上角的按鈕切換到&lt;code&gt;History&lt;/code&gt;，就會出現修改紀錄表。&lt;/p&gt;
&lt;p&gt;點擊其中的項目就會顯示並和目前版本的檔案做比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dwmVZD4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其中紅色是刪除；綠色是新增；藍色是取代。&lt;/p&gt;
&lt;p&gt;如果想復原其中的項目，可以移到顏色區塊上，左側的版本會出現箭頭，能夠將舊版的內容復原至當前的區段中，十分方便。&lt;/p&gt;
&lt;p&gt;若是想直接復原整個檔案，可以在紀錄上案右鍵，選擇&lt;code&gt;Revert from History&lt;/code&gt;就會復原檔案。特別的是，一但復原檔案，Netbeans就會直接儲存檔案，成為新的歷史紀錄，這方面需要多注意。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2Ih9AVd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而專案中的檔案名稱也會配上顏色，不論是在左側的檔案樹或是分頁上。&lt;/p&gt;
&lt;p&gt;黑色是一般clone下來的專案；藍色是使用者修改過的檔案（縱使已經復原到原始版本）；灰色是透過MinGW以外程式編寫的檔案；綠色是自己撰寫或是由MinGW編譯出的檔案。&lt;/p&gt;
&lt;p&gt;Netbeans是以Git功能為基礎架設的（雖然不一定要使用），因此十分注重版次管理，也支援圖形化顯示&lt;code&gt;git pull&lt;/code&gt;的修改處。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/H2v8Lve.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一個個人化的功能就是自訂工具列，能夠將內建或模組的功能鈕設置在工具列上。&lt;/p&gt;
&lt;p&gt;排列方法跟Firefox一樣是抓取的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/W7kSbRH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;上次的問題 :&lt;/h2&gt;

&lt;p&gt;上一篇網誌中的問題：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Netbeans找不到外部程式的問題已解決，只要指定程式的確切位置就能執行。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以指定Perl在W:槽的位置，上次發現的Perl其實是MinGW的附加工具，版本是5.8。&lt;/p&gt;
&lt;p&gt;但是新下載的是5.24，並且有安裝需要的模組"GD"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zSV5yLU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/NjpIYjZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改成下面這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
PERL = W:\Perl524\bin\perl.exe

...

$(OBJDIR)/icons.h: png2c.pl icons/*
    @echo icons
    $(PERL) $＜ $@ $(OBJDIR)/icons-proto.h
&lt;/pre&gt;

&lt;p&gt;指定後就可以執行。&lt;/p&gt;
&lt;p&gt;而後來又有一個"rc"的指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(RES): win32/$(@B).rc icon.ico
    rc win32/$(@B).rc
    mv win32/$(@B).res $(OBJDIR)/$(@B).res
&lt;/pre&gt;

&lt;p&gt;（原始版本的錯誤用法＄(＠B)應該為＄(＠F)，都改為＄＜或＄^較明瞭）&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;經查詢資料，"rc.exe"原是Windows Kits的一個工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QWfaVfq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以就改寫用變數指定。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
RC = "C:\Program Files (x86)\Windows Kits\$(RCVER)\bin\$(RCBIT)\rc.exe"
RCVER = 10
RCBIT = x64

...

$(RES): resource.rc icon.ico
    @echo RES
    $(RC) $＜
    mv win32/resource.res  $@
&lt;/pre&gt;

&lt;p&gt;同理，其他如SWIG都可以呼叫所在位置來執行了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要改一下語法，之前使用的&lt;code&gt;-lslvs&lt;/code&gt;應該指定名稱&lt;code&gt;-l:libslvs.so&lt;/code&gt;並指定同目錄：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
cdemo: CDemo.c libslvs.so
    @echo cdemo
    @$(CXX) $(CFLAGS) -o $@ $＜ -L. -l:libslvs.so $(LIBS)
&lt;/pre&gt;

&lt;p&gt;接著就能夠找到libslvs.so。&lt;/p&gt;
&lt;p&gt;不知道是因為沒有&lt;code&gt;-L&lt;/code&gt;指定目錄還是&lt;code&gt;-l&lt;/code&gt;不會看附檔名的關係，一定要標定到檔案才會容許。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;錯誤紀錄 :&lt;/h2&gt;

&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Function "vasprintf"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在"slvs_python.hpp"中，導入了一個stdio.h的函式&lt;code&gt;vasprintf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不過其實正確名稱應該要增加父項式，因此修改成&lt;code&gt;__mingw_vasprintf(&amp;amp;buf, fmt, args)&lt;/code&gt;就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/czsgUbf.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeams應該是支援h++的標頭檔，但是"slvs_python.hpp"的前半段錯誤累累，應該是從屬關係和宣告的部分沒弄清楚。&lt;/p&gt;
&lt;p&gt;目前並沒有干擾MinGW的編譯，但是這些東西應該重新整理一下，尤其是下面的導入：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜string＞
#include ＜exception＞
&lt;/pre&gt;

&lt;p&gt;在編寫時好像連結不到，但是編譯時MinGW抓得到，不知道Netbeams的錯誤有沒有算入這種情形。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CMath&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用SWIG剛轉出"slvs_wrap.cxx"時產生的問題。&lt;/p&gt;
&lt;p&gt;出現一段錯誤：&lt;code&gt;error: '::hypot' has not been declared&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在其他人的commit中有解答：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/casadi/casadi/issues/622" title="github.com"&gt;https://github.com/casadi/casadi/issues/622&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是說要新增&lt;code&gt;include ＜cmath＞&lt;/code&gt;進"slvs_wrap.cxx"中，而且必須在"Python.h"之前。&lt;/p&gt;
&lt;p&gt;所以我就在interface檔中新增了，讓轉換時會自動加入這段。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cqgzD3B.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個問題是暫時解決，後來又有相關的麻煩。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;分成兩部分的Makefile，主要是exposed資料夾的python函式比較重要。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在最後一個要生成"solvespace.exe"時無法辨識&lt;code&gt;.obj&lt;/code&gt;檔案？&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32 -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS   obj/ratpoly.obj ... obj/resource.res -o obj/solvespace.exe
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj: file format not recognized; treating as linker script
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj:1: syntax error
collect2.exe: error: ld returned 1 exit status
make.exe": *** [obj/solvespace.exe] Error 1
&lt;/pre&gt;

&lt;p&gt;目前還不知道怎麼辦，因為不太了解&lt;code&gt;.o&lt;/code&gt;和&lt;code&gt;.obj&lt;/code&gt;的關係。&lt;/p&gt;
&lt;p&gt;前者是暫時等待編譯的物件，後者是給記憶體參照的。&lt;/p&gt;
&lt;p&gt;gcc對於副檔名是很重視的，可能要調整參數之類的？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Exposed Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;剩下幾步可以編成"slvs_wrap.o"。&lt;/p&gt;
&lt;p&gt;最後跳出的錯誤，竟然是內建資料庫的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
In file included from W:/Anaconda3/include/Python.h:8:0,
                 from slvs_wrap.cxx:14:
W:/Anaconda3/include/pyconfig.h:262:15: error: 'std::_hypot' has not been declared
 #define hypot _hypot
               ^
make.exe": *** [../obj/slvs_wrap.o] Error 1
&lt;/pre&gt;

&lt;p&gt;導入"Python.h"和相關的"pyconfig.h"時出現了錯誤。是從上面cmath衍生的問題。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，好像找不到解決方法，&lt;code&gt;'std::_hypot' has not been declared&lt;/code&gt;好像有出現在MinGW的Bug紀錄中。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這兩個Makefile的使用參數大相逕庭，以下是比較：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DEFINES = -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32
CFLAGS = -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Exposed&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
WIN_DEFINES = -D_WIN32_WINNT=0x500 -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN
DEFINES = -DISOLATION_AWARE_ENABLED -DLIBRARY
CFLAGS  = -I../extlib -I../../common/win32 -I. -I.. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS -O2 -g -Wno-write-strings -fpermissive
CFLAGS_SHARED = -fPIC -shared $(CFLAGS)
&lt;/pre&gt;

&lt;p&gt;兩個Makefile編譯階段都進入整合階段，剩下的一些編譯問題主要是對MinGW的編譯程式不熟悉的緣故。&lt;/p&gt;
&lt;p&gt;像是一般的&lt;code&gt;.so&lt;/code&gt;、&lt;code&gt;.o&lt;/code&gt;都較為廣用，可是將obj檔直接轉換成可執行檔，卻找不到範例。&lt;/p&gt;
&lt;p&gt;之後要再找找看gcc和g++的編譯範例。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050718.html" rel="alternate"></link><published>2016-07-18T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-18:blog/40323230ri-zhi-1050718.html</id><summary type="html">&lt;p&gt;改寫Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;前言 :&lt;/h2&gt;

&lt;p&gt;閱讀GNU-Make的手冊之後，已經了解Makefile基本的運作方式，所以試圖解決Python-Solvespace編譯程序中出現的問題。&lt;/p&gt;
&lt;p&gt;手冊連結：&lt;a href="https://www.gnu.org/software/make/manual/make.pdf" title="gnu.org"&gt;https://www.gnu.org/software/make/manual/make.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用Interface來轉換Whitequark的新版Solvespace應該是不太可行的方式了，何況Python-Solvespace也未使用全部的功能，我們需要的是解題的函式就好。&lt;/p&gt;
&lt;p&gt;而另一方面Solid-python現在已經完全支援Python 3，若之後要調用其功能，應該也不會有太大的障礙。&lt;/p&gt;
&lt;p&gt;所以決定把Python-Solvespace的Makefile重新寫好，將Python-Solvespace的資料庫建構完成。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Netbeans的支援 :&lt;/h2&gt;

&lt;p&gt;其實Netbeans與$GNU開發者工具包$周邊的軟體都有良好的相依性，因此在撰寫Makefile時方便不少。&lt;/p&gt;
&lt;p&gt;在編寫完Makefile時，可以在個別的Makefile上點擊右鍵，選擇需要的命令讓make執行，諸如all、clean等等的功能可以選擇。&lt;/p&gt;
&lt;p&gt;Makefile中可以撰寫功能讓工程師執行，連基本的clean功能也可以自訂要刪除哪些檔案。&lt;/p&gt;
&lt;p&gt;當然利用這點，Makefile中也可以利用Echo做help的功能，Whitequark的Solvespace就有支援。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9DDeyVj.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編寫Makefile :&lt;/h2&gt;

&lt;p&gt;原本Python-Solvespace的Makefile是將檔案分類，再一類類用一樣的式子做轉換，而且語法冗長還有許多錯誤。若有新增檔案，就必須填入參數的名單中登記。&lt;/p&gt;
&lt;p&gt;一個小型程式專案的Makefile事實上只需要下列的式子就能轉換：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(ADIR)/%.obj: $(BDIR)/%.cpp $(HEADERS)
    $(CXX) $(FLAGS) -c -o $@ $＜
&lt;/pre&gt;

&lt;p&gt;意思是ADIR中的obj檔都與BDIR的cpp檔、標頭檔有關聯，而每個obj檔是由每個cpp檔透過＄(CXX)命令式產生的。&lt;/p&gt;
&lt;p&gt;$後面的＄＠表示每個目標項（包括其位置）$；同理，$＄＜亦代表每個參照項$，不過＄＜是只包含第一個條件的參照項，所以後面的多個標頭檔就不會帶入＄(CXX)命令中。&lt;/p&gt;
&lt;p&gt;若要在命令式中使用所有條件的參照項，要使用＄+，但是更好的選擇是使用＄^，會自動排除重複名稱的參照項。&lt;/p&gt;
&lt;p&gt;這樣寫固然簡單，但是每個檔案都在不同的資料夾中，要如何讓make搜尋？&lt;/p&gt;
&lt;p&gt;所以必須加上VPath這個參數，讓尋找參照檔案時可以搜尋到所有符合的項目。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wpUqKDX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;make在找檔案時最大的特性就是$按邏輯去找$。&lt;/p&gt;
&lt;p&gt;也因為這點，不用顧慮產生檔案的順序問題。只要"填寫"檔案是如何產生的，make就會根據需要的檔案來做順序調整。&lt;/p&gt;
&lt;p&gt;make會先忽略還沒產生的參照檔案，尋找已經備齊參照檔案的項目先做，指令亦可使用外部程式來執行。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯瓶頸 :&lt;/h2&gt;

&lt;p&gt;經過重新整理的Makefile，應該是沒有問題了，都將指令分配完整沒有衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IkKQSqe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是仍然遇到Makefile以外的一些問題。&lt;/p&gt;
&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Stdint.h&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;這個原先是C語言的額外函式庫，幫助統一化使用的格式，但是如果沒裝，就會選擇作者寫的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Rz3xBwO.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個地方應該是寫錯了，會一直認為這些是未定義的格式。&lt;/p&gt;
&lt;p&gt;其實導入"stdint.h"的地方也只有上圖的前半段，所以最快的解決方法就是讓solvespace.h擁有stdint.h一部份的能力。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BireSqB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在上面這張Netbeans的比較圖中，直接把前半段的功能插進來用了，並成功解決問題。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Min &amp;amp; Max Functions&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下列solvespace.h的函式出了問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef min
#define min(x, y) ((x) &lt; (y) ? (x) : (y))
#endif
#ifndef max
#define max(x, y) ((x) &gt; (y) ? (x) : (y))
#endif
&lt;/pre&gt;

&lt;p&gt;上網搜尋了一下，找到基本款的用法：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#define min(x, y) (((x)＜(y)) ? (x):(y))
#define max(x, y) (((x)&gt;(y)) ? (x):(y))
&lt;/pre&gt;

&lt;p&gt;加上括弧其實非必要，因為三元運算子的優先度本身就比大於小於還低。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l5u0t2N.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個判斷式使用上怪怪的，移除後直接define就沒這個問題了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Object-oriented problem&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在surface.h中有一段是這樣描述的：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;到stackoverflow.com的論壇尋找後，有相似的問題。&lt;/p&gt;
&lt;p&gt;是物件導向的從屬錯誤，不應該重複稱呼，但是編譯器通常不會抓這種錯誤，解決方法是刪掉前面的父項名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PC43snc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後變成：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;也是成功解決。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先是圖示(icon)的問題。&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者使用另一個語言$Perl$的程式來做出"icons.h"這個檔案。&lt;/p&gt;
&lt;p&gt;Perl是一個高階語言，特點就是除了自己的寫法，還可以安裝大量模組來改變撰寫方式，甚至還繼承許多C語言的標準式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/eXwWp0J.jpg" &gt;&lt;/p&gt;
&lt;p&gt;安裝方式跟Python相同，複製檔案跟設定環境變數就能使用了。&lt;/p&gt;
&lt;p&gt;作者用了"GD"這個模組來導出"icons.h"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y1p6Mck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeans雖然也有Perl的附加元件，但是功能比SciTE還陽春，就沒使用它了。&lt;/p&gt;
&lt;p&gt;Perl的副檔名是pl，專案中有"png2c.pl"和"pngchar2c.pl"，應該就是將PNG檔導入C語言中的意思，Makefile中是要執行"png2c.pl"並產生出"icons.h"和"icons-proto.h"的樣子，不過"icons-proto.h"不會用到。&lt;/p&gt;
&lt;p&gt;在Netbeans中似乎無法呼叫外部程式，會顯示無法找到Perl指令的訊息。&lt;/p&gt;
&lt;p&gt;可是到CMD中執行時又會發生無法回應的情況，接著make就會因為找不到"icons.h"而無法編譯。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在exposed資料的Makefile中，g++的參數中需要導入資料庫"-lslvs"。&lt;/p&gt;
&lt;p&gt;而在上一個步驟中，"libslvs.so"確定已經產生，但是找不到的狀況。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/67n3jzL.jpg" &gt;&lt;/p&gt;
&lt;p&gt;網路上普遍都是需要資料連結和打錯名稱，但是好像沒這種狀況，莫非是"libslvs.so"產生失敗，或是並非"slvs"這個名稱？&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者有特別指名不要使用DLL做副檔名。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次學到了編譯程式重要的一環，雖然make的過程中很煩人，也要一直注意是否出錯，但是最後成功時滿有成就感的。&lt;/p&gt;
&lt;p&gt;有些錯誤當下想不出來，不過換一種想法後就能克服許多障礙，訓練眼光放遠也是一件重要的事情。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/17</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050717.html" rel="alternate"></link><published>2016-07-17T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-17:blog/40323218ri-zhi-1050717.html</id><summary type="html">&lt;p&gt;V-rep_solvespace_linkages&lt;/p&gt;


&lt;h2&gt;嘗試 vrep_solvespace_linkages&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/linkages.png" weight=600 &gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;影片教學：&lt;/h2&gt;
&lt;br&gt;
&lt;iframe src="https://player.vimeo.com/video/175117655" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href="https://vimeo.com/175117655"&gt;vrep_solvespace_linkages&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;檔案：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/solvespace_successful.ttt?raw=true"&gt;solvespace_successful.ttt&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;心得：&lt;/h2&gt;
&lt;h3&gt;組裝這個物件的重點我認為是在零件的順序和Dummy放置的位置，嘗試了兩天終於作了出來，對零件的從屬關係有比較OK了，有學會dummy的應用，再來就是把這些統整可以試著弄我們的 printer。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230紀錄 - Makefile的建構</title><link href="http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html" rel="alternate"></link><published>2016-07-16T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-16:blog/40323230ji-lu-makefilede-jian-gou.html</id><summary type="html">&lt;p&gt;閱讀GNU-Make相關的知識。&lt;/p&gt;
&lt;p&gt;嘗試了解Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;Makefile簡介 :&lt;/h2&gt;

&lt;p&gt;閱讀資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://mropengate.blogspot.tw/2015/06/makefile-makefile.html" title="mropengate.blogspot.tw"&gt;http://mropengate.blogspot.tw/2015/06/makefile-makefile.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)" title="jeff71321.pixnet.net"&gt;http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU-Make在開發者工具包有著極其重要的地位，最大的好處就是「自動化編譯」。&lt;/p&gt;
&lt;p&gt;相較於要用shell來執行編譯的Script，GNU-Make可以只針對部分內容作測試，相當有自由度。&lt;/p&gt;
&lt;p&gt;make.exe依靠著Makefile的設定來將整個專案按照原作者的設定，編譯成可執行文件或是連結庫。&lt;/p&gt;
&lt;p&gt;也因為如此，只要是願意加入專案協同的工程師，裝好原作者使用的工具，無論使用哪個編譯程式，就能利用一個make命令，從頭到尾將專案編譯好進行測試或除錯。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;注意事項 :&lt;/h2&gt;

&lt;p&gt;GNU-Make在閱讀一份Makefile時有幾個重點。&lt;/p&gt;
&lt;p&gt;首先若直接執行make指令，會尋找當前目錄中叫"Makefile"或"makefile"的文件。若Makefile並非這兩個名稱（亦能自訂附檔名），可以加上"-f"參數指定Makefile的名稱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Makefile中包含了&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;1.&lt;em&gt;顯式規則&lt;/em&gt;：說明如何生成一個或多個文件，有使用工具、依賴文件、使用參數等等。&lt;/p&gt;
&lt;p&gt;2.&lt;em&gt;隱晦規則&lt;/em&gt;：不太瞭解這個功能，大約是利用自動推導原則，可以比較簡略地寫定義，篩選檔案。&lt;/p&gt;
&lt;p&gt;3.&lt;em&gt;變量&lt;/em&gt;：自訂參數的功能，能自由更改位置或目標名稱、使用工具和參數等等。&lt;/p&gt;
&lt;p&gt;4.&lt;em&gt;文件指示&lt;/em&gt;：Makefile之間是可以互相溝通的，也可以透過情況作出判斷。&lt;/p&gt;
&lt;p&gt;5.&lt;em&gt;註解&lt;/em&gt;：Makefile的註解符號是"#"，如果要使用井字符號，必須使用反斜線"#"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/j8IrEeN.jpg" &gt;&lt;/p&gt;
&lt;p&gt;特別注意，在Makefile中，命令項的起始一定要使用Tab縮排，不可使用空白字元。&lt;/p&gt;
&lt;p&gt;一般撰寫程式的編譯器都能檢視空白字元的類型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SciTE&lt;/em&gt;：View -&amp;gt; Whitespace&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qBsEJnx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Netbeams&lt;/em&gt;：View -&amp;gt; Show Non-printable Characters&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/f1srj0r.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在此會發現Tab（→）和空白字元（.）的差異。&lt;/p&gt;
&lt;p&gt;不過某些像是SciTE的編譯器，在按下Tab鍵時，會幫使用者轉換成四個空白字元，甚至會用空白字元補齊縮排，所以使用上需要注意。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xfUR3YE.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Fxn6RF6.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Makefile中的目錄分隔號是斜線"/"，換行閱讀符號是反斜線"\"。&lt;/p&gt;
&lt;p&gt;GNU-Make在執行途中遇到錯誤就會停止並跳出，所以必須要整個Makefile和編譯過程都沒有干擾執行問題，才會編譯完畢。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;主要規則 :&lt;/h2&gt;

&lt;p&gt;語法的結構就是目標文件（未生成）後方加上冒號和空格，接著同一行中必須接上會利用到的檔案名稱（不包含工具和include參數的項目）。&lt;/p&gt;
&lt;p&gt;第二行是寫下如何產生目標文件的命令。&lt;/p&gt;
&lt;p&gt;一個項目中有多個檔案時會用一個空白字元分隔。換行時如果想縮排以便閱讀，必須使用空白字元縮排，不然Tab起始的項目都會視為命令。&lt;/p&gt;
&lt;p&gt;而如果命令不能執行時就會中斷操作。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/R9ZtTgK.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Makefile中的參數定義和大部分的語言雷同。不過為了明顯標示，大部分使用者習慣大寫字母。&lt;/p&gt;
&lt;p&gt;定義項目後，使用"＄( )"符號括住來使用變數。變數可以是目錄位置、命令名稱、參數名稱，亦有如"＄＄(basename ＄＄(notdir ＄＄@))"內定的用法。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/weJOnmA.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;途中用Netbeams作輔助檢查檔案關聯性和編寫文件，並make專案。&lt;/p&gt;
&lt;p&gt;不過用cmd下指令也是可行。只是直接打make會用到MinGW的make，必須先指定MSYS的make。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/283ZkZJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Python-Solvespace中的Makefile編寫有一些小缺漏，是Tab和空白字元的問題，後來改正就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KG4JYdS.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過後來在Netbeams編譯外層"Solvespace"時出現了一些問題：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jkkUFzC.jpg" &gt;&lt;/p&gt;
&lt;p&gt;檢查了一下，似乎中間的檔案"＄(SRFOBJS)"找不到？而"＄(SRFOBJS)"的檔案是從"srf\＄(@B).cpp"和"＄(HEADERS)"產生的。&lt;/p&gt;
&lt;p&gt;其中"srf\＄(@B).cpp"應該就是取下所有\srf資料夾的cpp檔案，配上標頭檔後生成obj檔。途中不知道什麼原因obj檔沒有產生，所以才會無法找到？&lt;/p&gt;
&lt;p&gt;但是只編譯exposed資料夾的Makefile時又有這個問題：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/0Mv3ISG.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網檢查了一下這段的用途是編碼對應，可是語法照常來講應該沒錯才是。&lt;/p&gt;
&lt;p&gt;而且後面對應的檔案導入時都出錯，所以就停止了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KzAVcOg.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Makefile和cmake的CMakelist.txt一樣都是工程師自己要創建的，所以又是一項工程，不過除了一些內定代號，其他都滿好理解的。&lt;/p&gt;
&lt;p&gt;找了一下Python-Solvespace相關的網站，但是內容都好少。不過在Github的說明已經滿詳盡了，只是倉儲內的資料時間有點久遠，所以要花些時間偵錯。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050715.html" rel="alternate"></link><published>2016-07-15T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-15:blog/40323218ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;V-rep 程式應用&lt;/p&gt;


&lt;h2&gt;從 irb360 程式中找尋可能用到的並嘗試解釋和整理。 &lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;
simGetObjectHandle - 對物件命名&lt;br&gt;
&lt;br&gt;
用法： number objectHandle=simGetObjectHandle(string objectName)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointTargetPosition - 設置目標位置(if the joint is in torque/force mode)(motor and position control are enabled)&lt;br&gt;
&lt;br&gt;
用法： number result=simSetJointTargetPosition(number objectHandle,number targetPosition)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetJointPosition - 得到軸的位置(不能使用在關節上 , 用simGetJointMatrix取代)&lt;br&gt;
&lt;br&gt;
用法： number position=simGetJointPosition(number objectHandle)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSwitchThread - 轉換到另一個程式&lt;br&gt;
&lt;br&gt;
用法： number result=simSwitchThread()&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simAddStatusbarMessage - 增加一則訊息到狀態欄&lt;br&gt;
&lt;br&gt;
用法： number result=simAddStatusbarMessage(string message)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetIkElementProperties - 設置性質的特定反向運動元素&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil&lt;br&gt;
&lt;br&gt;
補充：  IK = Inverse kinematics(在左邊功能區第三個裡)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointMode - 設置joint的操作模式&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetJointMode(number jointHandle,number jointMode,number options)&lt;br&gt;
&lt;br&gt;
補充：  option(現在設定為0是可以被使用，如果設定為1會啟用hybrid mode)&lt;br&gt;
&lt;br&gt;
jointMode&lt;br&gt; 
sim_jointmode_passive&lt;br&gt;
sim_jointmode_motion_deprecated&lt;br&gt;
sim_jointmode_ik&lt;br&gt;
sim_jointmode_ikdependent&lt;br&gt;
sim_jointmode_dependent&lt;br&gt;
sim_jointmode_force&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetObjectAssociatedWithScript - 擷取角本附加到物體處理&lt;br&gt;
&lt;br&gt;
用法：  number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle)&lt;br&gt;
&lt;br&gt;
補充：  scriptHandle = sim_handle_self&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simRMLMoveToJointPositions - 在同一時間幾個關節一起使用Reflexxes Motion Library type IV移動（驅動）。這功能只能在child scripts中一個thread中運行（因為這是一個阻塞的操作），而且C-API的不可使用。&lt;br&gt;
&lt;br&gt;
用法：number result , table newPos , table newVel , table newAccel , number timeLeft =
simRMLMoveToJointPositions ( table jointHandles , number flags , table currentVel , table currentAccel , table maxVel , table maxAccel , table maxJerk , table targetPos , table targetVel , table direction)&lt;br&gt;
&lt;br&gt;
補充：&lt;br&gt; 
jointHandles: 要驅動的joint&lt;br&gt;
flags: RML flags. -1 for default flags.&lt;br&gt;
currentVel: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
currentAccel: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used.&lt;br&gt;
maxVel: the maximum allowed velocity of the joints&lt;br&gt;
maxAccel: the maximum allowed acceleration of the joints&lt;br&gt;
maxJerk: the maximum allowed jerk of the joints&lt;br&gt;
targetPos: the desired target positions of the joints&lt;br&gt;
targetVel: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
direction: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints&lt;br&gt;
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(待補充)&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050715.html" rel="alternate"></link><published>2016-07-15T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-15:blog/40323230ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;研究Python-Solvespace。&lt;/p&gt;


&lt;h2&gt;更新Anaconda3 :&lt;/h2&gt;

&lt;p&gt;從官方網站下載最新的Anaconda 3，配有Python 3.5.2。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.continuum.io/downloads" title="continuum.io"&gt;https://www.continuum.io/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Path指令檢查環境變數。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vvpj0ZV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;確定無誤後放入可攜式環境中，並把原本的Python 3.5移除，將start.bat的環境位置改成Anaconda的資料夾。&lt;/p&gt;
&lt;p&gt;接著再檢查Anaconda程式的運作狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2CfbnMR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;安裝了其他工具，也包含Leo 5.3。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BkhZNCL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;說明 :&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/BBBSnowball/python-solvespace" title="github.com"&gt;Python-Solvespace&lt;/a&gt;是由BBBSnowball所開發的Solvespace函式庫，另外能調用Solid-python來協助運算。&lt;/p&gt;
&lt;p&gt;Python-Solvespace最後一次更新是在2013年，所以使用的是Python 2，SWIG可能也是舊版的。&lt;/p&gt;
&lt;p&gt;而根據協同者們留下的"VbDemo.vb"紀錄，應該是用VC來編譯它的。&lt;/p&gt;
&lt;p&gt;若要使用Solid-python，必須用"git submodule update --init"指令額外下載它，不然只有空資料夾。&lt;/p&gt;
&lt;p&gt;不過目前沒有要使用Solid-python，所以可以不用下載。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cn1yVuk.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照Readme的說明，要用make指令來編譯檔案。&lt;/p&gt;
&lt;p&gt;但是在make的時候出錯了，顯示"missing separator. Stop."的錯誤，查了下面的網站，貌似是make.exe的新版本讀取舊的Makefile的問題，必須改寫他們的Makefile或使用舊版的MSYS。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/" title="crifan.com"&gt;http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而顯示的錯誤如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/P2M54ZE.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;與Whitequark的版本比較 :&lt;/h2&gt;

&lt;p&gt;不過Python-Solvespace有留下來interface的檔案，但是它的檔案結構已經跟Whitequark的版本不一樣了，所以也不能直接讓interface對應新版的檔案來創建。&lt;/p&gt;
&lt;p&gt;好消息是SWIG的interface檔案改變不大，新版仍能使用。只要切換到\exposed資料夾，使用下列指令就能生成"slvs_wrap.cxx"。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -c++ -python -py3 slvs.i
&lt;/pre&gt;

&lt;p&gt;新版有用到cmake來建置檔案，但是Python-Solvespace沒有，所以沒有CMakelist的清單。而CMakelist是要手動編寫的，視規模大小來分配。&lt;/p&gt;
&lt;p&gt;Python-Solvespace似乎是只有原本Solvespace的"src"資料夾部分（不過外面原本就是給編譯器介紹用）。&lt;/p&gt;
&lt;p&gt;並將"exposed"、"extlib"、"win32"等資料夾放了進來，並且將總標頭檔"slvs.h"和DLL的"lib.cpp"加入"exposed"中，讓CDemo成為主幹，調用Solvespace裡的約束函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RJZXL0w.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是"exposed"中除了原本的CDemo，還有一個h++的標頭檔"slvs_python.hpp"、一個"DOC.txt"說明Python要如何呼叫編譯好的函式列表，以及一些Python的小程式。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;test.py :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/inHplBd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;py檔總共有3個，其中一個是使用Solid-python的呼叫工具，其他的"test.py"分別用"2.scad"和"3.scad"命名。&lt;/p&gt;
&lt;p&gt;檢查了一下Python-Solvespace附上的py檔，最後作者做了3個測試，並寫下了一些註解。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FqBe5Ba.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第一個"test.py"，展示了Python要如何取用slvs.dll的函式，長得跟原先的"CDemo.c"十分相似。&lt;/p&gt;
&lt;p&gt;在這裡，可以注意到SWIG轉換後的函式名稱還是一樣，用法也極其相似。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IhJD1yg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第二個"test2.scad.py"匯入了slvs和solid。&lt;/p&gt;
&lt;p&gt;由於Python只要在附近資料中尋找到宣告的項目就可運作，所以不太確定它們的副檔名究竟是DLL還是SO、PYD之類的連結庫或Python程式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cHzJVHz.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第三個"test3.scad.py"明顯使用了"slvs_solid.py"的內容，不過只有稍微閱讀過Solid-python的Readme，所以不太知道它的函式，但是看似比Solvespace更方便。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TmysKJC.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次在Python-Solvespace碰上一些小瓶頸。&lt;/p&gt;
&lt;p&gt;主要是MSYS的Makefile問題，論壇上滿多人討論它在編譯時的障礙，有時連參數前加個空格都會顯示錯誤，無法進行。&lt;/p&gt;
&lt;p&gt;而Python-Solvespace應該是用不到cmake（因為原作者是用VC），如果需要用到Netbeams，就要自行撰寫一份CMakelist，或是在編譯器中捨棄它的功能。&lt;/p&gt;
&lt;p&gt;至於需要Python 2轉Python 3的部分比較少，除非要動用Solid-python的內容。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category></entry><entry><title>40323231日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T21:00:00+08:00</published><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323231ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;3DP碰到的問題及解決&lt;/p&gt;


&lt;h3&gt;第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床?&lt;/h3&gt;
&lt;h3&gt;解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為"+""-""S"顏色分別為"紅""藍""黑"，夢工老師接的是"+"接紅，"-"接藍，"S"接黑。網路是"+"接紅，"-"接黑，"S"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。&lt;/h3&gt;
&lt;h3&gt;問題:1. "+""-""S"如何接?  2.為何線路有的接兩條有的接三條?&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;限位開關分兩種:&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;1. 機械微動開關接法&lt;/h3&gt;
&lt;h4&gt;機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;2. 光學限位開關接法(我們的)&lt;/h3&gt;
&lt;h4&gt;光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;1.S為藍，+為紅，-為黑&lt;/h3&gt;
&lt;h3&gt;2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天進度&lt;/h3&gt;
&lt;h4&gt;組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作&lt;/h4&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323218日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323218ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h2&gt;翻譯文章重點&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h2&gt;原文章網址：&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm "&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm &lt;/a&gt;&lt;/p&gt; 
&lt;br&gt;
&lt;h2&gt;Building the visible shapes：&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;1. Automatic mesh division：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Divide selected shapes]&lt;br&gt;
(自動分割物件，有時候會無作用)&lt;br&gt;
[Menu bar --&amp;gt; Edit -&amp;gt; Grouping/Merging --&amp;gt; Merge selected shapes]&lt;br&gt;(使選擇的物件組合在一起)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;2. Extract the convex hull：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
(使物件轉換成convex hull)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;3. Decimate the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Decimate selected shape...]&lt;br&gt;
(減少mesh三角形量)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;4. Remove the inside of the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Extract inside of selected shape]&lt;br&gt;
(此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;下圖說明上述功能應用到imported mesh（沒有第一項）：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;再來我們要分割imported mesh，有兩種方式可使用。&lt;br&gt;&lt;br&gt;
1. Automatic mesh division：跟上面一樣
&lt;br&gt;
2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。&lt;/h3&gt;
&lt;br&gt;
&lt;h2&gt;Building the joints&lt;/h2&gt;&lt;br&gt;
&lt;h3&gt;再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep2.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt; 右鍵→Add→Joint→Revolute(創建一個Revolute joint)，
再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep3.png" weight=600 &gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep4.png" weight=600 &gt;
&lt;br&gt;
&lt;h2&gt;Building the dynamic shapes&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是：&lt;br&gt;&lt;br&gt;
1. dynamic or static：&lt;br&gt;
dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。&lt;br&gt;
static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著
運動移動。&lt;br&gt;&lt;br&gt;
2. respondable or non-respondable：&lt;br&gt;
respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。&lt;br&gt;non-respondable shapes 是相反，他們不會造成碰撞運動。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀：&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;1. Pure shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape]&lt;br&gt;
一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。&lt;br&gt;
&lt;br&gt;
2. Pure compound shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
它是由多個Pure shape組合而成的，功能跟Pure shape雷同。
&lt;br&gt;
&lt;br&gt;
3. Convex shapes：&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex hull of selection] &lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。
&lt;br&gt;
&lt;br&gt;
4. Compound convex shapes, or convex decomposed shapes&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex decomposition of selection...]&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into its convex decomposition...]&lt;br&gt;
它是由多個convex shapes組合而成的，功能跟convex shapes雷同。
&lt;br&gt;
&lt;br&gt;
5. Random shapes：&lt;br&gt;
一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。&lt;/h3&gt;&lt;br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;試圖解決SWIG問題&lt;/p&gt;


&lt;h2&gt;撰寫批次檔 :&lt;/h2&gt;

&lt;p&gt;依照&lt;a href="http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html" title="ittc.ku.edu"&gt;http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html&lt;/a&gt;提供的gcc指令，撰寫了3個批次檔來執行。&lt;/p&gt;
&lt;p&gt;第一個命名為interface.bat，用來讓swig生成"_wrap.c"檔，並建立"build"和"dist"兩個資料夾。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set interface_name=example

echo 編譯接口
swig -python -py3 %interface_name%.i
echo 編譯完成
pause

REM MKDIR
echo 正在建立目錄
MKDIR "build"
MKDIR "dist"
echo 目錄已建立
pause
&lt;/pre&gt;

&lt;p&gt;第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。&lt;/p&gt;
&lt;p&gt;原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成".o"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成".pyd"檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example
set module_name=example

echo 正在建立暫存檔
gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include
move %target_name%.o build\%target_name%.o
move %target_name%_wrap.o build\%target_name%_wrap.o
echo 暫存檔建立
pause

echo 正在建立PYD
gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd
echo PYD建立

copy /Y runme.py dist\runme.py

python dist\runme.py

pause
&lt;/pre&gt;

&lt;p&gt;第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example

echo RMDIR...
RMDIR /S /Q .\build
RMDIR /S /Q .\dist

echo DEL...
del /F /S /Q %target_name%_wrap.c
del /F /S /Q %target_name%.py

pause
&lt;/pre&gt;

&lt;p&gt;檔案如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iPB2jDu.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;執行測試 :&lt;/h2&gt;

&lt;p&gt;之前的example.c和example.i內容並沒有更動。&lt;/p&gt;
&lt;p&gt;第一次執行後，發現會出現以下錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/d0FfYoF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oeY2vw4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2HjltE6.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是這個舉動實在是太耗費時間了，所以後來放棄了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pXH2OW2.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4vVIw2v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;估計是這裡有錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4Dhvqym.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過不知道怎麼調整。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。&lt;/p&gt;
&lt;p&gt;另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323230日誌 - 105/07/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050713.html" rel="alternate"></link><published>2016-07-13T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-13:blog/40323230ri-zhi-1050713.html</id><summary type="html">&lt;p&gt;Python 3.5.2軟體更新&lt;/p&gt;


&lt;h2&gt;軟體更新目標 :&lt;/h2&gt;

&lt;p&gt;之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。&lt;/p&gt;
&lt;p&gt;以W:為主，Y:用來撰寫網誌暫不需要更新。&lt;/p&gt;
&lt;p&gt;1.Python 3.5及之前安裝的套件。&lt;/p&gt;
&lt;p&gt;2.Leo 5.3正式版。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Python及套件更新步驟 :&lt;/h2&gt;

&lt;p&gt;將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。&lt;/p&gt;
&lt;p&gt;Python 3.5.2下載處：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/downloads/" title="python.org"&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xgAInox.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip freeze &gt; rq.txt
&lt;/pre&gt;

&lt;p&gt;清單中列的就是Python 3.4安裝的套件版本。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pUMf021.jpg" &gt;&lt;/p&gt;
&lt;p&gt;進入Python 3.5後使用pip指令時出現類似"Fatal error in launcher"的訊息，原因是官方的pip版本較舊。&lt;/p&gt;
&lt;p&gt;如果不更新，只能用"python -m pip"的方式驅動它，所以先命令它為自己升級。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python -m pip install pip --upgrade
&lt;/pre&gt;

&lt;p&gt;然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PN2P60t.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著利用下列指令更新：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip install -r rq.txt
&lt;/pre&gt;

&lt;p&gt;就會裝回所有的套件了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RuXhQhT.jpg" &gt;&lt;/p&gt;
&lt;p&gt;使用下列指令可以查看已安裝的套件。&lt;/p&gt;
&lt;p&gt;而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//已安裝套件
pip freeze
//過期套件
pip list --outdated
&lt;/pre&gt;

&lt;hr&gt;

&lt;h2&gt;Leo更新步驟 :&lt;/h2&gt;

&lt;p&gt;至於安裝Leo，到&lt;a href="http://sourceforge.net/projects/leo/files/Leo/" title="sourceforge.net"&gt;http://sourceforge.net/projects/leo/files/Leo/&lt;/a&gt;下載5.3的安裝檔，並暫時解壓縮到根目錄。&lt;/p&gt;
&lt;p&gt;接著進入\Leo-5.3-final\leo\dist資料夾，執行下面指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python setup.py install
&lt;/pre&gt;

&lt;p&gt;安裝完後，接著就能把解壓縮的檔案刪除了。&lt;/p&gt;
&lt;p&gt;不過在pip的紀錄中還是5.0 Bata2的樣子。&lt;/p&gt;
&lt;p&gt;新版的Leo介面（設定檔複製之前的）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DZGSNFn.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;上次的swig還是沒成功，"_wrap.c"中似乎還要加一些python3的判斷式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python3porting.com/cextensions.html#module-initialization" title="python3porting.com"&gt;http://python3porting.com/cextensions.html#module-initialization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050712.html" rel="alternate"></link><published>2016-07-12T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-12:blog/40323230ri-zhi-1050712.html</id><summary type="html">&lt;p&gt;瞭解SWIG的用法。&lt;/p&gt;


&lt;h2&gt;軟體修正 :&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;NetBeans&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;為NetBeans安裝python的附加元件，使其可以編譯python文件。&lt;/p&gt;
&lt;p&gt;這些附加元件還包含了jython2.7.0。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M1eGLck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SWIG&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/swig/files/swigwin/" title="sourceforge.net"&gt;https://sourceforge.net/projects/swig/files/swigwin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K2UBCMh.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著就能用它下參數了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Enjvaxe.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;SWIG簡介 :&lt;/h2&gt;

&lt;p&gt;SWIG的功能就是利用自己的Interface檔案".i"，產生出一個"_wrap.c"檔，如果DLL專案一起將這個".c"編譯的話，就可以讓其他高階語言呼叫了。&lt;/p&gt;
&lt;p&gt;SWIG內有個\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。&lt;/p&gt;
&lt;p&gt;諸如：D語言、java、javascript、lua、php、python、ruby。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yrDg75c.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;練習應用 :&lt;/h2&gt;

&lt;p&gt;參考範例：&lt;/p&gt;
&lt;p&gt;/Examples/python/simple/index.html&lt;/p&gt;
&lt;p&gt;&lt;img src="" &gt;&lt;/p&gt;
&lt;p&gt;先寫一個".c"程式碼。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File : example.c */

/* A global variable */
double Foo = 3.0;

/* Compute the greatest common divisor of positive integers */
int gcd(int x, int y) {
  int g;
  g = y;
  while (x &gt; 0) {
    g = x;
    x = y % x;
    y = g;
  }
  return g;
}
&lt;/pre&gt;

&lt;p&gt;然後再寫一個Interface的".i"文件。&lt;/p&gt;
&lt;p&gt;至於格式可能要參考手冊的其他內容。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File: example.i */
%module example

extern int gcd(int x, int y);
extern double Foo;
&lt;/pre&gt;

&lt;p&gt;然後用cmd到/Examples/python/simple中下指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -python example.i
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/Enjvaxe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。&lt;/p&gt;
&lt;p&gt;但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aGmZKry.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG的操作大致知道了，但是仍有些許不瞭解的地方。&lt;/p&gt;
&lt;p&gt;像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現".i"文件格式錯誤的訊息。&lt;/p&gt;
&lt;p&gt;而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。&lt;/p&gt;
&lt;p&gt;另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323218日誌 - 105/07/11</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050711.html" rel="alternate"></link><published>2016-07-11T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-11:blog/40323218ri-zhi-1050711.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h4&gt;嘗試四連桿機構&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1&gt;&lt;h3&gt;理想狀態：&lt;/h3&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;br&gt;&lt;/h1&gt;
&lt;h3&gt;前期嘗試：&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/before.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;前期階級排列：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step10.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;查詢資料：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step11.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;(在兩個dynamic item之間不能有static item)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;修改後：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step12.png" weight=600 &gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/after.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;未來嘗試：製作搖擺機構&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm &lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230練習 - 105/07/11</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050711.html" rel="alternate"></link><published>2016-07-11T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-11:blog/40323230lian-xi-1050711.html</id><summary type="html">&lt;p&gt;使用2015cp範本練習".py"呼叫".pyd"。&lt;/p&gt;


&lt;h2&gt;編譯出Python的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/coursemdetw/2015cp" title="coursemdetw/2015cp"&gt;https://github.com/coursemdetw/2015cp&lt;/a&gt;下載老師的範本練習。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vifdEXt.jpg" &gt;&lt;/p&gt;
&lt;p&gt;C程式的部分分成pymod和pyfun。&lt;/p&gt;
&lt;p&gt;這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kanLiEj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;button裡的內容如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("Z:/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o V:/IDE/Python33/libs/libpython33.a")
g.es("done")
&lt;/pre&gt;

&lt;p&gt;在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("gcc -c -g -IW:/Python34/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("gcc -shared -o dist/"+module_name+".pyd build/"+target_name+".o W:/Python34/libs/python34.lib")
g.es("pymod done")
&lt;/pre&gt;

&lt;p&gt;而另一邊的pyfun同理。&lt;/p&gt;
&lt;p&gt;接著就能在\dist資料夾中編譯出sum.pyd和pyfun.pyd了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CF0b3Ff.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;使用mypy.py :&lt;/h2&gt;

&lt;p&gt;接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。&lt;/p&gt;
&lt;p&gt;mypy.py中導入sum，並使用它裡面的函式sum()。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(sum.sum(1, 30))
&lt;/pre&gt;

&lt;p&gt;在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 定義內部運算的函式內容
int sum2(int a, int b)
{
    return a+b;
}

// sum 函式的 interface
static PyObject* mod_sum(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int s;
    // ii 表示兩個輸入變數都是整數
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係
    s = sum2(a,b);
    // i 表示 s 為整數
    return Py_BuildValue("i",s);
}

// 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function)
// Mod_Methods 為函式 (方法) 結構定義
static struct PyMethodDef Mod_Methods[] = {
    {"sum", mod_sum, METH_VARARGS, "Description.."},
    {NULL,NULL,0,NULL}
};
&lt;/pre&gt;

&lt;p&gt;sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/00d1W9j.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。&lt;/p&gt;
&lt;p&gt;這次是加入一段字串。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(pyfun.pyfun("我的字串"))
&lt;/pre&gt;

&lt;p&gt;在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pyfun(PyObject *self,PyObject *args)
{
    const char *to_who;
    if(!PyArg_ParseTuple(args,"s",&amp;to_who))
        return NULL;
     // pyfun 函式會將輸入字串變數傳回
    return PyUnicode_FromString(to_who);
}
&lt;/pre&gt;

&lt;p&gt;執行後的結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FhNTo1L.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這兩個pyd的結尾不太一樣。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sum.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 模組啟始, PyInit_ 後必須使用"名稱".pyd 中的模組名稱, 以便啟動
// 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum
PyMODINIT_FUNC
PyInit_sum(void)
{
    // 建立模組的起始, 輸入為模組結構名稱之 address
    (void) PyModule_Create(&amp;ModMethods);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;pyfun.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同
PyInit_pyfun(void)
{
    PyObject *m;
    m = PyModule_Create(&amp;moduledef);
    return m;
}
&lt;/pre&gt;

&lt;p&gt;意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。&lt;/p&gt;
&lt;p&gt;若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;延伸應用 :&lt;/h2&gt;

&lt;p&gt;只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。&lt;/p&gt;
&lt;p&gt;在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DYEFA1M.jpg" &gt;&lt;/p&gt;
&lt;p&gt;添加了下列指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//導入
#include "math.h"
//宣告
int sum3(int a, int b);
//副程式sum3
int sum3(int a, int b)
{
    return sqrt(a+b)*10;
}
//定義輸入值和sum3的外部名稱score
static PyObject* mod_score(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int t;
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    t = sum3(a,b);
    return Py_BuildValue("i",t);
}
&lt;/pre&gt;

&lt;p&gt;並在PyMethodDef Mod_Methods[]中再新增一串：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
{"score", mod_score, METH_VARARGS, "Description.."},
&lt;/pre&gt;

&lt;p&gt;接著在mypy.py中呼叫sum.score()就行了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。&lt;/p&gt;
&lt;p&gt;這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？&lt;/p&gt;
&lt;p&gt;不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。&lt;/p&gt;</summary><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230練習 - 105/07/10</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050710.html" rel="alternate"></link><published>2016-07-10T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-10:blog/40323230lian-xi-1050710.html</id><summary type="html">&lt;p&gt;由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。&lt;/p&gt;


&lt;h2&gt;編譯出C的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;找到了一個別人學校的DLL簡單範例。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/" title="niu.edu.tw"&gt;http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。&lt;/p&gt;
&lt;p&gt;使用NetBeans建立了一個C/C++ Dynamic Library。&lt;/p&gt;
&lt;p&gt;若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vLbLF1a.jpg" &gt;&lt;/p&gt;
&lt;p&gt;新建完成後，Projects的欄位就會幫使用者分類：&lt;/p&gt;
&lt;p&gt;Header Files, Resource Files, Source Files, Test Files.&lt;/p&gt;
&lt;p&gt;這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。&lt;/p&gt;
&lt;p&gt;如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇"Add Existing Item..."，再選擇想加入的檔案就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K1LuZ3T.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照範例先在SciTE中寫好了三個檔案。&lt;/p&gt;
&lt;p&gt;編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/acz9z6v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*str, int a, int b)
{
    printf("This is your ID(8):\n");
    printf("Your ID: %s\n", str);
    printf("%d+%d=%d:\n", a, b, a+b);
    return "OK";
}
&lt;/pre&gt;

&lt;p&gt;標頭檔中也有這一段匯入，供可執行檔呼叫。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*, int, int);
&lt;/pre&gt;

&lt;p&gt;這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。&lt;/p&gt;
&lt;p&gt;在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/B5driZY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時候會顯示成功，並在\dist\Debug\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L3U9skL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯出C的可執行檔 :&lt;/h2&gt;

&lt;p&gt;這時再把call DLL.c加入Source File中。&lt;/p&gt;
&lt;p&gt;call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。&lt;/p&gt;
&lt;p&gt;call DLL.c的主程式如下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
int main(void)
{
    int i1, i2;
    char str1[9];
    printf("Key in:\n");
    scanf("%s,%d,%d", &amp;str1, i1, i2);
    printf("\n");

    HMODULE hInst=LoadLibrary("DLLtest.dll");
    if(hInst==NULL){
        printf("Can't load library.\n");
        system("PAUSE");
        return 1;
    }
    char* (*CallDll)(char*, int, int);
    (FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
    if(CallDll==NULL){
        printf("NO Value.\n");
        system("PAUSE");
        return 2;
    }
    printf("Result: %s\n", CallDll(str1, i1,i2));
    FreeLibrary(hInst);
    system("PAUSE");
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;然而在編譯時，NetBeans卻顯示了下列訊息：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/JjwIcXD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;顯示是在這段出了問題：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
(FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
&lt;/pre&gt;

&lt;p&gt;這裡的問題是定義項和被定義項的關係錯誤。&lt;/p&gt;
&lt;p&gt;上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。&lt;/p&gt;
&lt;p&gt;由於是內建函式，所以不太了解其格式甚麼的。&lt;/p&gt;
&lt;p&gt;於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg);
&lt;/pre&gt;

&lt;p&gt;完全不用呼叫dll名稱什麼的。&lt;/p&gt;
&lt;p&gt;因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的"Slvs_"指派計算。&lt;/p&gt;
&lt;p&gt;編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。&lt;/p&gt;
&lt;p&gt;至於工程師規定的格式在slvs.h的註解中有所說明。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。&lt;/p&gt;
&lt;p&gt;下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - 瞭解SWIG &amp; CDemo的資源</title><link href="http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html" rel="alternate"></link><published>2016-07-09T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html</id><summary type="html">&lt;p&gt;安裝SWIG&lt;/p&gt;
&lt;p&gt;並檢視下列檔案：&lt;/p&gt;
&lt;p&gt;CDemo.exe&lt;/p&gt;
&lt;p&gt;CDemo.c&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;除了英文的資料，另外還讀了一下關於SWIG的相關中文資料：&lt;/p&gt;
&lt;p&gt;1.Python的資料庫形式&lt;/p&gt;
&lt;p&gt;&lt;a href="https://read01.com/PnGeDg.html" title="read01.com"&gt;https://read01.com/PnGeDg.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.Python在Windows中用SWIG呼叫C/C++的函式（VC）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html" title="falldog7.blogspot.tw"&gt;http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.SWIG概念&lt;/p&gt;
&lt;p&gt;&lt;a href="http://user.frdm.info/ckhung/b/mi/swig.php" title="user.frdm.info"&gt;http://user.frdm.info/ckhung/b/mi/swig.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著從&lt;a href="http://www.swig.org/download.html" title="swig.org"&gt;swig.org&lt;/a&gt;下載最新版的SWIG 3.0.10，將壓縮包解至W:內。&lt;/p&gt;
&lt;p&gt;SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的".tar.gz"。&lt;/p&gt;
&lt;p&gt;解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/G3moEiW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;如果該步驟需要完整的流程，\Doc\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。&lt;/p&gt;
&lt;p&gt;在閱讀\Doc\Manual\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。&lt;/p&gt;
&lt;p&gt;只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VHvu5ps.jpg" &gt;&lt;/p&gt;
&lt;p&gt;手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vaa3Shm.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.exe :&lt;/h2&gt;

&lt;p&gt;CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。&lt;/p&gt;
&lt;p&gt;在原本的\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。&lt;/p&gt;
&lt;p&gt;為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7y0nwjC.jpg" &gt;&lt;/p&gt;
&lt;p&gt;由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。&lt;/p&gt;
&lt;p&gt;顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hzotTGs.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.c :&lt;/h2&gt;

&lt;p&gt;由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。&lt;/p&gt;
&lt;p&gt;用SciTE開啟CDemo.c，可以發現CDemo的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6IlMv1k.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而為了方便，將它部分的原始碼貼在下面：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/*---------------------------
 * Some sample code for slvs.dll. We draw some geometric entities, provide
 * initial guesses for their positions, and then constrain them. The solver
 * calculates their new positions, in order to satisfy the constraints.
 *
 * Copyright 2008-2013 Jonathan Westhues.
 *-------------------------*/
#ifdef HAVE_CONFIG_H
...
#endif
#ifdef WIN32
...
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_STDINT_H
...
#endif

#include &lt;slvs.h&gt;

static Slvs_System sys;

static void *CheckMalloc(size_t n)
{
    void *r = malloc(n);
    if(!r) {
        printf("out of memory!\n");
        exit(-1);
    }
    return r;
}

/*---------------------------
 * An example of a constraint in 3d. We create a single group, with some
 * entities and constraints.
 *-------------------------*/
void Example3d()
{
...
}

/*---------------------------
 * An example of a constraint in 2d. In our first group, we create a workplane
 * along the reference frame's xy plane. In a second group, we create some
 * entities in that group and dimension them.
 *-------------------------*/
void Example2d()
{
...
}

int main()
{
    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));
    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));
    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));

    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));
    sys.faileds = 50;

    /*Example3d();*/
    for(;;) {
        Example2d();
        sys.params = sys.constraints = sys.entities = 0;
        break;
    }
    return 0;
}

&lt;/pre&gt;

&lt;p&gt;在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。&lt;/p&gt;
&lt;p&gt;所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
void Example2d()
{
    Slvs_hGroup g;
    double qw, qx, qy, qz;

    g = 1;
    /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
    Slvs_MakeQuaternion(1, 0, 0,
                        0, 1, 0, &amp;qw, &amp;qx, &amp;qy, &amp;qz);
    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

    /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
    g = 2;
    /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */
    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);

    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);

    /* And we create a line segment with those endpoints. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,
                                        200, 301, 302);

    /* Now three more points. */
    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);
    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);

    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);
    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);

    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);
    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);

    /* And arc, centered at point 303, starting at point 304, ending at
     * point 305. */
    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,
                                    303, 304, 305);

    /* Now one more point, and a distance */
    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);
    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);

    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);
    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);

    /* And a complete circle, centered at point 306 with radius equal to
     * distance 307. The normal is 102, the same as our workplane. */
    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,
                                    306, 102, 307);


    /* The length of our line segment is 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            30.0,
                                            301, 302, 0, 0);

    /* And the distance from our line segment to the origin is 10.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            2, g,
                                            SLVS_C_PT_LINE_DISTANCE,
                                            200,
                                            10.0,
                                            101, 0, 400, 0);
    /* And the line segment is vertical. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            3, g,
                                            SLVS_C_VERTICAL,
                                            200,
                                            0.0,
                                            0, 0, 400, 0);
    /* And the distance from one endpoint to the origin is 15.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            4, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            15.0,
                                            301, 101, 0, 0);
#if 0
    /* And same for the other endpoint; so if you add this constraint then
     * the sketch is overconstrained and will signal an error. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            5, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            18.0,
                                            302, 101, 0, 0);
#endif /* 0 */

    /* The arc and the circle have equal radius. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            6, g,
                                            SLVS_C_EQUAL_RADIUS,
                                            200,
                                            0.0,
                                            0, 0, 401, 402);
    /* The arc has radius 17.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            7, g,
                                            SLVS_C_DIAMETER,
                                            200,
                                            17.0*2,
                                            0, 0, 401, 0);

    /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
    sys.calculateFaileds = 1;

    /* And solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("solved okay\n");
        printf("line from (%.3f %.3f) to (%.3f %.3f)\n",
                sys.param[7].val, sys.param[8].val,
                sys.param[9].val, sys.param[10].val);

        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\n",
                sys.param[11].val, sys.param[12].val,
                sys.param[13].val, sys.param[14].val,
                sys.param[15].val, sys.param[16].val);

        printf("circle center (%.3f %.3f) radius %.3f\n",
                sys.param[17].val, sys.param[18].val,
                sys.param[19].val);
        printf("%d DOF\n", sys.dof);
    } else {
        int i;
        printf("solve failed: problematic constraints are:");
        for(i = 0; i &lt; sys.faileds; i++) {
            printf(" %d", sys.failed[i]);
        }
        printf("\n");
        if(sys.result == SLVS_RESULT_INCONSISTENT) {
            printf("system inconsistent\n");
        } else {
            printf("system nonconvergent\n");
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;"Slvs_hGroup g"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。&lt;/p&gt;
&lt;p&gt;之後便能用"sys.param[sys.params++]"或是"sys.entity[sys.entities++]"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。&lt;/p&gt;
&lt;p&gt;比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。&lt;/p&gt;
&lt;p&gt;畫完圖之後，最後解決的程式是使用Slvs_Solve(&amp;amp;sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。&lt;/p&gt;
&lt;p&gt;不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。&lt;/p&gt;
&lt;p&gt;雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="SWIG"></category></entry><entry><title>40323230練習 - 105/07/09</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050709.html" rel="alternate"></link><published>2016-07-09T12:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323230lian-xi-1050709.html</id><summary type="html">&lt;p&gt;嘗試用C語言解題&lt;/p&gt;


&lt;h2&gt;BUG fix :&lt;/h2&gt;

&lt;p&gt;W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nXiTYLx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;只要修改cpp.properties的路徑就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zjc51Kz.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Nutcracker Solution :&lt;/h2&gt;

&lt;p&gt;上學期的&lt;a href="http://chiamingyen.github.io/kmolab/blog/2015-fall-cadp-w16.html" title="github.io"&gt;Nutcracker網誌內容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Tfik6jG.jpg" &gt;&lt;/p&gt;
&lt;p&gt;之前的python題目，稍微研究一下後轉成C語言。&lt;/p&gt;
&lt;p&gt;不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RwJbKM9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;先做了兩個程式，不過第一是介面而已，第二個才是主要架構。&lt;/p&gt;
&lt;p&gt;撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。&lt;/p&gt;
&lt;p&gt;有時候會偷吃步測試一些解法。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PDHq9QA.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。&lt;/p&gt;
&lt;p&gt;演算法概念：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iOuX4ks.jpg" &gt;&lt;/p&gt;
&lt;p&gt;途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int k=40;
int h=10;
int a=40;
int b=80;
double r=10;
double pi=M_PI;
int num=1000;

int main()
{
    double deg =pi/180;
    for (int j=45*num; j&lt;=180*num; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        printf("%g\n", (int)(j/num0*100000+.5)/100000.);
        if(r1&lt;=r){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            break;
        }
    }
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;第二支程式的最後成果。&lt;/p&gt;
&lt;p&gt;最後精確度還是沒有很高，不知道問題出在哪裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jbtn7X1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。&lt;/p&gt;
&lt;p&gt;後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int a, b, k, h, r, lim;
double o, wp, thmin, thmax;
double pi=M_PI;
int num=1000;

double solve_minpath(int, int, int, int, int);
double solve_maxangle(int, int, int, int, int);
double solve_maxpath(int, int, int, int);
double solve_minangle(int, int, int, int);

int main()
{
    scanf("%d,%d,%d,%d,%d,%d", &amp;a, &amp;b, &amp;k, &amp;h, &amp;r, &amp;lim);
//強制正值
    a=abs(a);
    b=abs(b);
    h=abs(h);
    k=abs(k);
    r=abs(r);
    lim=abs(lim);
    printf("\n---\n");
    printf("Used pi= %f\n", pi);
    printf("---\n");
    printf("Connecting Rod:\n");
    printf("a= %d b= %d\n", a, b);
    printf("Rod radius= %d\n", r);
    printf("Rod width= %d\n", r*2);
    printf("Space Usage:\n");
    printf("h= %d k= %d\n", h, k);
    printf("Work Path= %d\n", lim);
    printf("---\n\n");
//相關參數代入副程式解題
    o=solve_minpath(k, h, a, b, r);
    wp=solve_maxpath(lim, a, b, r)-o;
    thmin=solve_minangle(lim, a, b, r);
    thmax=solve_maxangle(k, h, a, b, r);
    if(a*b*lim==0){
        printf("---ERRO---\nSome value can't be zero.\n");
        return 1;
    }
    else{
        if(o+r&gt;lim){
            printf("---ERRO---\nSpace is not enough.\n");
            return 2;
        }
        else{
            printf("\n---\n---Result---\n");
            printf("Distance:\n");
            printf("Offset distance:\n");
            printf("o= %f\n", o);
            printf("Work distance:\n");
            printf("wp= %f\n", wp);
            printf("Angle(Degree):\n");
            printf("min= %f max= %f\n---\n", thmin, thmax);
            return 0;
        }
    }
}

double solve_minpath(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return x2;
            break;
        }
    }
    return 0;
}

double solve_maxangle(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return th/deg;
            break;
        }
    }
    return 0;
}

double solve_maxpath(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/2*a*n);
    }
    return n;
}

double solve_minangle(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/(2*a*n));
    }
    return th;
}

&lt;/pre&gt;

&lt;p&gt;最後執行的結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/S6oj3vJ.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。&lt;/p&gt;
&lt;p&gt;後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄 - 編譯Solvespace流程</title><link href="http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html" rel="alternate"></link><published>2016-07-07T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-07:blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html</id><summary type="html">&lt;p&gt;由原始碼編譯出Solvespace和CDemo的執行檔&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。&lt;/p&gt;
&lt;p&gt;連結為下載處。&lt;/p&gt;
&lt;p&gt;1.MinGW (Not official version), &lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;https://nuwen.net/mingw.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.msys (Official version), &lt;a href="http://www.mingw.org/wiki/msys" title="mingw.org"&gt;http://www.mingw.org/wiki/msys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.CMake  (Official version), &lt;a href="https://cmake.org/download/" title="cmake.org"&gt;https://cmake.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.NetBeans (Our storage), &lt;a href="http://140.130.17.17/public/Netbeans/" title="140.130.17.17/public/"&gt;http://140.130.17.17/public/Netbeans/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存放位置除了CMake之外皆為W:內，CMake存於W:\app資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kHQFc1g.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;下載Solvespace原始碼 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;git clone最新的原始碼到W:\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KUJCPoJ.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從\NetBeans\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/m7uH7TA.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/D6TKKRZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rame7tV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;若有必要可以為NetBeans安裝CMake的附加元件。&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6mi2Lz1.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;執行Build :&lt;/h2&gt;

&lt;p&gt;接著按下New Project...新增專案。&lt;/p&gt;
&lt;p&gt;選擇Project with Existing Sources繼續。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TxisGUv.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後選擇Whitequark的Solvespace原始碼目錄。&lt;/p&gt;
&lt;p&gt;並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Gzqb7so.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DF15llN.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時開啟專案內的\src\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。&lt;/p&gt;
&lt;p&gt;註：如果不是填在最後一項會有讀取順序錯誤的問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rAC4a2W.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\src和\exposed資料夾下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/0CEdXhu.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - Solvespace</title><link href="http://project.mde.tw/blog/40323230ji-lu-solvespace.html" rel="alternate"></link><published>2016-07-06T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-06:blog/40323230ji-lu-solvespace.html</id><summary type="html">&lt;p&gt;找到的Solvespace原始碼版本&lt;/p&gt;


&lt;h2&gt;目前可攜式環境內存放的Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;超連結為下載處。&lt;/h3&gt;

&lt;p&gt;1.&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;：非官方人員開發的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dcchKn7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace 2.0&lt;/a&gt;：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/HBZ0DM4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="https://github.com/solvespace/solvespace/releases/tag/v2.1" title="github.com"&gt;Solvespace 2.1&lt;/a&gt;：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和&lt;a href="https://github.com/solvespace/libdxfrw" title="github.com"&gt;solvespace/libdxfrw&lt;/a&gt;有關聯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Zqu4j7i.jpg" &gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href="https://github.com/solvespace/solvespace/tree/2.x" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/UYXGcF7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;相關連結：版本差異紀錄-&lt;a href="https://github.com/solvespace/solvespace/blob/2.x/CHANGELOG.md" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ZGLaQ0j.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WkmsWPq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;點開記錄錯誤的視窗：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/52VlrUJ.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050705.html" rel="alternate"></link><published>2016-07-05T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-05:blog/40323230ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索-2&lt;/p&gt;
&lt;p&gt;註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。&lt;/p&gt;


&lt;p&gt;目前NetBeans的&lt;a href="https://netbeans.org/kb/docs/intro-screencasts.html?utm_source=netbeans&amp;amp;utm_campaign=welcomepage" title="netbeans.org"&gt;官方網站&lt;/a&gt;並沒有很詳盡的介紹，只有放一些改版的導覽影片。&lt;/p&gt;
&lt;p&gt;基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。&lt;/p&gt;
&lt;h2&gt;NetBeans啟動 :&lt;/h2&gt;

&lt;p&gt;每次啟動可攜式環境，NetBeans portable都會保留之前的設定。&lt;/p&gt;
&lt;p&gt;只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。&lt;/p&gt;
&lt;p&gt;另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。&lt;/p&gt;
&lt;p&gt;不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。&lt;/p&gt;
&lt;p&gt;設定start.bat在啟動後自動打開NetBeans。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VyTHn6F.jpg" &gt;&lt;/p&gt;
&lt;p&gt;NetBeans在啟動時載入專案的提示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/g2hnriA.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans介面 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/dpboPO9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;跟大部分的文字編譯軟體差不多的介面。&lt;/p&gt;
&lt;p&gt;在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。&lt;/p&gt;
&lt;p&gt;行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。&lt;/p&gt;
&lt;p&gt;捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。&lt;/p&gt;
&lt;p&gt;NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dHiNW4x.jpg" &gt;&lt;/p&gt;
&lt;p&gt;主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。&lt;/p&gt;
&lt;p&gt;另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。&lt;/p&gt;
&lt;p&gt;上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y94zmYv.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。&lt;/p&gt;
&lt;p&gt;以下是File的檔案目錄和檔案總管顯示的比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ekWZDfJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ORqMv0Q.jpg" &gt;&lt;/p&gt;
&lt;p&gt;服務頁籤中會顯示一些工具，不過不知道怎麼使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qMeIdGo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。&lt;/p&gt;
&lt;p&gt;在物件上點擊兩下會移到該物件所在的檔案位置。&lt;/p&gt;
&lt;p&gt;在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rTjJ0jx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XBywmpk.jpg" &gt;&lt;/p&gt;
&lt;p&gt;工具列的功能說明：&lt;/p&gt;
&lt;p&gt;1：Source-切換至編輯原始碼模式。&lt;/p&gt;
&lt;p&gt;2：History-切換至編輯記錄模式。&lt;/p&gt;
&lt;p&gt;3：Last Edit-回到上次編輯（插入／刪除）過的位置。&lt;/p&gt;
&lt;p&gt;4：Go back to-上一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;5：Forward-下一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;6：Find Selection-在本檔案搜尋框選的文字。&lt;/p&gt;
&lt;p&gt;7：Find Previous Occurrence-尋找前一個關鍵字。&lt;/p&gt;
&lt;p&gt;8：Find Next Occurrence-尋找後一個關鍵字。&lt;/p&gt;
&lt;p&gt;9：Toggle Highlight Search-切換高亮度標示。&lt;/p&gt;
&lt;p&gt;10：Toggle Rectangular Selection-切換矩形框選模式。&lt;/p&gt;
&lt;p&gt;11：Previous Bookmark-前一個書籤。&lt;/p&gt;
&lt;p&gt;12：Next Bookmark-下一個書籤。&lt;/p&gt;
&lt;p&gt;13：Toggle Bookmark-切換書籤。&lt;/p&gt;
&lt;p&gt;14：Shift Line Left-往左縮排。&lt;/p&gt;
&lt;p&gt;15：Shift Line Right-往右縮排。&lt;/p&gt;
&lt;p&gt;16：Start Macro Recording-開始巨集（腳本）錄製。&lt;/p&gt;
&lt;p&gt;17：Stop Macro Recording-停止巨集錄製。&lt;/p&gt;
&lt;p&gt;18：Comment-註解。&lt;/p&gt;
&lt;p&gt;19：UNcomment-刪掉註解。&lt;/p&gt;
&lt;p&gt;20：Go to Header/Source-開啟源頭檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。&lt;/p&gt;
&lt;p&gt;以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050704.html" rel="alternate"></link><published>2016-07-04T20:37:00+08:00</published><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323218ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h3&gt;熟悉 V-Rep 基本操作&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/introduce1.PNG"&gt;
&lt;br&gt;
&lt;h3&gt;1. 2D移動&lt;br&gt;
2. 3D旋轉&lt;br&gt;
3. 遠近&lt;br&gt;
4. 移動畫面至物體&lt;br&gt;
5. 物體定位(x,y,z)&lt;br&gt;
6. 物體旋轉(x,y,z)&lt;br&gt;
7. 開始模擬&lt;br&gt;
8. 暫停模擬&lt;br&gt;
9. 結束模擬&lt;br&gt;
10. 慢速&lt;br&gt;
11. 加速&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;嘗試製作 one_link_robot&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;File→import→Mesh...(從資料夾中輸入 stl檔)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;選擇單位和方向&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step3.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選物體使用"object shift"調整Z軸距離&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;右鍵→Add→Joint→Revolute(增加旋轉軸)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ...
&lt;br&gt;
&lt;h3&gt;再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用"object shift"在XYZ都點Apply to selection , 在"Orientation/Rotations"也點 Apply , 使兩軸重疊&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step6.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動)
&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step7.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;
使圓柱降階成為旋轉軸的Child&lt;br&gt;
使旋轉物降階成為圓柱的Child&lt;br&gt;
使旋轉軸降階成為底座的Child&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step8.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;按左側"Script" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座.&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step9.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;double - click the child script,  在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) &lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/Round.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選"Start simulation" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~&lt;/h3&gt;&lt;/p&gt;
&lt;h3&gt;製作影片：&lt;/h3&gt;

&lt;iframe src="https://player.vimeo.com/video/173321561" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/173321561"&gt;V-Rep one_link_robot&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/04-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html" rel="alternate"></link><published>2016-07-04T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050704-2.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索&lt;/p&gt;


&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;MinGW Distro - nuwen.net&lt;/a&gt;下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。&lt;/p&gt;
&lt;p&gt;下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。&lt;/p&gt;
&lt;p&gt;這個MinGW裡還配有一個比較簡單的git工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QusRHMc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。&lt;/p&gt;
&lt;p&gt;先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。&lt;/p&gt;
&lt;p&gt;設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aY6AzV5.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans專案 :&lt;/h2&gt;

&lt;p&gt;之後新建專案，選擇C語言已有源代碼的專案。&lt;/p&gt;
&lt;p&gt;選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MOdwa0P.jpg" &gt;&lt;/p&gt;
&lt;p&gt;基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/f4sSsvQ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接下來是清理和建置指令，就和打在CMD視窗裡的一樣。&lt;/p&gt;
&lt;p&gt;幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/HrGJNnU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。&lt;/p&gt;
&lt;p&gt;下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。&lt;/p&gt;
&lt;p&gt;左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。&lt;/p&gt;
&lt;p&gt;左下的導航欄似乎能執行CMake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mFKn2Pc.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。&lt;/p&gt;
&lt;p&gt;雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704.html" rel="alternate"></link><published>2016-07-04T12:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;改用CMD設定CMake&lt;/p&gt;


&lt;h2&gt;CMD命令cmake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的Command-line build&lt;/h3&gt;

&lt;p&gt;使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/F6tBRr1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2h18M7K.jpg" &gt;&lt;/p&gt;
&lt;p&gt;到CMD中下Readme中提供的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpzsMMZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下nmake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SMlMAQc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是在最後出現一些錯誤，不知道原因為何。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CZ2wMoU.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。&lt;/p&gt;
&lt;p&gt;如果要改用NetBeans，就不用下nmake的指令。&lt;/p&gt;
&lt;hr&gt;

&lt;h3&gt;Readme的MSVC build&lt;/h3&gt;

&lt;p&gt;這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/8D6cRvV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著同樣按照Readme的說明用CMD下指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iXmV4cR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過後面的make指令會說無法讀取makefile檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html" rel="alternate"></link><published>2016-07-03T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:blog/40323230ri-zhi-1050703-2.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace(更新)&lt;/p&gt;


&lt;h2&gt;使用CMake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的GUI build&lt;/h3&gt;

&lt;p&gt;下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。&lt;/p&gt;
&lt;p&gt;在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。&lt;/p&gt;
&lt;p&gt;CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nk3qTV4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。&lt;/p&gt;
&lt;p&gt;要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。&lt;/p&gt;
&lt;p&gt;Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。&lt;/p&gt;
&lt;p&gt;雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。&lt;/p&gt;
&lt;p&gt;Configure的部分嘗試選擇MinGW的選項。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/5br2VyW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OljnPa7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;暫時用Visual Studio的設定，但是結果似乎不理想。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TSfLb5n.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.youtube.com/watch?v=gYmgbqGfv-8" title="youtube.com"&gt;教學影片-Visual Studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.youtube.com/watch?v=2A-iRgOhL8A" title="youtube.com"&gt;教學影片-Mingw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703.html" rel="alternate"></link><published>2016-07-03T12:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:blog/40323230ri-zhi-1050703.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;


&lt;h2&gt;編譯 Solvespace 前的準備 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="http://www.activestate.com/activeperl/downloads" title="activestate.com"&gt;Active State&lt;/a&gt;下載了 ActivePerl，使用的是5.24.0／x64版。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="visualstudio.com"&gt;Microsoft&lt;/a&gt;下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;GitHub&lt;/a&gt;下載Solvespace的原始碼，另外在&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace&lt;/a&gt;提供下載的頁面中也有一個較舊版的原始碼。&lt;/p&gt;
&lt;p&gt;裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/we7AKIF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;用CMD從安裝目錄的\VC\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iCFeYAe.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;關於NMAKE的使用方法，找了幾個中國的網站介紹：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://www.cnblogs.com/kekec/archive/2013/04/21/3007277.html" title="cnblogs.com"&gt;NMAKE的指令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.csdn.net/cneaglelee/article/details/11714803" title="csdn.net"&gt;NMAKE的開發環境設置&lt;/a&gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄</title><link href="http://project.mde.tw/blog/40323230ji-lu.html" rel="alternate"></link><published>2016-07-02T19:00:00+08:00</published><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-02:blog/40323230ji-lu.html</id><summary type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;


&lt;h2&gt;V-REP Example Learning Reviews&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;嘗試用英文說明&lt;/h4&gt;
&lt;/br&gt;
&lt;h2&gt;Notes :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;The "Scene hierarchy" panel can show whole of outward and entity in a tree.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy" title="coppeliarobotics.com"&gt;Scene hierarchy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/cqIHtFn.jpg" &gt;
&lt;/br&gt;
&lt;h3&gt;In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Any parts can insert a script to control them.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;"Dummy" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummies.htm" title="coppeliarobotics.com"&gt;Dummy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/caU2SLx.jpg" &gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;目前整理完幾何部件的檔案。存於\users\g2_files\VREP_Simulation.ttt中。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNvEHRc.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="V-rep"></category></entry><entry><title>40323250日誌 - 105/06/29</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050629.html" rel="alternate"></link><published>2016-06-29T21:37:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-29:blog/40323250ri-zhi-1050629.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;


&lt;h3&gt;進度&lt;/h3&gt;

&lt;h4&gt;目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖:&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/OCcfYur.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/64Qlmfm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是v-rep拆解後的截圖&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;簡易版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/1C9EKl2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;完整版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/I7q77aX.png"&gt;
&lt;/br&gt;
&lt;h3&gt;明天應該就可以開始測試模擬了。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/28</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050628.html" rel="alternate"></link><published>2016-06-28T20:48:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-28:blog/40323250ri-zhi-1050628.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;


&lt;h3&gt;目前組合進度&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/D2k3uqk.gif"&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的狀況&lt;/h3&gt;
&lt;h4&gt;我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/W3N5pkC.png"&gt;
&lt;/br&gt;
&lt;h4&gt;滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>Summer Plan</title><link href="http://project.mde.tw/blog/summer-plan.html" rel="alternate"></link><published>2016-06-23T17:10:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-23:blog/summer-plan.html</id><summary type="html">&lt;p&gt;Summer project&lt;/p&gt;


&lt;p&gt;1.畫3D Printer (V-rep ,Onshape)&lt;/p&gt;

&lt;p&gt;2.實驗室網站介面&lt;/p&gt;

&lt;p&gt;3.Octopi ,機械手臂&lt;/p&gt;

&lt;p&gt;4.OpenCV &lt;/p&gt;

&lt;p&gt;5.RGA演算&lt;/p&gt;

&lt;p&gt;6.認證主機(Virtual Box)&lt;/p&gt;

&lt;p&gt;7.Proxy&lt;/p&gt;

&lt;p&gt;8.報告(拍照 ,內容整理)&lt;/p&gt;

&lt;p&gt;9.找碩班教授&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;暑期人數 : &lt;/p&gt;
&lt;p&gt;七月:第一組3人 ,第二組4人&lt;/p&gt;
&lt;p&gt;八月:第一組3人 ,第二組4人 ,第三組1人&lt;/p&gt;
&lt;p&gt;&lt;font size="5" face="Arial"&gt;&lt;marquee border="0" scrollamount="50" behavior="alternate"&gt;You can't see me&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>OpenCv範例執行</title><link href="http://project.mde.tw/blog/opencvfan-li-zhi-xing.html" rel="alternate"></link><published>2016-06-10T17:50:00+08:00</published><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-10:blog/opencvfan-li-zhi-xing.html</id><summary type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;


&lt;h3&gt;實作系統Ubuntu 14.04 以及 老師整合的檔案&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image"&gt;範例網址1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/picture/messi.jpg"&gt;使用到的圖片&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
img = cv2.imread('messi.jpg',0)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv2.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv2.imwrite('messigray.png',img)
    cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/tI55TDf.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html#display-video"&gt;範例網址2.&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)
while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break&lt;/p&gt;
&lt;h1&gt;When everything done, release the capture&lt;/h1&gt;
&lt;p&gt;cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/MOL03LL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;範例網址3.(同上)&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)&lt;/p&gt;
&lt;h1&gt;Define the codec and create VideoWriter object&lt;/h1&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        # write the flipped frame
        out.write(frame)
        cv2.imshow('frame',frame)
        if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
            break
    else:
        break&lt;/p&gt;
&lt;h1&gt;Release everything if job is finished&lt;/h1&gt;
&lt;p&gt;cap.release()
out.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;h4&gt;得到檔案名稱為output的avi影片檔&lt;/h4&gt;&lt;/p&gt;</summary><category term="OpenCv"></category></entry></feed>