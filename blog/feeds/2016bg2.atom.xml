<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016bg2.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2016-07-24T21:07:48+08:00</updated><entry><title>40323250日誌 - V-rep &amp; 3D-Printer</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-3d-printer.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323250ri-zhi-v-rep-3d-printer.html</id><summary type="html">&lt;p&gt;之後的 V-rep模擬Printer都整理於本文章中&lt;/p&gt;
</summary><category term="solvespace&amp;v-rep"></category></entry><entry><title>40323250日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050705.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323250ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;V-rep 與 Solvespace的結合應用&lt;/p&gt;


&lt;h3&gt;最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 &lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_solvespace.png" &gt;
&lt;h3&gt;(檔案位於solvespace官網的 tutorial : linkages)
&lt;/h3&gt;&lt;p&gt;&lt;a href="http://solvespace.com/dl/mechanisms.zip "&gt;壓縮檔載點&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3&gt;由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep.png"&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;軸都放好了 ,只是從屬關係還是不太清楚要如何放置&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep_allaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結果我又弄了一個圖 ,試圖從這邊學習從屬設定&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前只會讓它亂轉&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.gif"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;感覺和各個旋轉軸速度也有關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test2.gif"&gt;
&lt;hr&gt;
&lt;h3&gt;105 - 07/10更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;現在能夠讓連桿旋轉了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;想要測試能否以固定角度來回旋轉 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間...&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_types.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前先以控單軸為主 ,但是遇到以下狀況&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_control2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/example_code1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/code_error1.png" &gt;
&lt;h3&gt;如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;參考 :&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm "&gt;Joint types and operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded "&gt;Child Scripts&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/11更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Joint 種類分成以下4種 :&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/joint-types.png" &gt;
&lt;/br&gt;
&lt;h4&gt;1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。&lt;/h4&gt;
&lt;h4&gt;2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 &lt;/h4&gt;
&lt;h4&gt;3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。&lt;/h4&gt;
&lt;h4&gt;4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;Control the joint :&lt;/h3&gt;
&lt;h4&gt;1.simSetJointPosition : when your joint is not in force/torque mode&lt;/h4&gt;
&lt;h4&gt;2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled&lt;/h4&gt;
&lt;h4&gt;3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試:&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/12更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... &lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/little_car.ttt?raw=true"&gt;little_car.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/little_car.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/14更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Printer_new.png" &gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new.ttt?raw=true"&gt;printer_new.ttt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new_2.ttt?raw=true"&gt;printer_new_2.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/15更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天開始研究Inverse Kinematic 逆向運動學(IK) ,透過矩正及向量運算 ,就可以得到參數 ,且恰巧有學長論文和此相關 ,從中學到了不少 ,但還沒能弄懂 ,最後要結合進V-rep模擬中 ,腳步要加快了&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/17更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace測試連桿運動方式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_tutorial.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;旋轉軸定義&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_pic.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;子屬關係設定 (測試) ,加上dummy固定&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/relation_test.png" &gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;經過一番波折 ,終於和同學弄出來了 ,只要無法封閉的部分利用dummy固定就可以了 ,至於實體轉軸部分要搭接在桿子上才可以&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/solvespace_successful.ttt?raw=true"&gt;solvespace_successful&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/18更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;嘗試幫第一組 組裝手臂, 除了夾爪部分外 ,其餘都組裝好了 ,過程發現部分零件拆解後會有座標不對的問題 ,只要將做標調整和world相同就比較容易了&lt;/h3&gt;
&lt;h3&gt;(參照範例: 7 DoF manipulator 設定ik值)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/24更新&lt;/h3&gt;
&lt;/br&gt;
今天預計要測試馬達控制 ,但是沒有多的12V power supply ,所以先把Onshape ,printer的細部畫一畫 ,現在大概有300個特徵 ,本來可以輕鬆的拉動滑塊 ,現在要用箭頭才能拉動了 ,估計不會畫電路板部分 ,戲偶衣服穿太多了
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_top.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_bottom.gif" &gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="solvespace&amp;v-rep"></category></entry><entry><title>40323250日誌 - V-rep 功能 (持續更新中)</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html</id><summary type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;


&lt;p&gt;&lt;/br&gt;
&lt;h2&gt;Onshape繪製V-rep零件 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在Onshape新增一個零件檔 ,選擇隱私或者公開 ,目前每個人擁有的容量為10mb。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在part studio部分選擇平面當作草圖繪圖 ,功能和大多繪圖軟體相同。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;單位設置 :&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_units.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;功能表有一個(x)函數圖示 ,能夠設定變數值 ,方便用於零件設計 ,若新增一個x ,命名為a且值為10的值 ,之後在填入尺寸部分輸入#a ,則該尺寸為10。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_a.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;零件繪製好之後 ,在Assembly中引入零件。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_insert.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;先按右鍵將底座設定為fix(固定) ,組裝零件須注意 ,因為使用V-rep模擬 ,組裝時零件和零件設定小段距離(offset) ,不要完全貼合(在V-rep較易拆解零件) ,旋轉軸先透過cylindrical_mate和孔配合 ,再利用planar_mate讓軸偏移小段距離。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_offset.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;組合完畢後 ,在Assembly點選右鍵 ,輸出成stl格式檔案。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_export.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;V-rep 教學 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;導入stl檔案 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選左上方工具列File ,import ,mesh ,選取繪製的stl檔案後 ,就可以看到零件了。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;調整座標 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;若只看到零件的一部分 ,就是零件倒過來了 ,這時候點選左方零件圖示 ,再選上方工具列 ,將零件座標系設定成V-rep內(World)座標 ,最後點選上方旋轉功能 ,旋轉零件至理想角度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;轉好角度之後 ,點選上方平移功能 ,並調整Z軸高度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若零件被地板遮住 ,看不到零件 ,可先使用選平移功能 。&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;拆解零件 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在V-rep導入的stl檔都會變成一個整體零件 ,而在Onshape先組好是因為零件拆解後較容易定位 ,且座標較容易設定等等。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選欲拆解之零件後 ,點選工具列 ,編輯 ,Grouping/Merging ,Divide select shapes。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若有照上方Onshape繪製零件方式 ,零件就可以順利拆開。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入旋轉軸 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在右側視窗點選右鍵 , Add → Joint → Revolute
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;新增完成 ,快點兩下圖示 ,可以設定相關性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;橘色框框為旋轉軸長度及直徑 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;如果相關參數都設定好了 ,點選右鍵→Edit→使旋轉軸與零件結合成一物件(也可以直接用滑鼠拖曳)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結合後的從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_parent.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;旋轉軸(馬達)設定 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;先將各部位組立完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_pin.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定底座Dynamic性質 , ( X = 不打勾 )&lt;/h3&gt;
&lt;h3&gt;Body is respondable 指 是否實體化 ,若兩個實體化物件互相碰撞 ,會依照物理設定做相對反應。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定Revolute_joint(馬達)性質 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉軸Dynamic性質 ,設為動態物件
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉桿Dynamic性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在Assciated object選擇STL_Imported_sub(主體) &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後打開左方script ,並加入下面那行程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/child_script.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定完之後就可以按start ,跑老師的python範例了&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入攝影機&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;vision_sensor類型可分為 :
a.為orthographic type  及  b.為perspective type&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_types.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 ,
綠色框框為範圍內的解析度 (2^n ,2~256) ,棕色框框為攝影機大小&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將旋轉桿和攝影機結合並設定從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/add_2views.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/first_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/second_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;啟動程式來跑看看囉~&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision.gif"&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;dummy ( 虛擬座標 ) :&lt;/h3&gt;
&lt;h3&gt;dummy 能夠讓不是從屬性質的物件做相對移動, 常用於close chain, 以irb360範例來說 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;a. b.桿為示範物件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將a.及b.桿實體隱藏之後 ,能夠看到從屬於a、b桿下的dummy為重疊狀態 ,並且為互相對應(target)  &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目的是因為 ,若a桿做出任何動作(移動) ,在它從屬下的dummy會隨著target的dummy做相對運動 ,因此兩桿距離始終會保持固定 &lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件大小 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;size factor 為 目前模型的 比例 ,透過下方 Scaling 可以設定模型倍率 ,若Scaling factor 設為2 ,上方的size factor 會變成2 ,就是原始模型的2倍大&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/size_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件座標系 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;導入零件後 ,拆解發現零件的角度與V-rep右下角(World)的座標不同 ,有時對於joint的放置會變得不方便 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選要改變座標的零件後 ,在edit選單下點選Reorient bounding box→with reference frame of world 即可&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;利用三角建構零件放入joint :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;因為手臂有個齒輪 ,且有傾斜角度 ,所以需要透過零件轉換 ,並插入一個圓軸來輔助joint&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選零件後右鍵選取 Edit→Decimate selected shape後 ,選擇三角形數量 (太少圓形會變多角形 ,太多運算會變慢) ,之後點選左方 Toggle shape edit mode&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;全選所有三角形 ,並點選Extract cylinder後按OK&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後就可以順利放上joint了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape_2.png"&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/29</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050629.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323250ri-zhi-1050629.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;


&lt;h3&gt;進度&lt;/h3&gt;

&lt;h4&gt;目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖:&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/OCcfYur.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/64Qlmfm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是v-rep拆解後的截圖&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;簡易版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/1C9EKl2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;完整版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/I7q77aX.png"&gt;
&lt;/br&gt;
&lt;h3&gt;明天應該就可以開始測試模擬了。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/28</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050628.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323250ri-zhi-1050628.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;


&lt;h3&gt;目前組合進度&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/D2k3uqk.gif"&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的狀況&lt;/h3&gt;
&lt;h4&gt;我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/W3N5pkC.png"&gt;
&lt;/br&gt;
&lt;h4&gt;滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>Summer Plan</title><link href="http://project.mde.tw/blog/summer-plan.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/summer-plan.html</id><summary type="html">&lt;p&gt;Summer project&lt;/p&gt;


&lt;p&gt;1.畫3D Printer (V-rep ,Onshape)&lt;/p&gt;

&lt;p&gt;2.實驗室網站介面&lt;/p&gt;

&lt;p&gt;3.Octopi ,機械手臂&lt;/p&gt;

&lt;p&gt;4.OpenCV &lt;/p&gt;

&lt;p&gt;5.RGA演算&lt;/p&gt;

&lt;p&gt;6.認證主機(Virtual Box)&lt;/p&gt;

&lt;p&gt;7.Proxy&lt;/p&gt;

&lt;p&gt;8.報告(拍照 ,內容整理)&lt;/p&gt;

&lt;p&gt;9.找碩班教授&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;暑期人數 : &lt;/p&gt;
&lt;p&gt;七月:第一組3人 ,第二組4人&lt;/p&gt;
&lt;p&gt;八月:第一組3人 ,第二組4人 ,第三組1人&lt;/p&gt;
&lt;p&gt;&lt;font size="5" face="Arial"&gt;&lt;marquee border="0" scrollamount="50" behavior="alternate"&gt;You can't see me&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>OpenCv範例執行</title><link href="http://project.mde.tw/blog/opencvfan-li-zhi-xing.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-24:blog/opencvfan-li-zhi-xing.html</id><summary type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;


&lt;h3&gt;實作系統Ubuntu 14.04 以及 老師整合的檔案&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image"&gt;範例網址1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/picture/messi.jpg"&gt;使用到的圖片&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
img = cv2.imread('messi.jpg',0)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv2.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv2.imwrite('messigray.png',img)
    cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/tI55TDf.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html#display-video"&gt;範例網址2.&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)
while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break&lt;/p&gt;
&lt;h1&gt;When everything done, release the capture&lt;/h1&gt;
&lt;p&gt;cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/MOL03LL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;範例網址3.(同上)&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)&lt;/p&gt;
&lt;h1&gt;Define the codec and create VideoWriter object&lt;/h1&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        # write the flipped frame
        out.write(frame)
        cv2.imshow('frame',frame)
        if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
            break
    else:
        break&lt;/p&gt;
&lt;h1&gt;Release everything if job is finished&lt;/h1&gt;
&lt;p&gt;cap.release()
out.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;h4&gt;得到檔案名稱為output的avi影片檔&lt;/h4&gt;&lt;/p&gt;</summary><category term="OpenCv"></category></entry><entry><title>40323231日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050714.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323231ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;3DP碰到的問題及解決&lt;/p&gt;


&lt;h3&gt;第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床?&lt;/h3&gt;
&lt;h3&gt;解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為"+""-""S"顏色分別為"紅""藍""黑"，夢工老師接的是"+"接紅，"-"接藍，"S"接黑。網路是"+"接紅，"-"接黑，"S"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。&lt;/h3&gt;
&lt;h3&gt;問題:1. "+""-""S"如何接?  2.為何線路有的接兩條有的接三條?&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;限位開關分兩種:&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;1. 機械微動開關接法&lt;/h3&gt;
&lt;h4&gt;機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;2. 光學限位開關接法(我們的)&lt;/h3&gt;
&lt;h4&gt;光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;1.S為藍，+為紅，-為黑&lt;/h3&gt;
&lt;h3&gt;2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天進度&lt;/h3&gt;
&lt;h4&gt;組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230紀錄 - Python-Solvespace編譯完畢</title><link href="http://project.mde.tw/blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows執行成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu執行失敗（需重生&lt;code&gt;_slvs.so&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/E4PEUbR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後編譯時把&lt;code&gt;_slvs.so&lt;/code&gt;改成了&lt;code&gt;_slvs.pyd&lt;/code&gt;就能使用了。&lt;/p&gt;
&lt;p&gt;有測試過改成&lt;code&gt;.dll&lt;/code&gt;的方式，但是反而不能使用，可能是Windows平台Python辨認的問題。&lt;/p&gt;
&lt;p&gt;不過由於&lt;code&gt;_slvs.pyd&lt;/code&gt;是參照&lt;code&gt;libslvs.so&lt;/code&gt;的內容生成的，所以這四個檔案必須放在同一個資料夾：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;solvespace/exposed/_slvs.pyd
solvespace/exposed/libslvs.so
solvespace/exposed/slvs.py
solvespace/exposed/Usage.py
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;倉儲的Readme也做了一下說明。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;test.py&lt;/code&gt;執行結果中，偵測到&lt;code&gt;long&lt;/code&gt;還沒定義，所以資料庫還需要修理一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ejc5KDo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搬到新電腦虛擬機的Ubuntu上測試時，使用的是&lt;code&gt;_slvs.so&lt;/code&gt;的樣式。&lt;/p&gt;
&lt;p&gt;會顯示ELF標頭檔錯誤，而無法執行，應該是因為在Windows上生成的關係，重新在Ubuntu上編譯應該就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jolKcHW.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;另外在新電腦虛擬機的Ubuntu上裝了一下Git、Netbeans和GNU工具包，可以正常運作，不過可能是跨系統模擬的關係，反應還滿慢的。&lt;/p&gt;
&lt;p&gt;然後Python3不知道怎麼更新，一直在3.4.2沒辦法升上去。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230紀錄 - C語言資料庫格式</title><link href="http://project.mde.tw/blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html</id><summary type="html">&lt;p&gt;關於各平台程式使用之連結庫類型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Static libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shared libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically loaded libraries&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://terrycslife.blogspot.tw/2010/07/so.html" title="terrycslife.blogspot.tw"&gt;http://terrycslife.blogspot.tw/2010/07/so.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/" title="kaineshu.wordpress.com"&gt;https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.jianshu.com/p/09994c9d8489" title="jianshu.com"&gt;http://www.jianshu.com/p/09994c9d8489&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Object File :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.o&lt;/code&gt;或是&lt;code&gt;.obj&lt;/code&gt;，後者為Windows使用的格式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpxnXLj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將&lt;code&gt;.c&lt;/code&gt;或&lt;code&gt;.cpp&lt;/code&gt;、&lt;code&gt;.cxx&lt;/code&gt;的C語言程式碼包裝成的物件檔，無法直接使用。&lt;/p&gt;
&lt;p&gt;使用編譯工具的"Link"功能可以將這些單獨的物件檔合併成連結庫或是可執行檔。&lt;/p&gt;
&lt;h2&gt;Static libraries - 靜態資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作用方式：將連結庫包入程式中執行，處理效率高，缺點是檔案大且不易更新。&lt;/p&gt;
&lt;p&gt;若要建立一個靜態資料庫，可以使用DllTool從&lt;code&gt;.dll&lt;/code&gt;檔解出或是用GNU的&lt;code&gt;ar&lt;/code&gt;工具連結物件檔編譯。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar&lt;/code&gt;的指令中，&lt;code&gt;rcs&lt;/code&gt;或是&lt;code&gt;-r&lt;/code&gt;後接上輸出的檔案名稱，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar rcs libmylib.a first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生靜態資料庫後，可以使用gcc的&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;指令連結，對象包含程式碼、物件檔和其他靜態資料庫。&lt;/p&gt;
&lt;h2&gt;Shared libraries - 共用資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.so&lt;/code&gt;，後面可加掛版本編號。&lt;/p&gt;
&lt;p&gt;作用方式：資料庫和執行檔是分離的，剛開始就要載入，並且資料庫必須一直和執行檔待在一起，優點是修改方便。&lt;/p&gt;
&lt;p&gt;gcc在產生物件檔時必須加上&lt;code&gt;-fPIC&lt;/code&gt;參數，紀錄"position-independent code"，就是獨立位置碼，以紀錄存取位置的資訊。沒有使用的話只會用相對位置，不利於共享內容。&lt;/p&gt;
&lt;p&gt;再來將物件檔合併成資料庫時，加上&lt;code&gt;-shared&lt;/code&gt;參數，接著要自訂義"soname"、"real name"、"linker name"。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;soname是資料庫的名稱，通常以&lt;code&gt;lib&lt;/code&gt;開頭，包含附檔名和大版號，如&lt;code&gt;libexample.so.1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;real name是真正使用程式的資料庫名稱，包含小版號，如&lt;code&gt;libexample.so.1.0.0&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linker name是連結時的資料庫名稱，不包含版號，如&lt;code&gt;libexample.so&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;gcc使用&lt;code&gt;-Wl&lt;/code&gt;參數向內建的Link工具"ln"傳入資訊，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcc -shared -Wl,-soname,libexample.so.1 -o libexample.so.1.0.0 first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-Wl,-soname&lt;/code&gt;定義soname；輸出的檔案名稱為real name；使用&lt;code&gt;-l&lt;/code&gt;或&lt;code&gt;-l:&lt;/code&gt;連結的名稱為linker name。&lt;/p&gt;
&lt;p&gt;尋找了下&lt;a href="https://en.wikipedia.org/wiki/Soname" title="https://en.wikipedia.org/wiki/Soname"&gt;維基百科&lt;/a&gt;，似乎也能使用&lt;code&gt;-h&lt;/code&gt;和&lt;code&gt;-soname=&lt;/code&gt;來定義soname的名稱。&lt;/p&gt;
&lt;p&gt;資料庫連結時使用&lt;code&gt;ln&lt;/code&gt;指令連結兩個&lt;code&gt;.so&lt;/code&gt;檔。使用&lt;code&gt;-s&lt;/code&gt;參數為軟連結，類似捷徑式的參照；使用&lt;code&gt;-d&lt;/code&gt;參數為硬連結，類似副本的備份。&lt;/p&gt;
&lt;p&gt;最後必須用以下指令為real name創造linker name和soname的檔案（使用&lt;code&gt;-s&lt;/code&gt;或&lt;code&gt;-d&lt;/code&gt;就隨喜好了）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;linker name&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;soname&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之後可以用GNU的另一個工具"objdump"檢查連結。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objdump -p libexample.so.1.3 | grep SONAME&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生共用資料庫後，可以像靜態資料庫一樣包裝，也可以用程式呼叫。&lt;/p&gt;
&lt;p&gt;連結時有同名資料庫時會以共用資料庫優先，加上&lt;code&gt;-static&lt;/code&gt;參數可以指定靜態資料庫。&lt;/p&gt;
&lt;p&gt;而調用資料庫時是先找soname的檔案，否則會尋找linker name的檔案，可執行檔亦同。&lt;/p&gt;
&lt;h2&gt;Dynamically loaded libraries - 動態載入庫 :&lt;/h2&gt;

&lt;p&gt;為Windows中&lt;code&gt;.dll&lt;/code&gt;檔標準的模式，不過並非所有&lt;code&gt;.dll&lt;/code&gt;都是如此。&lt;/p&gt;
&lt;p&gt;作用方式：使用時才會載入，編譯時不須要相關資料庫檔案，因此常用於附加元件。&lt;/p&gt;
&lt;p&gt;使用一套DLL funtion來處理，標頭檔和編譯的程式碼中都會使用來傳遞訊息。&lt;/p&gt;
&lt;p&gt;gcc編譯時要加上&lt;code&gt;-ldl&lt;/code&gt;參數連結。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;後來發現gcc有時編譯「成功」的樣子可能包含著錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Pk6DJDw.jpg" &gt;&lt;/p&gt;
&lt;p&gt;今天測試了一些方法，但是明明CDemo和Python的&lt;code&gt;.so&lt;/code&gt;都是差不多的參數，編譯出的結果卻不如預期。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;libslvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o libslvs.so ../obj/util.obj ... ../obj/w32util.obj
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;_slvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o _slvs.so ../obj/util.obj ... ../obj/slvs_wrap.o -LW:/Anaconda3/libs -lPython35 -L. -l:libslvs.so
&lt;/pre&gt;

&lt;p&gt;如果編譯&lt;code&gt;_slvs.so&lt;/code&gt;時不加上後面的&lt;code&gt;-LW:/Anaconda3/libs&lt;/code&gt;、&lt;code&gt;-lPython35&lt;/code&gt;等等就會因為&lt;code&gt;slvs_wrap.o&lt;/code&gt;的&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;出問題，但是沒加上就和&lt;code&gt;libslvs.so&lt;/code&gt;一樣了。&lt;/p&gt;
&lt;p&gt;但是這樣另一個問題就產生了，因為編出來的&lt;code&gt;_slvs.so&lt;/code&gt;是「可執行檔」，不指定&lt;code&gt;-o _slvs.so&lt;/code&gt;的話就會編譯成&lt;code&gt;a.exe&lt;/code&gt;，所以其他Python程式碼都找不到（有搬到虛擬機的Ubuntu測試，也找不到）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/A9ITgDd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;想過學範例用&lt;code&gt;.c&lt;/code&gt;跳過Object File的階段直接轉成&lt;code&gt;.so&lt;/code&gt;檔，但是只有&lt;code&gt;libslvs.so&lt;/code&gt;成功，&lt;code&gt;_slvs.so&lt;/code&gt;反而在系統暫存檔Temp資料夾中找不到Python連結。&lt;/p&gt;
&lt;p&gt;之後稍微看了一下SWIG轉出的&lt;code&gt;slvs.py&lt;/code&gt;結構，呼叫的&lt;code&gt;.py&lt;/code&gt;檔必須先導入&lt;code&gt;slvs.py&lt;/code&gt;後，&lt;code&gt;slvs.py&lt;/code&gt;會視Python版本取用&lt;code&gt;_slvs.so&lt;/code&gt;的內容，再傳給需要的&lt;code&gt;.py&lt;/code&gt;檔，所以&lt;code&gt;slvs.py&lt;/code&gt;和&lt;code&gt;_slvs.so&lt;/code&gt;都必須和撰寫的&lt;code&gt;.py&lt;/code&gt;檔放在一起。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050722.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050722.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python-Solvespace編譯完畢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進行&lt;code&gt;_slvs.so&lt;/code&gt;呼叫測試。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已推送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯成功 :&lt;/h2&gt;

&lt;p&gt;上次編譯時一直找不到&lt;code&gt;Slvs_&lt;/code&gt;相關名稱的問題。&lt;/p&gt;
&lt;p&gt;最後發現編譯&lt;code&gt;_slvs.so&lt;/code&gt;時加入參照&lt;code&gt;libslvs.so&lt;/code&gt;資料庫的指令（&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;），就成功編譯了。&lt;/p&gt;
&lt;p&gt;結束編譯時，Makefile執行了CDemo.exe證明C語言調用&lt;code&gt;libslvs.so&lt;/code&gt;是完全沒問題的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M7G0AH3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著要試著執行Python調用&lt;code&gt;_slvs.so&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;測試test.py和Usage.py :&lt;/h2&gt;

&lt;p&gt;作者提供了2個範例使用，將它們和&lt;code&gt;_slvs.so&lt;/code&gt;放在相同目錄中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Usage.py&lt;/code&gt;是參照Readme的說明，將範例code抓下來存在&lt;code&gt;exposed&lt;/code&gt;資料夾的程式檔。&lt;/p&gt;
&lt;p&gt;然而若直接執行會出下列錯誤：&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;test.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dp86EeP.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;Usage.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/goKX3du.jpg" &gt;&lt;/p&gt;
&lt;p&gt;意思是Python無法調用&lt;code&gt;_slvs&lt;/code&gt;這個模組，大部分的原因是名稱錯誤或是沒有導入。&lt;/p&gt;
&lt;p&gt;SWIG手冊的"Using distutils"之後的幾章是講導出模組後的應用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xm3XyRs.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看了一下內容，Python導出後的模組可以作為Python的附加元件、直接呼叫、動態模組、靜態連結之類的。&lt;/p&gt;
&lt;p&gt;不過沒有解答一些例外的錯誤。&lt;/p&gt;
&lt;p&gt;但是一直找不到&lt;code&gt;_slvs.so&lt;/code&gt;，不知道是出了甚麼問題，會繼續尋找資料。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;公開倉儲 :&lt;/h2&gt;

&lt;p&gt;把目前進度推到了自己的&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;倉儲，在&lt;code&gt;exposed&lt;/code&gt;資料夾中的Makefile編輯工具位置，就能Make和Clean。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5OAbuX.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050720.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050720.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;gcc的&lt;code&gt;-M&lt;/code&gt;類型參數問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;math.h與pyconfig.h衝突修正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用libpython35.a解決_wrap.cxx找不到函式的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Solvespace Makefile :&lt;/h2&gt;

&lt;p&gt;目前發現obj檔案無法辨識的原因是原始Makefile中加上了&lt;code&gt;-MT&lt;/code&gt;這個參數，然而沒有這個參數，只能改用&lt;code&gt;-MD&lt;/code&gt;來取代。&lt;/p&gt;
&lt;p&gt;直到Link這些obj檔時才發現，這些obj檔竟然是文字文件，而另一個Makefile導出的obj檔都相當正常。&lt;/p&gt;
&lt;p&gt;最後決定把Makefile中gcc的參數統一化，剩下才發現&lt;code&gt;-M&lt;/code&gt;系的參數會輸出信息檔，而不是物件。&lt;/p&gt;
&lt;p&gt;但是將obj檔重新連結成&lt;code&gt;solvespace.exe&lt;/code&gt;時就開始顯示大大小小的錯誤了，而且並非&lt;code&gt;-W&lt;/code&gt;的普通警告。相反的另一邊exposed資料夾就沒出現過警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/fnQrcS8.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以要成功編譯就必須將錯誤修正，看一些關於C++的資料。這些錯誤貌似都是物件繼承、指標項的用法問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2dtnGX0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過今天專注在如何克服exposed資料夾的錯誤。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;MinGW的math.h和Python的pyconfig.h :&lt;/h2&gt;

&lt;p&gt;上網搜尋了許多文章，大部分的人使用MinGW編譯C轉Python的文件時，同時導入&lt;code&gt;cmath&lt;/code&gt;和&lt;code&gt;Python.h&lt;/code&gt;都會遇到這個衝突。&lt;/p&gt;
&lt;p&gt;主要原因是＜math.h＞中有一段&lt;code&gt;_hypot(double _X, double _Y)&lt;/code&gt;的函式，而它的名稱剛好與&lt;code&gt;pyconfig.h&lt;/code&gt;中的&lt;code&gt;define hypot _hypot&lt;/code&gt;衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xdCKbBE.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網搜尋時找到一系列2013年的信件：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html" title="vtk.org"&gt;http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要是討論如何處理這個問題，信中曾建議在自己的程式碼的&lt;code&gt;include ＜Python.h＞&lt;/code&gt;下加上這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜cmath＞
#include ＜Python.h＞
#ifdef hypot
#undef hypot
#endif
&lt;/pre&gt;

&lt;p&gt;但是這樣根本不可行，因為導入&lt;code&gt;Python.h&lt;/code&gt;時就會同時導入&lt;code&gt;pyconfig.h&lt;/code&gt;，一旦導入&lt;code&gt;pyconfig.h&lt;/code&gt;就會產生衝突，後面再undefine也不會有用。&lt;/p&gt;
&lt;p&gt;所以根本的問題就是修改&lt;code&gt;pyconfig.h&lt;/code&gt;，變成這一段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef _MATH_H_
#define hypot _hypot
#endif
&lt;/pre&gt;

&lt;p&gt;讓它只能在沒有&lt;code&gt;math.h&lt;/code&gt;的時候才能使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4OWuZG1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;更改後編譯就沒有問題了。&lt;/p&gt;
&lt;p&gt;不過不知道這樣更改會不會讓Anaconda的Python衍生其他狀況。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;libpython35.a :&lt;/h2&gt;

&lt;p&gt;出現了&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;匯入函式的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
slvs_wrap.o: In function `_SWIG_Py_None':
slvs_wrap.cxx:1446: undefined reference to `__imp__Py_RefTotal'
...
&lt;/pre&gt;

&lt;p&gt;這些是SWIG自動產生的，interface無法修改。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，應該是軟體位元問題，找到了類似的問題。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/" title="gdomc.com"&gt;http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著參考另一篇文章生成&lt;code&gt;libpython35.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows" title="github.com"&gt;https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，將Python的DLL檔複製一份進Python的libs資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6CGP2VW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下載&lt;code&gt;gendef.exe&lt;/code&gt;，它也是MinGW的工具之一，從下列網址下載&lt;code&gt;gendef-1.0.1346-1-mingw32-bin.tar.lzma&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/" title="sourceforge.net"&gt;https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮進MinGW的bin資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CsH45V5.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著用CMD進入Python的libs資料夾中使用以下命令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
gendef python35.dll
dlltool --dllname python35.dll --def python35.def --output libpython35.a
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/nMybQmX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dlltool&lt;/code&gt;是GNU內建的工具，有安裝過安裝版的GNU工具包就能在本機端環境使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wAdo8A1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;做完後就會產生&lt;code&gt;libpython35.a&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;然後到Python的include資料夾開啟&lt;code&gt;pyconfig.h&lt;/code&gt;這個檔案編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oSfNLI9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋並將以下內容剪下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _WIN64
#define MS_WIN64
#endif
&lt;/pre&gt;

&lt;p&gt;貼到以下內容的「上方」：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _MSC_VER
...
&lt;/pre&gt;

&lt;p&gt;再到Python的&lt;code&gt;Lib\distutils&lt;/code&gt;資料夾中，開啟&lt;code&gt;cygwinccompiler.py&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XwvABHb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋以下內容並註解掉：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
self.dll_libraries = get_msvcr()
&lt;/pre&gt;

&lt;p&gt;注意四周會有相似的內容，不要弄錯註解。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xfY1FU0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;範例在編譯&lt;code&gt;slvs_wrap.o&lt;/code&gt;時加上&lt;code&gt;-DMS_WIN64&lt;/code&gt;參數。&lt;/p&gt;
&lt;p&gt;不過這時因為已經修改過&lt;code&gt;pyconfig.h&lt;/code&gt;的內容，會自動宣告&lt;code&gt;MS_WIN64&lt;/code&gt;，所以加上會提示說重複宣告。&lt;/p&gt;
&lt;p&gt;最後編譯用的指令如下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -IW:/Anaconda3/include -Wno-unused-but-set-variable -c -o ../obj/slvs_wrap.o slvs_wrap.cxx
g++ -shared -fPIC -o _slvs.so ... ../extlib/si/siapp.lib  -LW:/Anaconda3/libs -lPython35
&lt;/pre&gt;

&lt;p&gt;但是最後還是出現一點錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ie05RYb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;應該是內部的導入問題。&lt;/p&gt;
&lt;p&gt;由於時間不多，所以這個部分之後再解決。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天有稍微比較下Whitequark的原始碼，不過用法已經完全不一樣，相同的變數也改變了型態，更有系統性，但是也更難判讀，所以&lt;code&gt;.cpp&lt;/code&gt;的部分還得熟悉相關的知識。&lt;/p&gt;
&lt;p&gt;Solvespace Makefile的部分是編譯&lt;code&gt;solvespace.exe&lt;/code&gt;的部分，不過Python呼叫的部分應該是不用那麼多，畢竟那些大部分都是介面檔，真正的本體只需要判斷是否衝突。&lt;/p&gt;
&lt;p&gt;所以Solvespace Makefile的部分才做得漫不經心吧。&lt;/p&gt;
&lt;p&gt;exposed Makefile部分的&lt;code&gt;all&lt;/code&gt;為三個目標：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
all: cdemo _slvs.so slvs.py
    LD_LIBRARY_PATH=. ./cdemo
&lt;/pre&gt;

&lt;p&gt;CDemo的部分已經成功轉出可執行檔；&lt;code&gt;_slvs.so&lt;/code&gt;還在最後階段的編譯中；&lt;code&gt;slvs.py&lt;/code&gt;則是原作者撰寫好的（不過是Python 2）。&lt;/p&gt;
&lt;p&gt;預計不久後就能夠測試&lt;code&gt;_slvs.so&lt;/code&gt;的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050719.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;Python-Solvespace編譯除錯中。&lt;/p&gt;


&lt;h2&gt;Netbeans的版次管理與自訂工具列 :&lt;/h2&gt;

&lt;p&gt;Netbeans有內建檔案版本紀錄的功能，只要在檔案左上角的按鈕切換到&lt;code&gt;History&lt;/code&gt;，就會出現修改紀錄表。&lt;/p&gt;
&lt;p&gt;點擊其中的項目就會顯示並和目前版本的檔案做比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dwmVZD4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其中紅色是刪除；綠色是新增；藍色是取代。&lt;/p&gt;
&lt;p&gt;如果想復原其中的項目，可以移到顏色區塊上，左側的版本會出現箭頭，能夠將舊版的內容復原至當前的區段中，十分方便。&lt;/p&gt;
&lt;p&gt;若是想直接復原整個檔案，可以在紀錄上案右鍵，選擇&lt;code&gt;Revert from History&lt;/code&gt;就會復原檔案。特別的是，一但復原檔案，Netbeans就會直接儲存檔案，成為新的歷史紀錄，這方面需要多注意。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2Ih9AVd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而專案中的檔案名稱也會配上顏色，不論是在左側的檔案樹或是分頁上。&lt;/p&gt;
&lt;p&gt;黑色是一般clone下來的專案；藍色是使用者修改過的檔案（縱使已經復原到原始版本）；灰色是透過MinGW以外程式編寫的檔案；綠色是自己撰寫或是由MinGW編譯出的檔案。&lt;/p&gt;
&lt;p&gt;Netbeans是以Git功能為基礎架設的（雖然不一定要使用），因此十分注重版次管理，也支援圖形化顯示&lt;code&gt;git pull&lt;/code&gt;的修改處。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/H2v8Lve.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一個個人化的功能就是自訂工具列，能夠將內建或模組的功能鈕設置在工具列上。&lt;/p&gt;
&lt;p&gt;排列方法跟Firefox一樣是抓取的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/W7kSbRH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;上次的問題 :&lt;/h2&gt;

&lt;p&gt;上一篇網誌中的問題：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Netbeans找不到外部程式的問題已解決，只要指定程式的確切位置就能執行。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以指定Perl在W:槽的位置，上次發現的Perl其實是MinGW的附加工具，版本是5.8。&lt;/p&gt;
&lt;p&gt;但是新下載的是5.24，並且有安裝需要的模組"GD"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zSV5yLU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/NjpIYjZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改成下面這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
PERL = W:\Perl524\bin\perl.exe

...

$(OBJDIR)/icons.h: png2c.pl icons/*
    @echo icons
    $(PERL) $＜ $@ $(OBJDIR)/icons-proto.h
&lt;/pre&gt;

&lt;p&gt;指定後就可以執行。&lt;/p&gt;
&lt;p&gt;而後來又有一個"rc"的指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(RES): win32/$(@B).rc icon.ico
    rc win32/$(@B).rc
    mv win32/$(@B).res $(OBJDIR)/$(@B).res
&lt;/pre&gt;

&lt;p&gt;（原始版本的錯誤用法＄(＠B)應該為＄(＠F)，都改為＄＜或＄^較明瞭）&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;經查詢資料，"rc.exe"原是Windows Kits的一個工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QWfaVfq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以就改寫用變數指定。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
RC = "C:\Program Files (x86)\Windows Kits\$(RCVER)\bin\$(RCBIT)\rc.exe"
RCVER = 10
RCBIT = x64

...

$(RES): resource.rc icon.ico
    @echo RES
    $(RC) $＜
    mv win32/resource.res  $@
&lt;/pre&gt;

&lt;p&gt;同理，其他如SWIG都可以呼叫所在位置來執行了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要改一下語法，之前使用的&lt;code&gt;-lslvs&lt;/code&gt;應該指定名稱&lt;code&gt;-l:libslvs.so&lt;/code&gt;並指定同目錄：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
cdemo: CDemo.c libslvs.so
    @echo cdemo
    @$(CXX) $(CFLAGS) -o $@ $＜ -L. -l:libslvs.so $(LIBS)
&lt;/pre&gt;

&lt;p&gt;接著就能夠找到libslvs.so。&lt;/p&gt;
&lt;p&gt;不知道是因為沒有&lt;code&gt;-L&lt;/code&gt;指定目錄還是&lt;code&gt;-l&lt;/code&gt;不會看附檔名的關係，一定要標定到檔案才會容許。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;錯誤紀錄 :&lt;/h2&gt;

&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Funtion "vasprintf"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在"slvs_python.hpp"中，導入了一個stdio.h的函式&lt;code&gt;vasprintf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不過其實正確名稱應該要增加父項式，因此修改成&lt;code&gt;__mingw_vasprintf(&amp;amp;buf, fmt, args)&lt;/code&gt;就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/czsgUbf.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeams應該是支援h++的標頭檔，但是"slvs_python.hpp"的前半段錯誤累累，應該是從屬關係和宣告的部分沒弄清楚。&lt;/p&gt;
&lt;p&gt;目前並沒有干擾MinGW的編譯，但是這些東西應該重新整理一下，尤其是下面的導入：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜string＞
#include ＜exception＞
&lt;/pre&gt;

&lt;p&gt;在編寫時好像連結不到，但是編譯時MinGW抓得到，不知道Netbeams的錯誤有沒有算入這種情形。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CMath&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用SWIG剛轉出"slvs_wrap.cxx"時產生的問題。&lt;/p&gt;
&lt;p&gt;出現一段錯誤：&lt;code&gt;error: '::hypot' has not been declared&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在其他人的commit中有解答：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/casadi/casadi/issues/622" title="github.com"&gt;https://github.com/casadi/casadi/issues/622&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是說要新增&lt;code&gt;include ＜cmath＞&lt;/code&gt;進"slvs_wrap.cxx"中，而且必須在"Python.h"之前。&lt;/p&gt;
&lt;p&gt;所以我就在interface檔中新增了，讓轉換時會自動加入這段。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cqgzD3B.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個問題是暫時解決，後來又有相關的麻煩。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;分成兩部分的Makefile，主要是exposed資料夾的python函式比較重要。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在最後一個要生成"solvespace.exe"時無法辨識&lt;code&gt;.obj&lt;/code&gt;檔案？&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32 -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS   obj/ratpoly.obj ... obj/resource.res -o obj/solvespace.exe
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj: file format not recognized; treating as linker script
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj:1: syntax error
collect2.exe: error: ld returned 1 exit status
make.exe": *** [obj/solvespace.exe] Error 1
&lt;/pre&gt;

&lt;p&gt;目前還不知道怎麼辦，因為不太了解&lt;code&gt;.o&lt;/code&gt;和&lt;code&gt;.obj&lt;/code&gt;的關係。&lt;/p&gt;
&lt;p&gt;前者是暫時等待編譯的物件，後者是給記憶體參照的。&lt;/p&gt;
&lt;p&gt;gcc對於副檔名是很重視的，可能要調整參數之類的？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Exposed Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;剩下幾步可以編成"slvs_wrap.o"。&lt;/p&gt;
&lt;p&gt;最後跳出的錯誤，竟然是內建資料庫的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
In file included from W:/Anaconda3/include/Python.h:8:0,
                 from slvs_wrap.cxx:14:
W:/Anaconda3/include/pyconfig.h:262:15: error: 'std::_hypot' has not been declared
 #define hypot _hypot
               ^
make.exe": *** [../obj/slvs_wrap.o] Error 1
&lt;/pre&gt;

&lt;p&gt;導入"Python.h"和相關的"pyconfig.h"時出現了錯誤。是從上面cmath衍生的問題。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，好像找不到解決方法，&lt;code&gt;'std::_hypot' has not been declared&lt;/code&gt;好像有出現在MinGW的Bug紀錄中。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這兩個Makefile的使用參數大相逕庭，以下是比較：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DEFINES = -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32
CFLAGS = -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Exposed&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
WIN_DEFINES = -D_WIN32_WINNT=0x500 -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN
DEFINES = -DISOLATION_AWARE_ENABLED -DLIBRARY
CFLAGS  = -I../extlib -I../../common/win32 -I. -I.. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS -O2 -g -Wno-write-strings -fpermissive
CFLAGS_SHARED = -fPIC -shared $(CFLAGS)
&lt;/pre&gt;

&lt;p&gt;兩個Makefile編譯階段都進入整合階段，剩下的一些編譯問題主要是對MinGW的編譯程式不熟悉的緣故。&lt;/p&gt;
&lt;p&gt;像是一般的&lt;code&gt;.so&lt;/code&gt;、&lt;code&gt;.o&lt;/code&gt;都較為廣用，可是將obj檔直接轉換成可執行檔，卻找不到範例。&lt;/p&gt;
&lt;p&gt;之後要再找找看gcc和g++的編譯範例。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050718.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050718.html</id><summary type="html">&lt;p&gt;改寫Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;前言 :&lt;/h2&gt;

&lt;p&gt;閱讀GNU-Make的手冊之後，已經了解Makefile基本的運作方式，所以試圖解決Python-Solvespace編譯程序中出現的問題。&lt;/p&gt;
&lt;p&gt;手冊連結：&lt;a href="https://www.gnu.org/software/make/manual/make.pdf" title="gnu.org"&gt;https://www.gnu.org/software/make/manual/make.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用Interface來轉換Whitequark的新版Solvespace應該是不太可行的方式了，何況Python-Solvespace也未使用全部的功能，我們需要的是解題的函式就好。&lt;/p&gt;
&lt;p&gt;而另一方面Solid-python現在已經完全支援Python 3，若之後要調用其功能，應該也不會有太大的障礙。&lt;/p&gt;
&lt;p&gt;所以決定把Python-Solvespace的Makefile重新寫好，將Python-Solvespace的資料庫建構完成。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Netbeans的支援 :&lt;/h2&gt;

&lt;p&gt;其實Netbeans與$GNU開發者工具包$周邊的軟體都有良好的相依性，因此在撰寫Makefile時方便不少。&lt;/p&gt;
&lt;p&gt;在編寫完Makefile時，可以在個別的Makefile上點擊右鍵，選擇需要的命令讓make執行，諸如all、clean等等的功能可以選擇。&lt;/p&gt;
&lt;p&gt;Makefile中可以撰寫功能讓工程師執行，連基本的clean功能也可以自訂要刪除哪些檔案。&lt;/p&gt;
&lt;p&gt;當然利用這點，Makefile中也可以利用Echo做help的功能，Whitequark的Solvespace就有支援。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9DDeyVj.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編寫Makefile :&lt;/h2&gt;

&lt;p&gt;原本Python-Solvespace的Makefile是將檔案分類，再一類類用一樣的式子做轉換，而且語法冗長還有許多錯誤。若有新增檔案，就必須填入參數的名單中登記。&lt;/p&gt;
&lt;p&gt;一個小型程式專案的Makefile事實上只需要下列的式子就能轉換：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(ADIR)/%.obj: $(BDIR)/%.cpp $(HEADERS)
    $(CXX) $(FLAGS) -c -o $@ $＜
&lt;/pre&gt;

&lt;p&gt;意思是ADIR中的obj檔都與BDIR的cpp檔、標頭檔有關聯，而每個obj檔是由每個cpp檔透過＄(CXX)命令式產生的。&lt;/p&gt;
&lt;p&gt;$後面的＄＠表示每個目標項（包括其位置）$；同理，$＄＜亦代表每個參照項$，不過＄＜是只包含第一個條件的參照項，所以後面的多個標頭檔就不會帶入＄(CXX)命令中。&lt;/p&gt;
&lt;p&gt;若要在命令式中使用所有條件的參照項，要使用＄+，但是更好的選擇是使用＄^，會自動排除重複名稱的參照項。&lt;/p&gt;
&lt;p&gt;這樣寫固然簡單，但是每個檔案都在不同的資料夾中，要如何讓make搜尋？&lt;/p&gt;
&lt;p&gt;所以必須加上VPath這個參數，讓尋找參照檔案時可以搜尋到所有符合的項目。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wpUqKDX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;make在找檔案時最大的特性就是$按邏輯去找$。&lt;/p&gt;
&lt;p&gt;也因為這點，不用顧慮產生檔案的順序問題。只要"填寫"檔案是如何產生的，make就會根據需要的檔案來做順序調整。&lt;/p&gt;
&lt;p&gt;make會先忽略還沒產生的參照檔案，尋找已經備齊參照檔案的項目先做，指令亦可使用外部程式來執行。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯瓶頸 :&lt;/h2&gt;

&lt;p&gt;經過重新整理的Makefile，應該是沒有問題了，都將指令分配完整沒有衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IkKQSqe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是仍然遇到Makefile以外的一些問題。&lt;/p&gt;
&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Stdint.h&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;這個原先是C語言的額外函式庫，幫助統一化使用的格式，但是如果沒裝，就會選擇作者寫的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Rz3xBwO.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個地方應該是寫錯了，會一直認為這些是未定義的格式。&lt;/p&gt;
&lt;p&gt;其實導入"stdint.h"的地方也只有上圖的前半段，所以最快的解決方法就是讓solvespace.h擁有stdint.h一部份的能力。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BireSqB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在上面這張Netbeans的比較圖中，直接把前半段的功能插進來用了，並成功解決問題。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Min &amp;amp; Max Funtions&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下列solvespace.h的函式出了問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef min
#define min(x, y) ((x) &lt; (y) ? (x) : (y))
#endif
#ifndef max
#define max(x, y) ((x) &gt; (y) ? (x) : (y))
#endif
&lt;/pre&gt;

&lt;p&gt;上網搜尋了一下，找到基本款的用法：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#define min(x, y) (((x)＜(y)) ? (x):(y))
#define max(x, y) (((x)&gt;(y)) ? (x):(y))
&lt;/pre&gt;

&lt;p&gt;加上括弧其實非必要，因為三元運算子的優先度本身就比大於小於還低。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l5u0t2N.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個判斷式使用上怪怪的，移除後直接define就沒這個問題了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Object-oriented problem&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在surface.h中有一段是這樣描述的：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;到stackoverflow.com的論壇尋找後，有相似的問題。&lt;/p&gt;
&lt;p&gt;是物件導向的從屬錯誤，不應該重複稱呼，但是編譯器通常不會抓這種錯誤，解決方法是刪掉前面的父項名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PC43snc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後變成：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;也是成功解決。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先是圖示(icon)的問題。&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者使用另一個語言$Perl$的程式來做出"icons.h"這個檔案。&lt;/p&gt;
&lt;p&gt;Perl是一個高階語言，特點就是除了自己的寫法，還可以安裝大量模組來改變撰寫方式，甚至還繼承許多C語言的標準式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/eXwWp0J.jpg" &gt;&lt;/p&gt;
&lt;p&gt;安裝方式跟Python相同，複製檔案跟設定環境變數就能使用了。&lt;/p&gt;
&lt;p&gt;作者用了"GD"這個模組來導出"icons.h"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y1p6Mck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeans雖然也有Perl的附加元件，但是功能比SciTE還陽春，就沒使用它了。&lt;/p&gt;
&lt;p&gt;Perl的副檔名是pl，專案中有"png2c.pl"和"pngchar2c.pl"，應該就是將PNG檔導入C語言中的意思，Makefile中是要執行"png2c.pl"並產生出"icons.h"和"icons-proto.h"的樣子，不過"icons-proto.h"不會用到。&lt;/p&gt;
&lt;p&gt;在Netbeans中似乎無法呼叫外部程式，會顯示無法找到Perl指令的訊息。&lt;/p&gt;
&lt;p&gt;可是到CMD中執行時又會發生無法回應的情況，接著make就會因為找不到"icons.h"而無法編譯。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在exposed資料的Makefile中，g++的參數中需要導入資料庫"-lslvs"。&lt;/p&gt;
&lt;p&gt;而在上一個步驟中，"libslvs.so"確定已經產生，但是找不到的狀況。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/67n3jzL.jpg" &gt;&lt;/p&gt;
&lt;p&gt;網路上普遍都是需要資料連結和打錯名稱，但是好像沒這種狀況，莫非是"libslvs.so"產生失敗，或是並非"slvs"這個名稱？&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者有特別指名不要使用DLL做副檔名。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次學到了編譯程式重要的一環，雖然make的過程中很煩人，也要一直注意是否出錯，但是最後成功時滿有成就感的。&lt;/p&gt;
&lt;p&gt;有些錯誤當下想不出來，不過換一種想法後就能克服許多障礙，訓練眼光放遠也是一件重要的事情。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230紀錄 - Makefile的建構</title><link href="http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-makefilede-jian-gou.html</id><summary type="html">&lt;p&gt;閱讀GNU-Make相關的知識。&lt;/p&gt;
&lt;p&gt;嘗試了解Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;Makefile簡介 :&lt;/h2&gt;

&lt;p&gt;閱讀資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://mropengate.blogspot.tw/2015/06/makefile-makefile.html" title="mropengate.blogspot.tw"&gt;http://mropengate.blogspot.tw/2015/06/makefile-makefile.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)" title="jeff71321.pixnet.net"&gt;http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU-Make在開發者工具包有著極其重要的地位，最大的好處就是「自動化編譯」。&lt;/p&gt;
&lt;p&gt;相較於要用shell來執行編譯的Script，GNU-Make可以只針對部分內容作測試，相當有自由度。&lt;/p&gt;
&lt;p&gt;make.exe依靠著Makefile的設定來將整個專案按照原作者的設定，編譯成可執行文件或是連結庫。&lt;/p&gt;
&lt;p&gt;也因為如此，只要是願意加入專案協同的工程師，裝好原作者使用的工具，無論使用哪個編譯程式，就能利用一個make命令，從頭到尾將專案編譯好進行測試或除錯。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;注意事項 :&lt;/h2&gt;

&lt;p&gt;GNU-Make在閱讀一份Makefile時有幾個重點。&lt;/p&gt;
&lt;p&gt;首先若直接執行make指令，會尋找當前目錄中叫"Makefile"或"makefile"的文件。若Makefile並非這兩個名稱（亦能自訂附檔名），可以加上"-f"參數指定Makefile的名稱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Makefile中包含了&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;1.&lt;em&gt;顯式規則&lt;/em&gt;：說明如何生成一個或多個文件，有使用工具、依賴文件、使用參數等等。&lt;/p&gt;
&lt;p&gt;2.&lt;em&gt;隱晦規則&lt;/em&gt;：不太瞭解這個功能，大約是利用自動推導原則，可以比較簡略地寫定義，篩選檔案。&lt;/p&gt;
&lt;p&gt;3.&lt;em&gt;變量&lt;/em&gt;：自訂參數的功能，能自由更改位置或目標名稱、使用工具和參數等等。&lt;/p&gt;
&lt;p&gt;4.&lt;em&gt;文件指示&lt;/em&gt;：Makefile之間是可以互相溝通的，也可以透過情況作出判斷。&lt;/p&gt;
&lt;p&gt;5.&lt;em&gt;註解&lt;/em&gt;：Makefile的註解符號是"#"，如果要使用井字符號，必須使用反斜線"#"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/j8IrEeN.jpg" &gt;&lt;/p&gt;
&lt;p&gt;特別注意，在Makefile中，命令項的起始一定要使用Tab縮排，不可使用空白字元。&lt;/p&gt;
&lt;p&gt;一般撰寫程式的編譯器都能檢視空白字元的類型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SciTE&lt;/em&gt;：View -&amp;gt; Whitespace&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qBsEJnx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Netbeams&lt;/em&gt;：View -&amp;gt; Show Non-printable Characters&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/f1srj0r.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在此會發現Tab（→）和空白字元（.）的差異。&lt;/p&gt;
&lt;p&gt;不過某些像是SciTE的編譯器，在按下Tab鍵時，會幫使用者轉換成四個空白字元，甚至會用空白字元補齊縮排，所以使用上需要注意。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xfUR3YE.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Fxn6RF6.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Makefile中的目錄分隔號是斜線"/"，換行閱讀符號是反斜線"\"。&lt;/p&gt;
&lt;p&gt;GNU-Make在執行途中遇到錯誤就會停止並跳出，所以必須要整個Makefile和編譯過程都沒有干擾執行問題，才會編譯完畢。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;主要規則 :&lt;/h2&gt;

&lt;p&gt;語法的結構就是目標文件（未生成）後方加上冒號和空格，接著同一行中必須接上會利用到的檔案名稱（不包含工具和include參數的項目）。&lt;/p&gt;
&lt;p&gt;第二行是寫下如何產生目標文件的命令。&lt;/p&gt;
&lt;p&gt;一個項目中有多個檔案時會用一個空白字元分隔。換行時如果想縮排以便閱讀，必須使用空白字元縮排，不然Tab起始的項目都會視為命令。&lt;/p&gt;
&lt;p&gt;而如果命令不能執行時就會中斷操作。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/R9ZtTgK.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Makefile中的參數定義和大部分的語言雷同。不過為了明顯標示，大部分使用者習慣大寫字母。&lt;/p&gt;
&lt;p&gt;定義項目後，使用"＄( )"符號括住來使用變數。變數可以是目錄位置、命令名稱、參數名稱，亦有如"＄＄(basename ＄＄(notdir ＄＄@))"內定的用法。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/weJOnmA.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;途中用Netbeams作輔助檢查檔案關聯性和編寫文件，並make專案。&lt;/p&gt;
&lt;p&gt;不過用cmd下指令也是可行。只是直接打make會用到MinGW的make，必須先指定MSYS的make。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/283ZkZJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Python-Solvespace中的Makefile編寫有一些小缺漏，是Tab和空白字元的問題，後來改正就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KG4JYdS.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過後來在Netbeams編譯外層"Solvespace"時出現了一些問題：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jkkUFzC.jpg" &gt;&lt;/p&gt;
&lt;p&gt;檢查了一下，似乎中間的檔案"＄(SRFOBJS)"找不到？而"＄(SRFOBJS)"的檔案是從"srf\＄(@B).cpp"和"＄(HEADERS)"產生的。&lt;/p&gt;
&lt;p&gt;其中"srf\＄(@B).cpp"應該就是取下所有\srf資料夾的cpp檔案，配上標頭檔後生成obj檔。途中不知道什麼原因obj檔沒有產生，所以才會無法找到？&lt;/p&gt;
&lt;p&gt;但是只編譯exposed資料夾的Makefile時又有這個問題：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/0Mv3ISG.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網檢查了一下這段的用途是編碼對應，可是語法照常來講應該沒錯才是。&lt;/p&gt;
&lt;p&gt;而且後面對應的檔案導入時都出錯，所以就停止了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KzAVcOg.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Makefile和cmake的CMakelist.txt一樣都是工程師自己要創建的，所以又是一項工程，不過除了一些內定代號，其他都滿好理解的。&lt;/p&gt;
&lt;p&gt;找了一下Python-Solvespace相關的網站，但是內容都好少。不過在Github的說明已經滿詳盡了，只是倉儲內的資料時間有點久遠，所以要花些時間偵錯。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050715.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;研究Python-Solvespace。&lt;/p&gt;


&lt;h2&gt;更新Anaconda3 :&lt;/h2&gt;

&lt;p&gt;從官方網站下載最新的Anaconda 3，配有Python 3.5.2。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.continuum.io/downloads" title="continuum.io"&gt;https://www.continuum.io/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Path指令檢查環境變數。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vvpj0ZV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;確定無誤後放入可攜式環境中，並把原本的Python 3.5移除，將start.bat的環境位置改成Anaconda的資料夾。&lt;/p&gt;
&lt;p&gt;接著再檢查Anaconda程式的運作狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2CfbnMR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;安裝了其他工具，也包含Leo 5.3。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BkhZNCL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;說明 :&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/BBBSnowball/python-solvespace" title="github.com"&gt;Python-Solvespace&lt;/a&gt;是由BBBSnowball所開發的Solvespace函式庫，另外能調用Solid-python來協助運算。&lt;/p&gt;
&lt;p&gt;Python-Solvespace最後一次更新是在2013年，所以使用的是Python 2，SWIG可能也是舊版的。&lt;/p&gt;
&lt;p&gt;而根據協同者們留下的"VbDemo.vb"紀錄，應該是用VC來編譯它的。&lt;/p&gt;
&lt;p&gt;若要使用Solid-python，必須用"git submodule update --init"指令額外下載它，不然只有空資料夾。&lt;/p&gt;
&lt;p&gt;不過目前沒有要使用Solid-python，所以可以不用下載。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cn1yVuk.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照Readme的說明，要用make指令來編譯檔案。&lt;/p&gt;
&lt;p&gt;但是在make的時候出錯了，顯示"missing separator. Stop."的錯誤，查了下面的網站，貌似是make.exe的新版本讀取舊的Makefile的問題，必須改寫他們的Makefile或使用舊版的MSYS。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/" title="crifan.com"&gt;http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而顯示的錯誤如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/P2M54ZE.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;與Whitequark的版本比較 :&lt;/h2&gt;

&lt;p&gt;不過Python-Solvespace有留下來interface的檔案，但是它的檔案結構已經跟Whitequark的版本不一樣了，所以也不能直接讓interface對應新版的檔案來創建。&lt;/p&gt;
&lt;p&gt;好消息是SWIG的interface檔案改變不大，新版仍能使用。只要切換到\exposed資料夾，使用下列指令就能生成"slvs_wrap.cxx"。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -c++ -python -py3 slvs.i
&lt;/pre&gt;

&lt;p&gt;新版有用到cmake來建置檔案，但是Python-Solvespace沒有，所以沒有CMakelist的清單。而CMakelist是要手動編寫的，視規模大小來分配。&lt;/p&gt;
&lt;p&gt;Python-Solvespace似乎是只有原本Solvespace的"src"資料夾部分（不過外面原本就是給編譯器介紹用）。&lt;/p&gt;
&lt;p&gt;並將"exposed"、"extlib"、"win32"等資料夾放了進來，並且將總標頭檔"slvs.h"和DLL的"lib.cpp"加入"exposed"中，讓CDemo成為主幹，調用Solvespace裡的約束函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RJZXL0w.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是"exposed"中除了原本的CDemo，還有一個h++的標頭檔"slvs_python.hpp"、一個"DOC.txt"說明Python要如何呼叫編譯好的函式列表，以及一些Python的小程式。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;test.py :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/inHplBd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;py檔總共有3個，其中一個是使用Solid-python的呼叫工具，其他的"test.py"分別用"2.scad"和"3.scad"命名。&lt;/p&gt;
&lt;p&gt;檢查了一下Python-Solvespace附上的py檔，最後作者做了3個測試，並寫下了一些註解。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FqBe5Ba.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第一個"test.py"，展示了Python要如何取用slvs.dll的函式，長得跟原先的"CDemo.c"十分相似。&lt;/p&gt;
&lt;p&gt;在這裡，可以注意到SWIG轉換後的函式名稱還是一樣，用法也極其相似。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IhJD1yg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第二個"test2.scad.py"匯入了slvs和solid。&lt;/p&gt;
&lt;p&gt;由於Python只要在附近資料中尋找到宣告的項目就可運作，所以不太確定它們的副檔名究竟是DLL還是SO、PYD之類的連結庫或Python程式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cHzJVHz.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第三個"test3.scad.py"明顯使用了"slvs_solid.py"的內容，不過只有稍微閱讀過Solid-python的Readme，所以不太知道它的函式，但是看似比Solvespace更方便。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TmysKJC.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次在Python-Solvespace碰上一些小瓶頸。&lt;/p&gt;
&lt;p&gt;主要是MSYS的Makefile問題，論壇上滿多人討論它在編譯時的障礙，有時連參數前加個空格都會顯示錯誤，無法進行。&lt;/p&gt;
&lt;p&gt;而Python-Solvespace應該是用不到cmake（因為原作者是用VC），如果需要用到Netbeams，就要自行撰寫一份CMakelist，或是在編譯器中捨棄它的功能。&lt;/p&gt;
&lt;p&gt;至於需要Python 2轉Python 3的部分比較少，除非要動用Solid-python的內容。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050714.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;試圖解決SWIG問題&lt;/p&gt;


&lt;h2&gt;撰寫批次檔 :&lt;/h2&gt;

&lt;p&gt;依照&lt;a href="http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html" title="ittc.ku.edu"&gt;http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html&lt;/a&gt;提供的gcc指令，撰寫了3個批次檔來執行。&lt;/p&gt;
&lt;p&gt;第一個命名為interface.bat，用來讓swig生成"_wrap.c"檔，並建立"build"和"dist"兩個資料夾。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set interface_name=example

echo 編譯接口
swig -python -py3 %interface_name%.i
echo 編譯完成
pause

REM MKDIR
echo 正在建立目錄
MKDIR "build"
MKDIR "dist"
echo 目錄已建立
pause
&lt;/pre&gt;

&lt;p&gt;第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。&lt;/p&gt;
&lt;p&gt;原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成".o"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成".pyd"檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example
set module_name=example

echo 正在建立暫存檔
gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include
move %target_name%.o build\%target_name%.o
move %target_name%_wrap.o build\%target_name%_wrap.o
echo 暫存檔建立
pause

echo 正在建立PYD
gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd
echo PYD建立

copy /Y runme.py dist\runme.py

python dist\runme.py

pause
&lt;/pre&gt;

&lt;p&gt;第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example

echo RMDIR...
RMDIR /S /Q .\build
RMDIR /S /Q .\dist

echo DEL...
del /F /S /Q %target_name%_wrap.c
del /F /S /Q %target_name%.py

pause
&lt;/pre&gt;

&lt;p&gt;檔案如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iPB2jDu.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;執行測試 :&lt;/h2&gt;

&lt;p&gt;之前的example.c和example.i內容並沒有更動。&lt;/p&gt;
&lt;p&gt;第一次執行後，發現會出現以下錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/d0FfYoF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oeY2vw4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2HjltE6.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是這個舉動實在是太耗費時間了，所以後來放棄了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pXH2OW2.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4vVIw2v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;估計是這裡有錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4Dhvqym.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過不知道怎麼調整。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。&lt;/p&gt;
&lt;p&gt;另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323230日誌 - 105/07/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050713.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050713.html</id><summary type="html">&lt;p&gt;Python 3.5.2軟體更新&lt;/p&gt;


&lt;h2&gt;軟體更新目標 :&lt;/h2&gt;

&lt;p&gt;之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。&lt;/p&gt;
&lt;p&gt;以W:為主，Y:用來撰寫網誌暫不需要更新。&lt;/p&gt;
&lt;p&gt;1.Python 3.5及之前安裝的套件。&lt;/p&gt;
&lt;p&gt;2.Leo 5.3正式版。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Python及套件更新步驟 :&lt;/h2&gt;

&lt;p&gt;將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。&lt;/p&gt;
&lt;p&gt;Python 3.5.2下載處：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/downloads/" title="python.org"&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xgAInox.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip freeze &gt; rq.txt
&lt;/pre&gt;

&lt;p&gt;清單中列的就是Python 3.4安裝的套件版本。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pUMf021.jpg" &gt;&lt;/p&gt;
&lt;p&gt;進入Python 3.5後使用pip指令時出現類似"Fatal error in launcher"的訊息，原因是官方的pip版本較舊。&lt;/p&gt;
&lt;p&gt;如果不更新，只能用"python -m pip"的方式驅動它，所以先命令它為自己升級。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python -m pip install pip --upgrade
&lt;/pre&gt;

&lt;p&gt;然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PN2P60t.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著利用下列指令更新：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip install -r rq.txt
&lt;/pre&gt;

&lt;p&gt;就會裝回所有的套件了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RuXhQhT.jpg" &gt;&lt;/p&gt;
&lt;p&gt;使用下列指令可以查看已安裝的套件。&lt;/p&gt;
&lt;p&gt;而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//已安裝套件
pip freeze
//過期套件
pip list --outdated
&lt;/pre&gt;

&lt;hr&gt;

&lt;h2&gt;Leo更新步驟 :&lt;/h2&gt;

&lt;p&gt;至於安裝Leo，到&lt;a href="http://sourceforge.net/projects/leo/files/Leo/" title="sourceforge.net"&gt;http://sourceforge.net/projects/leo/files/Leo/&lt;/a&gt;下載5.3的安裝檔，並暫時解壓縮到根目錄。&lt;/p&gt;
&lt;p&gt;接著進入\Leo-5.3-final\leo\dist資料夾，執行下面指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python setup.py install
&lt;/pre&gt;

&lt;p&gt;安裝完後，接著就能把解壓縮的檔案刪除了。&lt;/p&gt;
&lt;p&gt;不過在pip的紀錄中還是5.0 Bata2的樣子。&lt;/p&gt;
&lt;p&gt;新版的Leo介面（設定檔複製之前的）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DZGSNFn.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;上次的swig還是沒成功，"_wrap.c"中似乎還要加一些python3的判斷式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python3porting.com/cextensions.html#module-initialization" title="python3porting.com"&gt;http://python3porting.com/cextensions.html#module-initialization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050712.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050712.html</id><summary type="html">&lt;p&gt;瞭解SWIG的用法。&lt;/p&gt;


&lt;h2&gt;軟體修正 :&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;NetBeans&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;為NetBeans安裝python的附加元件，使其可以編譯python文件。&lt;/p&gt;
&lt;p&gt;這些附加元件還包含了jython2.7.0。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M1eGLck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SWIG&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/swig/files/swigwin/" title="sourceforge.net"&gt;https://sourceforge.net/projects/swig/files/swigwin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K2UBCMh.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著就能用它下參數了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Enjvaxe.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;SWIG簡介 :&lt;/h2&gt;

&lt;p&gt;SWIG的功能就是利用自己的Interface檔案".i"，產生出一個"_wrap.c"檔，如果DLL專案一起將這個".c"編譯的話，就可以讓其他高階語言呼叫了。&lt;/p&gt;
&lt;p&gt;SWIG內有個\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。&lt;/p&gt;
&lt;p&gt;諸如：D語言、java、javascript、lua、php、python、ruby。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yrDg75c.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;練習應用 :&lt;/h2&gt;

&lt;p&gt;參考範例：&lt;/p&gt;
&lt;p&gt;/Examples/python/simple/index.html&lt;/p&gt;
&lt;p&gt;&lt;img src="" &gt;&lt;/p&gt;
&lt;p&gt;先寫一個".c"程式碼。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File : example.c */

/* A global variable */
double Foo = 3.0;

/* Compute the greatest common divisor of positive integers */
int gcd(int x, int y) {
  int g;
  g = y;
  while (x &gt; 0) {
    g = x;
    x = y % x;
    y = g;
  }
  return g;
}
&lt;/pre&gt;

&lt;p&gt;然後再寫一個Interface的".i"文件。&lt;/p&gt;
&lt;p&gt;至於格式可能要參考手冊的其他內容。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File: example.i */
%module example

extern int gcd(int x, int y);
extern double Foo;
&lt;/pre&gt;

&lt;p&gt;然後用cmd到/Examples/python/simple中下指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -python example.i
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/Enjvaxe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。&lt;/p&gt;
&lt;p&gt;但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aGmZKry.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG的操作大致知道了，但是仍有些許不瞭解的地方。&lt;/p&gt;
&lt;p&gt;像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現".i"文件格式錯誤的訊息。&lt;/p&gt;
&lt;p&gt;而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。&lt;/p&gt;
&lt;p&gt;另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。&lt;/p&gt;</summary><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323230練習 - 105/07/11</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050711.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230lian-xi-1050711.html</id><summary type="html">&lt;p&gt;使用2015cp範本練習".py"呼叫".pyd"。&lt;/p&gt;


&lt;h2&gt;編譯出Python的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/coursemdetw/2015cp" title="coursemdetw/2015cp"&gt;https://github.com/coursemdetw/2015cp&lt;/a&gt;下載老師的範本練習。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vifdEXt.jpg" &gt;&lt;/p&gt;
&lt;p&gt;C程式的部分分成pymod和pyfun。&lt;/p&gt;
&lt;p&gt;這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kanLiEj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;button裡的內容如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("Z:/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o V:/IDE/Python33/libs/libpython33.a")
g.es("done")
&lt;/pre&gt;

&lt;p&gt;在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("gcc -c -g -IW:/Python34/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("gcc -shared -o dist/"+module_name+".pyd build/"+target_name+".o W:/Python34/libs/python34.lib")
g.es("pymod done")
&lt;/pre&gt;

&lt;p&gt;而另一邊的pyfun同理。&lt;/p&gt;
&lt;p&gt;接著就能在\dist資料夾中編譯出sum.pyd和pyfun.pyd了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CF0b3Ff.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;使用mypy.py :&lt;/h2&gt;

&lt;p&gt;接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。&lt;/p&gt;
&lt;p&gt;mypy.py中導入sum，並使用它裡面的函式sum()。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(sum.sum(1, 30))
&lt;/pre&gt;

&lt;p&gt;在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 定義內部運算的函式內容
int sum2(int a, int b)
{
    return a+b;
}

// sum 函式的 interface
static PyObject* mod_sum(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int s;
    // ii 表示兩個輸入變數都是整數
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係
    s = sum2(a,b);
    // i 表示 s 為整數
    return Py_BuildValue("i",s);
}

// 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function)
// Mod_Methods 為函式 (方法) 結構定義
static struct PyMethodDef Mod_Methods[] = {
    {"sum", mod_sum, METH_VARARGS, "Description.."},
    {NULL,NULL,0,NULL}
};
&lt;/pre&gt;

&lt;p&gt;sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/00d1W9j.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。&lt;/p&gt;
&lt;p&gt;這次是加入一段字串。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(pyfun.pyfun("我的字串"))
&lt;/pre&gt;

&lt;p&gt;在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pyfun(PyObject *self,PyObject *args)
{
    const char *to_who;
    if(!PyArg_ParseTuple(args,"s",&amp;to_who))
        return NULL;
     // pyfun 函式會將輸入字串變數傳回
    return PyUnicode_FromString(to_who);
}
&lt;/pre&gt;

&lt;p&gt;執行後的結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FhNTo1L.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這兩個pyd的結尾不太一樣。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sum.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 模組啟始, PyInit_ 後必須使用"名稱".pyd 中的模組名稱, 以便啟動
// 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum
PyMODINIT_FUNC
PyInit_sum(void)
{
    // 建立模組的起始, 輸入為模組結構名稱之 address
    (void) PyModule_Create(&amp;ModMethods);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;pyfun.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同
PyInit_pyfun(void)
{
    PyObject *m;
    m = PyModule_Create(&amp;moduledef);
    return m;
}
&lt;/pre&gt;

&lt;p&gt;意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。&lt;/p&gt;
&lt;p&gt;若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;延伸應用 :&lt;/h2&gt;

&lt;p&gt;只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。&lt;/p&gt;
&lt;p&gt;在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DYEFA1M.jpg" &gt;&lt;/p&gt;
&lt;p&gt;添加了下列指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//導入
#include "math.h"
//宣告
int sum3(int a, int b);
//副程式sum3
int sum3(int a, int b)
{
    return sqrt(a+b)*10;
}
//定義輸入值和sum3的外部名稱score
static PyObject* mod_score(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int t;
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    t = sum3(a,b);
    return Py_BuildValue("i",t);
}
&lt;/pre&gt;

&lt;p&gt;並在PyMethodDef Mod_Methods[]中再新增一串：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
{"score", mod_score, METH_VARARGS, "Description.."},
&lt;/pre&gt;

&lt;p&gt;接著在mypy.py中呼叫sum.score()就行了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。&lt;/p&gt;
&lt;p&gt;這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？&lt;/p&gt;
&lt;p&gt;不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。&lt;/p&gt;</summary><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230練習 - 105/07/10</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050710.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230lian-xi-1050710.html</id><summary type="html">&lt;p&gt;由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。&lt;/p&gt;


&lt;h2&gt;編譯出C的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;找到了一個別人學校的DLL簡單範例。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/" title="niu.edu.tw"&gt;http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。&lt;/p&gt;
&lt;p&gt;使用NetBeans建立了一個C/C++ Dynamic Library。&lt;/p&gt;
&lt;p&gt;若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vLbLF1a.jpg" &gt;&lt;/p&gt;
&lt;p&gt;新建完成後，Projects的欄位就會幫使用者分類：&lt;/p&gt;
&lt;p&gt;Header Files, Resource Files, Source Files, Test Files.&lt;/p&gt;
&lt;p&gt;這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。&lt;/p&gt;
&lt;p&gt;如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇"Add Existing Item..."，再選擇想加入的檔案就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K1LuZ3T.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照範例先在SciTE中寫好了三個檔案。&lt;/p&gt;
&lt;p&gt;編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/acz9z6v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*str, int a, int b)
{
    printf("This is your ID(8):\n");
    printf("Your ID: %s\n", str);
    printf("%d+%d=%d:\n", a, b, a+b);
    return "OK";
}
&lt;/pre&gt;

&lt;p&gt;標頭檔中也有這一段匯入，供可執行檔呼叫。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*, int, int);
&lt;/pre&gt;

&lt;p&gt;這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。&lt;/p&gt;
&lt;p&gt;在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/B5driZY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時候會顯示成功，並在\dist\Debug\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L3U9skL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯出C的可執行檔 :&lt;/h2&gt;

&lt;p&gt;這時再把call DLL.c加入Source File中。&lt;/p&gt;
&lt;p&gt;call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。&lt;/p&gt;
&lt;p&gt;call DLL.c的主程式如下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
int main(void)
{
    int i1, i2;
    char str1[9];
    printf("Key in:\n");
    scanf("%s,%d,%d", &amp;str1, i1, i2);
    printf("\n");

    HMODULE hInst=LoadLibrary("DLLtest.dll");
    if(hInst==NULL){
        printf("Can't load library.\n");
        system("PAUSE");
        return 1;
    }
    char* (*CallDll)(char*, int, int);
    (FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
    if(CallDll==NULL){
        printf("NO Value.\n");
        system("PAUSE");
        return 2;
    }
    printf("Result: %s\n", CallDll(str1, i1,i2));
    FreeLibrary(hInst);
    system("PAUSE");
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;然而在編譯時，NetBeans卻顯示了下列訊息：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/JjwIcXD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;顯示是在這段出了問題：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
(FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
&lt;/pre&gt;

&lt;p&gt;這裡的問題是定義項和被定義項的關係錯誤。&lt;/p&gt;
&lt;p&gt;上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。&lt;/p&gt;
&lt;p&gt;由於是內建函式，所以不太了解其格式甚麼的。&lt;/p&gt;
&lt;p&gt;於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg);
&lt;/pre&gt;

&lt;p&gt;完全不用呼叫dll名稱什麼的。&lt;/p&gt;
&lt;p&gt;因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的"Slvs_"指派計算。&lt;/p&gt;
&lt;p&gt;編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。&lt;/p&gt;
&lt;p&gt;至於工程師規定的格式在slvs.h的註解中有所說明。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。&lt;/p&gt;
&lt;p&gt;下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230練習 - 105/07/09</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050709.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230lian-xi-1050709.html</id><summary type="html">&lt;p&gt;嘗試用C語言解題&lt;/p&gt;


&lt;h2&gt;BUG fix :&lt;/h2&gt;

&lt;p&gt;W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nXiTYLx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;只要修改cpp.properties的路徑就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zjc51Kz.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Nutcracker Solution :&lt;/h2&gt;

&lt;p&gt;上學期的&lt;a href="http://chiamingyen.github.io/kmolab/blog/2015-fall-cadp-w16.html" title="github.io"&gt;Nutcracker網誌內容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Tfik6jG.jpg" &gt;&lt;/p&gt;
&lt;p&gt;之前的python題目，稍微研究一下後轉成C語言。&lt;/p&gt;
&lt;p&gt;不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RwJbKM9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;先做了兩個程式，不過第一是介面而已，第二個才是主要架構。&lt;/p&gt;
&lt;p&gt;撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。&lt;/p&gt;
&lt;p&gt;有時候會偷吃步測試一些解法。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PDHq9QA.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。&lt;/p&gt;
&lt;p&gt;演算法概念：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iOuX4ks.jpg" &gt;&lt;/p&gt;
&lt;p&gt;途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int k=40;
int h=10;
int a=40;
int b=80;
double r=10;
double pi=M_PI;
int num=1000;

int main()
{
    double deg =pi/180;
    for (int j=45*num; j&lt;=180*num; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        printf("%g\n", (int)(j/num0*100000+.5)/100000.);
        if(r1&lt;=r){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            break;
        }
    }
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;第二支程式的最後成果。&lt;/p&gt;
&lt;p&gt;最後精確度還是沒有很高，不知道問題出在哪裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jbtn7X1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。&lt;/p&gt;
&lt;p&gt;後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int a, b, k, h, r, lim;
double o, wp, thmin, thmax;
double pi=M_PI;
int num=1000;

double solve_minpath(int, int, int, int, int);
double solve_maxangle(int, int, int, int, int);
double solve_maxpath(int, int, int, int);
double solve_minangle(int, int, int, int);

int main()
{
    scanf("%d,%d,%d,%d,%d,%d", &amp;a, &amp;b, &amp;k, &amp;h, &amp;r, &amp;lim);
//強制正值
    a=abs(a);
    b=abs(b);
    h=abs(h);
    k=abs(k);
    r=abs(r);
    lim=abs(lim);
    printf("\n---\n");
    printf("Used pi= %f\n", pi);
    printf("---\n");
    printf("Connecting Rod:\n");
    printf("a= %d b= %d\n", a, b);
    printf("Rod radius= %d\n", r);
    printf("Rod width= %d\n", r*2);
    printf("Space Usage:\n");
    printf("h= %d k= %d\n", h, k);
    printf("Work Path= %d\n", lim);
    printf("---\n\n");
//相關參數代入副程式解題
    o=solve_minpath(k, h, a, b, r);
    wp=solve_maxpath(lim, a, b, r)-o;
    thmin=solve_minangle(lim, a, b, r);
    thmax=solve_maxangle(k, h, a, b, r);
    if(a*b*lim==0){
        printf("---ERRO---\nSome value can't be zero.\n");
        return 1;
    }
    else{
        if(o+r&gt;lim){
            printf("---ERRO---\nSpace is not enough.\n");
            return 2;
        }
        else{
            printf("\n---\n---Result---\n");
            printf("Distance:\n");
            printf("Offset distance:\n");
            printf("o= %f\n", o);
            printf("Work distance:\n");
            printf("wp= %f\n", wp);
            printf("Angle(Degree):\n");
            printf("min= %f max= %f\n---\n", thmin, thmax);
            return 0;
        }
    }
}

double solve_minpath(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return x2;
            break;
        }
    }
    return 0;
}

double solve_maxangle(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return th/deg;
            break;
        }
    }
    return 0;
}

double solve_maxpath(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/2*a*n);
    }
    return n;
}

double solve_minangle(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/(2*a*n));
    }
    return th;
}

&lt;/pre&gt;

&lt;p&gt;最後執行的結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/S6oj3vJ.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。&lt;/p&gt;
&lt;p&gt;後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄 - 瞭解SWIG &amp; CDemo的資源</title><link href="http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html</id><summary type="html">&lt;p&gt;安裝SWIG&lt;/p&gt;
&lt;p&gt;並檢視下列檔案：&lt;/p&gt;
&lt;p&gt;CDemo.exe&lt;/p&gt;
&lt;p&gt;CDemo.c&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;除了英文的資料，另外還讀了一下關於SWIG的相關中文資料：&lt;/p&gt;
&lt;p&gt;1.Python的資料庫形式&lt;/p&gt;
&lt;p&gt;&lt;a href="https://read01.com/PnGeDg.html" title="read01.com"&gt;https://read01.com/PnGeDg.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.Python在Windows中用SWIG呼叫C/C++的函式（VC）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html" title="falldog7.blogspot.tw"&gt;http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.SWIG概念&lt;/p&gt;
&lt;p&gt;&lt;a href="http://user.frdm.info/ckhung/b/mi/swig.php" title="user.frdm.info"&gt;http://user.frdm.info/ckhung/b/mi/swig.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著從&lt;a href="http://www.swig.org/download.html" title="swig.org"&gt;swig.org&lt;/a&gt;下載最新版的SWIG 3.0.10，將壓縮包解至W:內。&lt;/p&gt;
&lt;p&gt;SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的".tar.gz"。&lt;/p&gt;
&lt;p&gt;解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/G3moEiW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;如果該步驟需要完整的流程，\Doc\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。&lt;/p&gt;
&lt;p&gt;在閱讀\Doc\Manual\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。&lt;/p&gt;
&lt;p&gt;只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VHvu5ps.jpg" &gt;&lt;/p&gt;
&lt;p&gt;手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vaa3Shm.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.exe :&lt;/h2&gt;

&lt;p&gt;CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。&lt;/p&gt;
&lt;p&gt;在原本的\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。&lt;/p&gt;
&lt;p&gt;為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7y0nwjC.jpg" &gt;&lt;/p&gt;
&lt;p&gt;由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。&lt;/p&gt;
&lt;p&gt;顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hzotTGs.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.c :&lt;/h2&gt;

&lt;p&gt;由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。&lt;/p&gt;
&lt;p&gt;用SciTE開啟CDemo.c，可以發現CDemo的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6IlMv1k.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而為了方便，將它部分的原始碼貼在下面：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/*-----------------------------------------------------------------------------
 * Some sample code for slvs.dll. We draw some geometric entities, provide
 * initial guesses for their positions, and then constrain them. The solver
 * calculates their new positions, in order to satisfy the constraints.
 *
 * Copyright 2008-2013 Jonathan Westhues.
 *---------------------------------------------------------------------------*/
#ifdef HAVE_CONFIG_H
...
#endif
#ifdef WIN32
...
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_STDINT_H
...
#endif

#include &lt;slvs.h&gt;

static Slvs_System sys;

static void *CheckMalloc(size_t n)
{
    void *r = malloc(n);
    if(!r) {
        printf("out of memory!\n");
        exit(-1);
    }
    return r;
}

/*-----------------------------------------------------------------------------
 * An example of a constraint in 3d. We create a single group, with some
 * entities and constraints.
 *---------------------------------------------------------------------------*/
void Example3d()
{
...
}

/*-----------------------------------------------------------------------------
 * An example of a constraint in 2d. In our first group, we create a workplane
 * along the reference frame's xy plane. In a second group, we create some
 * entities in that group and dimension them.
 *---------------------------------------------------------------------------*/
void Example2d()
{
...
}

int main()
{
    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));
    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));
    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));

    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));
    sys.faileds = 50;

    /*Example3d();*/
    for(;;) {
        Example2d();
        sys.params = sys.constraints = sys.entities = 0;
        break;
    }
    return 0;
}

&lt;/pre&gt;

&lt;p&gt;在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。&lt;/p&gt;
&lt;p&gt;所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
void Example2d()
{
    Slvs_hGroup g;
    double qw, qx, qy, qz;

    g = 1;
    /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
    Slvs_MakeQuaternion(1, 0, 0,
                        0, 1, 0, &amp;qw, &amp;qx, &amp;qy, &amp;qz);
    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

    /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
    g = 2;
    /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */
    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);

    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);

    /* And we create a line segment with those endpoints. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,
                                        200, 301, 302);

    /* Now three more points. */
    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);
    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);

    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);
    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);

    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);
    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);

    /* And arc, centered at point 303, starting at point 304, ending at
     * point 305. */
    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,
                                    303, 304, 305);

    /* Now one more point, and a distance */
    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);
    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);

    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);
    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);

    /* And a complete circle, centered at point 306 with radius equal to
     * distance 307. The normal is 102, the same as our workplane. */
    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,
                                    306, 102, 307);


    /* The length of our line segment is 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            30.0,
                                            301, 302, 0, 0);

    /* And the distance from our line segment to the origin is 10.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            2, g,
                                            SLVS_C_PT_LINE_DISTANCE,
                                            200,
                                            10.0,
                                            101, 0, 400, 0);
    /* And the line segment is vertical. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            3, g,
                                            SLVS_C_VERTICAL,
                                            200,
                                            0.0,
                                            0, 0, 400, 0);
    /* And the distance from one endpoint to the origin is 15.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            4, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            15.0,
                                            301, 101, 0, 0);
#if 0
    /* And same for the other endpoint; so if you add this constraint then
     * the sketch is overconstrained and will signal an error. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            5, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            18.0,
                                            302, 101, 0, 0);
#endif /* 0 */

    /* The arc and the circle have equal radius. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            6, g,
                                            SLVS_C_EQUAL_RADIUS,
                                            200,
                                            0.0,
                                            0, 0, 401, 402);
    /* The arc has radius 17.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            7, g,
                                            SLVS_C_DIAMETER,
                                            200,
                                            17.0*2,
                                            0, 0, 401, 0);

    /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
    sys.calculateFaileds = 1;

    /* And solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("solved okay\n");
        printf("line from (%.3f %.3f) to (%.3f %.3f)\n",
                sys.param[7].val, sys.param[8].val,
                sys.param[9].val, sys.param[10].val);

        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\n",
                sys.param[11].val, sys.param[12].val,
                sys.param[13].val, sys.param[14].val,
                sys.param[15].val, sys.param[16].val);

        printf("circle center (%.3f %.3f) radius %.3f\n",
                sys.param[17].val, sys.param[18].val,
                sys.param[19].val);
        printf("%d DOF\n", sys.dof);
    } else {
        int i;
        printf("solve failed: problematic constraints are:");
        for(i = 0; i &lt; sys.faileds; i++) {
            printf(" %d", sys.failed[i]);
        }
        printf("\n");
        if(sys.result == SLVS_RESULT_INCONSISTENT) {
            printf("system inconsistent\n");
        } else {
            printf("system nonconvergent\n");
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;"Slvs_hGroup g"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。&lt;/p&gt;
&lt;p&gt;之後便能用"sys.param[sys.params++]"或是"sys.entity[sys.entities++]"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。&lt;/p&gt;
&lt;p&gt;比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。&lt;/p&gt;
&lt;p&gt;畫完圖之後，最後解決的程式是使用Slvs_Solve(&amp;amp;sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。&lt;/p&gt;
&lt;p&gt;不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。&lt;/p&gt;
&lt;p&gt;雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="SWIG"></category></entry><entry><title>40323230紀錄 - 編譯Solvespace流程</title><link href="http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html</id><summary type="html">&lt;p&gt;由原始碼編譯出Solvespace和CDemo的執行檔&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。&lt;/p&gt;
&lt;p&gt;連結為下載處。&lt;/p&gt;
&lt;p&gt;1.MinGW (Not official version), &lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;https://nuwen.net/mingw.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.msys (Official version), &lt;a href="http://www.mingw.org/wiki/msys" title="mingw.org"&gt;http://www.mingw.org/wiki/msys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.CMake  (Official version), &lt;a href="https://cmake.org/download/" title="cmake.org"&gt;https://cmake.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.NetBeans (Our storage), &lt;a href="http://140.130.17.17/public/Netbeans/" title="140.130.17.17/public/"&gt;http://140.130.17.17/public/Netbeans/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存放位置除了CMake之外皆為W:內，CMake存於W:\app資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kHQFc1g.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;下載Solvespace原始碼 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;git clone最新的原始碼到W:\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KUJCPoJ.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從\NetBeans\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/m7uH7TA.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/D6TKKRZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rame7tV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;若有必要可以為NetBeans安裝CMake的附加元件。&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6mi2Lz1.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;執行Build :&lt;/h2&gt;

&lt;p&gt;接著按下New Project...新增專案。&lt;/p&gt;
&lt;p&gt;選擇Project with Existing Sources繼續。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TxisGUv.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後選擇Whitequark的Solvespace原始碼目錄。&lt;/p&gt;
&lt;p&gt;並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Gzqb7so.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DF15llN.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時開啟專案內的\src\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。&lt;/p&gt;
&lt;p&gt;註：如果不是填在最後一項會有讀取順序錯誤的問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rAC4a2W.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\src和\exposed資料夾下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/0CEdXhu.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - Solvespace</title><link href="http://project.mde.tw/blog/40323230ji-lu-solvespace.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-solvespace.html</id><summary type="html">&lt;p&gt;找到的Solvespace原始碼版本&lt;/p&gt;


&lt;h2&gt;目前可攜式環境內存放的Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;超連結為下載處。&lt;/h3&gt;

&lt;p&gt;1.&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;：非官方人員開發的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dcchKn7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace 2.0&lt;/a&gt;：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/HBZ0DM4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="https://github.com/solvespace/solvespace/releases/tag/v2.1" title="github.com"&gt;Solvespace 2.1&lt;/a&gt;：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和&lt;a href="https://github.com/solvespace/libdxfrw" title="github.com"&gt;solvespace/libdxfrw&lt;/a&gt;有關聯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Zqu4j7i.jpg" &gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href="https://github.com/solvespace/solvespace/tree/2.x" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/UYXGcF7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;相關連結：版本差異紀錄-&lt;a href="https://github.com/solvespace/solvespace/blob/2.x/CHANGELOG.md" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ZGLaQ0j.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WkmsWPq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;點開記錄錯誤的視窗：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/52VlrUJ.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050705.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索-2&lt;/p&gt;
&lt;p&gt;註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。&lt;/p&gt;


&lt;p&gt;目前NetBeans的&lt;a href="https://netbeans.org/kb/docs/intro-screencasts.html?utm_source=netbeans&amp;amp;utm_campaign=welcomepage" title="netbeans.org"&gt;官方網站&lt;/a&gt;並沒有很詳盡的介紹，只有放一些改版的導覽影片。&lt;/p&gt;
&lt;p&gt;基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。&lt;/p&gt;
&lt;h2&gt;NetBeans啟動 :&lt;/h2&gt;

&lt;p&gt;每次啟動可攜式環境，NetBeans portable都會保留之前的設定。&lt;/p&gt;
&lt;p&gt;只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。&lt;/p&gt;
&lt;p&gt;另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。&lt;/p&gt;
&lt;p&gt;不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。&lt;/p&gt;
&lt;p&gt;設定start.bat在啟動後自動打開NetBeans。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VyTHn6F.jpg" &gt;&lt;/p&gt;
&lt;p&gt;NetBeans在啟動時載入專案的提示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/g2hnriA.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans介面 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/dpboPO9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;跟大部分的文字編譯軟體差不多的介面。&lt;/p&gt;
&lt;p&gt;在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。&lt;/p&gt;
&lt;p&gt;行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。&lt;/p&gt;
&lt;p&gt;捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。&lt;/p&gt;
&lt;p&gt;NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dHiNW4x.jpg" &gt;&lt;/p&gt;
&lt;p&gt;主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。&lt;/p&gt;
&lt;p&gt;另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。&lt;/p&gt;
&lt;p&gt;上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y94zmYv.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。&lt;/p&gt;
&lt;p&gt;以下是File的檔案目錄和檔案總管顯示的比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ekWZDfJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ORqMv0Q.jpg" &gt;&lt;/p&gt;
&lt;p&gt;服務頁籤中會顯示一些工具，不過不知道怎麼使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qMeIdGo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。&lt;/p&gt;
&lt;p&gt;在物件上點擊兩下會移到該物件所在的檔案位置。&lt;/p&gt;
&lt;p&gt;在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rTjJ0jx.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XBywmpk.jpg" &gt;&lt;/p&gt;
&lt;p&gt;工具列的功能說明：&lt;/p&gt;
&lt;p&gt;1：Source-切換至編輯原始碼模式。&lt;/p&gt;
&lt;p&gt;2：History-切換至編輯記錄模式。&lt;/p&gt;
&lt;p&gt;3：Last Edit-回到上次編輯（插入／刪除）過的位置。&lt;/p&gt;
&lt;p&gt;4：Go back to-上一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;5：Forward-下一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;6：Find Selection-在本檔案搜尋框選的文字。&lt;/p&gt;
&lt;p&gt;7：Find Previous Occurrence-尋找前一個關鍵字。&lt;/p&gt;
&lt;p&gt;8：Find Next Occurrence-尋找後一個關鍵字。&lt;/p&gt;
&lt;p&gt;9：Toggle Highlight Search-切換高亮度標示。&lt;/p&gt;
&lt;p&gt;10：Toggle Rectangular Selection-切換矩形框選模式。&lt;/p&gt;
&lt;p&gt;11：Previous Bookmark-前一個書籤。&lt;/p&gt;
&lt;p&gt;12：Next Bookmark-下一個書籤。&lt;/p&gt;
&lt;p&gt;13：Toggle Bookmark-切換書籤。&lt;/p&gt;
&lt;p&gt;14：Shift Line Left-往左縮排。&lt;/p&gt;
&lt;p&gt;15：Shift Line Right-往右縮排。&lt;/p&gt;
&lt;p&gt;16：Start Macro Recording-開始巨集（腳本）錄製。&lt;/p&gt;
&lt;p&gt;17：Stop Macro Recording-停止巨集錄製。&lt;/p&gt;
&lt;p&gt;18：Comment-註解。&lt;/p&gt;
&lt;p&gt;19：UNcomment-刪掉註解。&lt;/p&gt;
&lt;p&gt;20：Go to Header/Source-開啟源頭檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。&lt;/p&gt;
&lt;p&gt;以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;改用CMD設定CMake&lt;/p&gt;


&lt;h2&gt;CMD命令cmake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的Command-line build&lt;/h3&gt;

&lt;p&gt;使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/F6tBRr1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2h18M7K.jpg" &gt;&lt;/p&gt;
&lt;p&gt;到CMD中下Readme中提供的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpzsMMZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下nmake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SMlMAQc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是在最後出現一些錯誤，不知道原因為何。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CZ2wMoU.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。&lt;/p&gt;
&lt;p&gt;如果要改用NetBeans，就不用下nmake的指令。&lt;/p&gt;
&lt;hr&gt;

&lt;h3&gt;Readme的MSVC build&lt;/h3&gt;

&lt;p&gt;這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/8D6cRvV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著同樣按照Readme的說明用CMD下指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iXmV4cR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過後面的make指令會說無法讀取makefile檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/04-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050704-2.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索&lt;/p&gt;


&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;MinGW Distro - nuwen.net&lt;/a&gt;下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。&lt;/p&gt;
&lt;p&gt;下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。&lt;/p&gt;
&lt;p&gt;這個MinGW裡還配有一個比較簡單的git工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QusRHMc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。&lt;/p&gt;
&lt;p&gt;先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。&lt;/p&gt;
&lt;p&gt;設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/aY6AzV5.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;NetBeans專案 :&lt;/h2&gt;

&lt;p&gt;之後新建專案，選擇C語言已有源代碼的專案。&lt;/p&gt;
&lt;p&gt;選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MOdwa0P.jpg" &gt;&lt;/p&gt;
&lt;p&gt;基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/f4sSsvQ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接下來是清理和建置指令，就和打在CMD視窗裡的一樣。&lt;/p&gt;
&lt;p&gt;幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/HrGJNnU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。&lt;/p&gt;
&lt;p&gt;下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。&lt;/p&gt;
&lt;p&gt;左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。&lt;/p&gt;
&lt;p&gt;左下的導航欄似乎能執行CMake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mFKn2Pc.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。&lt;/p&gt;
&lt;p&gt;雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050703.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;


&lt;h2&gt;編譯 Solvespace 前的準備 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="http://www.activestate.com/activeperl/downloads" title="activestate.com"&gt;Active State&lt;/a&gt;下載了 ActivePerl，使用的是5.24.0／x64版。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="visualstudio.com"&gt;Microsoft&lt;/a&gt;下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;GitHub&lt;/a&gt;下載Solvespace的原始碼，另外在&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace&lt;/a&gt;提供下載的頁面中也有一個較舊版的原始碼。&lt;/p&gt;
&lt;p&gt;裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/we7AKIF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;用CMD從安裝目錄的\VC\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iCFeYAe.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;關於NMAKE的使用方法，找了幾個中國的網站介紹：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://www.cnblogs.com/kekec/archive/2013/04/21/3007277.html" title="cnblogs.com"&gt;NMAKE的指令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.csdn.net/cneaglelee/article/details/11714803" title="csdn.net"&gt;NMAKE的開發環境設置&lt;/a&gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ri-zhi-1050703-2.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace(更新)&lt;/p&gt;


&lt;h2&gt;使用CMake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的GUI build&lt;/h3&gt;

&lt;p&gt;下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。&lt;/p&gt;
&lt;p&gt;在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。&lt;/p&gt;
&lt;p&gt;CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nk3qTV4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。&lt;/p&gt;
&lt;p&gt;要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。&lt;/p&gt;
&lt;p&gt;Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。&lt;/p&gt;
&lt;p&gt;雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。&lt;/p&gt;
&lt;p&gt;Configure的部分嘗試選擇MinGW的選項。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/5br2VyW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OljnPa7.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;暫時用Visual Studio的設定，但是結果似乎不理想。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TSfLb5n.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.youtube.com/watch?v=gYmgbqGfv-8" title="youtube.com"&gt;教學影片-Visual Studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.youtube.com/watch?v=2A-iRgOhL8A" title="youtube.com"&gt;教學影片-Mingw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄</title><link href="http://project.mde.tw/blog/40323230ji-lu.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu.html</id><summary type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;


&lt;h2&gt;V-REP Example Learning Reviews&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;嘗試用英文說明&lt;/h4&gt;
&lt;/br&gt;
&lt;h2&gt;Notes :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;The "Scene hierarchy" panel can show whole of outward and entity in a tree.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy" title="coppeliarobotics.com"&gt;Scene hierarchy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/cqIHtFn.jpg" &gt;
&lt;/br&gt;
&lt;h3&gt;In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Any parts can insert a script to control them.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;"Dummy" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummies.htm" title="coppeliarobotics.com"&gt;Dummy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/caU2SLx.jpg" &gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;目前整理完幾何部件的檔案。存於\users\g2_files\VREP_Simulation.ttt中。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNvEHRc.jpg" &gt;&lt;/p&gt;</summary><category term="Kmol"></category><category term="V-rep"></category></entry><entry><title>40323218日誌 - 105/07/23</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050723.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050723.html</id><summary type="html">&lt;p&gt;V-rep   printer_control&lt;/p&gt;


&lt;h2&gt;嘗試組裝3Dprinter&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;現在已嘗試兩種方式操控&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;分別是：&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_position_control.ttt?raw=true"&gt;Printer_position_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控position(需用滑鼠移動)&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/position.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_motor_control.ttt?raw=true"&gt;Printer_motor_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控motor(需用參數移動)&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/motor.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;
&lt;h3&gt;串列通訊：&lt;/h3&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/1-CW00QXwwk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/y1vbxmeJ4M0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323218日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050719.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;V-rep 翻譯 Inverse kinematics&lt;/p&gt;


&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK1.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Inverse kinematics enabled:   啟用或禁用所有IK計算。&lt;br&gt;
&lt;br&gt;&lt;br&gt;
•  Add new IK group: &lt;br&gt;&lt;br&gt;新增一個空的 IK group. IK groups 可以包含一個或多個 IK elements.&lt;br&gt;&lt;br&gt; IK elements 是基本運動學綁著IK任務, IK groups可以組合他們來同時運行.&lt;br&gt;&lt;br&gt; 當需要時只使用同時運行(比依序運算花較長的計算時間).&lt;br&gt;&lt;br&gt; 一個IK element 總必須被一個IK group連結，而且不能單獨存在. &lt;br&gt;&lt;br&gt;在按鈕下方的列表中顯示所有的IK groups將會在IK計算時被運行.&lt;br&gt;&lt;br&gt; 在列表中一個 IK group需要被選擇，為了顯現它的參數在剩餘的對話框中.&lt;br&gt;&lt;br&gt; 在列表中的順序很重要(IK group 1的結果可能被IK group 2需要來正確地或更快的執行).&lt;br&gt;&lt;br&gt; 在列表旁的兩個按鈕可以改變被選擇的IK group的位置.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  IK group is active:     允許啟動這個IK groups.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Explicit handling: &lt;br&gt;&lt;br&gt;表示被選擇的IK group 是否應該被明確地處理. &lt;br&gt;&lt;br&gt;如果打勾, 當呼叫simHandleIkGroup(sim_handle_all_except_explicit)時，&lt;br&gt;&lt;br&gt;在IK 計算這個IK group將不會被處理，但只有當&lt;br&gt;&lt;br&gt;simHandleIkGroup(sim_handle_all) or&lt;br&gt;&lt;br&gt; simHandleIkGroup(ikGroupHandle) 呼叫時除外. &lt;br&gt;&lt;br&gt;這是非常有用的當如果用戶希望在  child script 而不是在  main script&lt;br&gt;&lt;br&gt;處理IK group裡的kinematics  (如果沒有打勾, IK計算將會被執行兩次,一次是在&lt;br&gt;&lt;br&gt;main script呼叫simHandleIkGroup(sim_handle_all_except_explicit) 時, &lt;br&gt;&lt;br&gt;另一次是在child script 呼叫simHandleIkGroup(ikGroupHandle)時. &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Mechanism is redundant: &lt;br&gt;&lt;br&gt;當被打勾時, 在IK解析時joint限制校正將被啟用. &lt;br&gt;&lt;br&gt;否則，joint limits 將會簡單地被強制執行在IK 解析之後，可能導致不穩定.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Ignore max. step sizes:   如果被勾選，在  joint properties 裡的maximum step sizes 將會被忽略.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Calc. method: &lt;br&gt;&lt;br&gt;具體說明IK group 決定使用的計算方式. &lt;br&gt;&lt;br&gt; Pseudo inverse  是最快的方式但可能不穩定當目標與 tip lie 距離太遠, 當一個運動鏈超過限制或當機構靠近一個單一組態 或 超出目標.&lt;br&gt;&lt;br&gt;  DLS 是較慢但更穩定因為它是一個阻尼分析方式(阻尼因子可以被指定（阻尼）). &lt;br&gt;&lt;br&gt;這是一個好的選擇當  pseudo inverse可能失敗.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Damping: &lt;br&gt;&lt;br&gt;阻尼因子當使用DLS.  較大的值導致更穩定的分辨率，但速度很慢。適當地調整值是重要的。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Max. iterations: &lt;br&gt;&lt;br&gt;重複的最大數值可以被指定. 這是計算經過的最大數量對於給予的IK group，直到它指定的結果精度到達. DLS 經常需要比  Pseudo inverse更多的重複.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limits (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用在 joint limitation constraints &lt;br&gt;&lt;br&gt;(joint limitation constraints 是被指定在  joint properties &lt;br&gt;&lt;br&gt;(position minimum andposition range).&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Obstacle avoidance (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用對於 obstacle avoidance(避開障礙物) constraints.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limit thresholds:   線性和角度的臨界值應該和joint limitation constraints 一起被使用.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit conditional parameters:   調整選擇的IK group裡附加的參數 .&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK2.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;•  Perform if... : &lt;br&gt;&lt;br&gt;這是有條件的分析部分. &lt;br&gt;&lt;br&gt;使用者可以選擇下拉一個在列表中的IK group，&lt;br&gt;&lt;br&gt;這個IK分析結果將會決定當前IK group是否會被解決。&lt;br&gt;&lt;br&gt;被認為是成功的IK group計算的IK elements都位於指定的線性/角度精度內。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Restore if... : &lt;br&gt;&lt;br&gt;允許恢復初始IK group配置（goint values）如果分析沒有成功 (位置和/或定向精度沒有達到).&lt;br&gt;&lt;br&gt; 與上述條件的解結合時，用戶可以例如結合兩個不同的計算方法。&lt;br&gt;&lt;br&gt;這是有用的如果在操作者的目標可能超出範圍或靠近一個單一組態: &lt;br&gt;&lt;br&gt;第一次分析嘗試將試著求解IK group與non-damped resolution method (pseudo inverse, fast), &lt;br&gt;&lt;br&gt;而且如果不成功, 第二次嘗試將會試著解決它與damped resolution method (DLS, slower). &lt;br&gt;&lt;br&gt;使用者也當然可以自由手動地處理IK resolution 從script, plugin, 等.&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Edit obstacle avoidance parameters: &lt;br&gt;&lt;br&gt;允許調整避障參數。&lt;br&gt;&lt;br&gt;請注意，這只是對熟練的操作者有意義, &lt;br&gt;&lt;br&gt;而且模擬速度會大幅度地放緩。&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK3.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Select avoidance entities / Remove avoidance constraint: &lt;br&gt;&lt;br&gt;允許選擇/移除avoidance entities. &lt;br&gt;&lt;br&gt;一個整體通常是機器人，其他實體是障礙物。&lt;br&gt;&lt;br&gt; 使用簡單地measurable objects 來快速分析.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Distance threshold: &lt;br&gt;&lt;br&gt;在兩個avoidance entities 之間應該保持最小的距離.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit IK elements: &lt;br&gt;&lt;br&gt;允許編輯各種被選擇的IK group有關聯的IK elements.
&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323218日誌 - 105/07/17</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050717.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050717.html</id><summary type="html">&lt;p&gt;V-rep_solvespace_linkages&lt;/p&gt;


&lt;h2&gt;嘗試 vrep_solvespace_linkages&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/linkages.png" weight=600 &gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;影片教學：&lt;/h2&gt;
&lt;br&gt;
&lt;iframe src="https://player.vimeo.com/video/175117655" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href="https://vimeo.com/175117655"&gt;vrep_solvespace_linkages&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;檔案：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/solvespace_successful.ttt?raw=true"&gt;solvespace_successful.ttt&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;心得：&lt;/h2&gt;
&lt;h3&gt;組裝這個物件的重點我認為是在零件的順序和Dummy放置的位置，嘗試了兩天終於作了出來，對零件的從屬關係有比較OK了，有學會dummy的應用，再來就是把這些統整可以試著弄我們的 printer。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323218日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050715.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;V-rep 程式應用&lt;/p&gt;


&lt;h2&gt;從 irb360 程式中找尋可能用到的並嘗試解釋和整理。 &lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;
simGetObjectHandle - 對物件命名&lt;br&gt;
&lt;br&gt;
用法： number objectHandle=simGetObjectHandle(string objectName)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointTargetPosition - 設置目標位置(if the joint is in torque/force mode)(motor and position control are enabled)&lt;br&gt;
&lt;br&gt;
用法： number result=simSetJointTargetPosition(number objectHandle,number targetPosition)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetJointPosition - 得到軸的位置(不能使用在關節上 , 用simGetJointMatrix取代)&lt;br&gt;
&lt;br&gt;
用法： number position=simGetJointPosition(number objectHandle)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSwitchThread - 轉換到另一個程式&lt;br&gt;
&lt;br&gt;
用法： number result=simSwitchThread()&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simAddStatusbarMessage - 增加一則訊息到狀態欄&lt;br&gt;
&lt;br&gt;
用法： number result=simAddStatusbarMessage(string message)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetIkElementProperties - 設置性質的特定反向運動元素&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil&lt;br&gt;
&lt;br&gt;
補充：  IK = Inverse kinematics(在左邊功能區第三個裡)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointMode - 設置joint的操作模式&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetJointMode(number jointHandle,number jointMode,number options)&lt;br&gt;
&lt;br&gt;
補充：  option(現在設定為0是可以被使用，如果設定為1會啟用hybrid mode)&lt;br&gt;
&lt;br&gt;
jointMode&lt;br&gt; 
sim_jointmode_passive&lt;br&gt;
sim_jointmode_motion_deprecated&lt;br&gt;
sim_jointmode_ik&lt;br&gt;
sim_jointmode_ikdependent&lt;br&gt;
sim_jointmode_dependent&lt;br&gt;
sim_jointmode_force&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetObjectAssociatedWithScript - 擷取角本附加到物體處理&lt;br&gt;
&lt;br&gt;
用法：  number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle)&lt;br&gt;
&lt;br&gt;
補充：  scriptHandle = sim_handle_self&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simRMLMoveToJointPositions - 在同一時間幾個關節一起使用Reflexxes Motion Library type IV移動（驅動）。這功能只能在child scripts中一個thread中運行（因為這是一個阻塞的操作），而且C-API的不可使用。&lt;br&gt;
&lt;br&gt;
用法：number result , table newPos , table newVel , table newAccel , number timeLeft =
simRMLMoveToJointPositions ( table jointHandles , number flags , table currentVel , table currentAccel , table maxVel , table maxAccel , table maxJerk , table targetPos , table targetVel , table direction)&lt;br&gt;
&lt;br&gt;
補充：&lt;br&gt; 
jointHandles: 要驅動的joint&lt;br&gt;
flags: RML flags. -1 for default flags.&lt;br&gt;
currentVel: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
currentAccel: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used.&lt;br&gt;
maxVel: the maximum allowed velocity of the joints&lt;br&gt;
maxAccel: the maximum allowed acceleration of the joints&lt;br&gt;
maxJerk: the maximum allowed jerk of the joints&lt;br&gt;
targetPos: the desired target positions of the joints&lt;br&gt;
targetVel: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
direction: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints&lt;br&gt;
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(待補充)&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323218日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050714.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h2&gt;翻譯文章重點&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h2&gt;原文章網址：&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm "&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm &lt;/a&gt;&lt;/p&gt; 
&lt;br&gt;
&lt;h2&gt;Building the visible shapes：&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;1. Automatic mesh division：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Divide selected shapes]&lt;br&gt;
(自動分割物件，有時候會無作用)&lt;br&gt;
[Menu bar --&amp;gt; Edit -&amp;gt; Grouping/Merging --&amp;gt; Merge selected shapes]&lt;br&gt;(使選擇的物件組合在一起)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;2. Extract the convex hull：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
(使物件轉換成convex hull)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;3. Decimate the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Decimate selected shape...]&lt;br&gt;
(減少mesh三角形量)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;4. Remove the inside of the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Extract inside of selected shape]&lt;br&gt;
(此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;下圖說明上述功能應用到imported mesh（沒有第一項）：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;再來我們要分割imported mesh，有兩種方式可使用。&lt;br&gt;&lt;br&gt;
1. Automatic mesh division：跟上面一樣
&lt;br&gt;
2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。&lt;/h3&gt;
&lt;br&gt;
&lt;h2&gt;Building the joints&lt;/h2&gt;&lt;br&gt;
&lt;h3&gt;再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep2.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt; 右鍵→Add→Joint→Revolute(創建一個Revolute joint)，
再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep3.png" weight=600 &gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep4.png" weight=600 &gt;
&lt;br&gt;
&lt;h2&gt;Building the dynamic shapes&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是：&lt;br&gt;&lt;br&gt;
1. dynamic or static：&lt;br&gt;
dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。&lt;br&gt;
static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著
運動移動。&lt;br&gt;&lt;br&gt;
2. respondable or non-respondable：&lt;br&gt;
respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。&lt;br&gt;non-respondable shapes 是相反，他們不會造成碰撞運動。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀：&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;1. Pure shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape]&lt;br&gt;
一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。&lt;br&gt;
&lt;br&gt;
2. Pure compound shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
它是由多個Pure shape組合而成的，功能跟Pure shape雷同。
&lt;br&gt;
&lt;br&gt;
3. Convex shapes：&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex hull of selection] &lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。
&lt;br&gt;
&lt;br&gt;
4. Compound convex shapes, or convex decomposed shapes&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex decomposition of selection...]&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into its convex decomposition...]&lt;br&gt;
它是由多個convex shapes組合而成的，功能跟convex shapes雷同。
&lt;br&gt;
&lt;br&gt;
5. Random shapes：&lt;br&gt;
一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。&lt;/h3&gt;&lt;br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323218日誌 - 105/07/11</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050711.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050711.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h4&gt;嘗試四連桿機構&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1&gt;&lt;h3&gt;理想狀態：&lt;/h3&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;br&gt;&lt;/h1&gt;
&lt;h3&gt;前期嘗試：&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/before.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;前期階級排列：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step10.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;查詢資料：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step11.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;(在兩個dynamic item之間不能有static item)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;修改後：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step12.png" weight=600 &gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/after.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;未來嘗試：製作搖擺機構&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm &lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323218日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050704.html" rel="alternate"></link><updated>2016-07-24T21:07:48+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323218ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h3&gt;熟悉 V-Rep 基本操作&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/introduce1.PNG"&gt;
&lt;br&gt;
&lt;h3&gt;1. 2D移動&lt;br&gt;
2. 3D旋轉&lt;br&gt;
3. 遠近&lt;br&gt;
4. 移動畫面至物體&lt;br&gt;
5. 物體定位(x,y,z)&lt;br&gt;
6. 物體旋轉(x,y,z)&lt;br&gt;
7. 開始模擬&lt;br&gt;
8. 暫停模擬&lt;br&gt;
9. 結束模擬&lt;br&gt;
10. 慢速&lt;br&gt;
11. 加速&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;嘗試製作 one_link_robot&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;File→import→Mesh...(從資料夾中輸入 stl檔)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;選擇單位和方向&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step3.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選物體使用"object shift"調整Z軸距離&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;右鍵→Add→Joint→Revolute(增加旋轉軸)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ...
&lt;br&gt;
&lt;h3&gt;再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用"object shift"在XYZ都點Apply to selection , 在"Orientation/Rotations"也點 Apply , 使兩軸重疊&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step6.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動)
&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step7.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;
使圓柱降階成為旋轉軸的Child&lt;br&gt;
使旋轉物降階成為圓柱的Child&lt;br&gt;
使旋轉軸降階成為底座的Child&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step8.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;按左側"Script" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座.&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step9.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;double - click the child script,  在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) &lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/Round.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選"Start simulation" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~&lt;/h3&gt;&lt;/p&gt;
&lt;h3&gt;製作影片：&lt;/h3&gt;

&lt;iframe src="https://player.vimeo.com/video/173321561" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/173321561"&gt;V-Rep one_link_robot&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry></feed>