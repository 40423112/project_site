{"pages":[{"tags":"misc","text":"機械設計專題網誌 http://project.mde.tw 是台灣國立虎尾科技大學機械設計工程系 (Department of Mechanical Design Engineering, National Formosa University, Taiwan ) KMOL 研究室 (Knowledge Management and Optimal utilization Laboratory) 專題網站, 與課程相關的網誌位於 http://chiamingyen.github.io/kmolab/blog/ . 本網誌的所有資料位於 https://github.com/coursemdetw/project_site , 除了所引用的資料特別聲明各自所宣告的使用授權外, 一律採用 AGPL 授權 https://github.com/coursemdetw/project_site/blob/gh-pages/LICENSE . 歡迎您的蒞臨! 專題成員 https://github.com/coursemdetw/project_site/watchers","url":"http://project.mde.tw/blog/pages/about/","title":"About"},{"tags":"2016bg2","text":"改寫Python-Solvespace的Makefile運作方式。 前言 : 閱讀GNU-Make的手冊之後，已經了解Makefile基本的運作方式，所以試圖解決Python-Solvespace編譯程序中出現的問題。 手冊連結： https://www.gnu.org/software/make/manual/make.pdf 利用Interface來轉換Whitequark的新版Solvespace應該是不太可行的方式了，何況Python-Solvespace也未使用全部的功能，我們需要的是解題的函式就好。 而另一方面Solid-python現在已經完全支援Python 3，若之後要調用其功能，應該也不會有太大的障礙。 所以決定把Python-Solvespace的Makefile重新寫好，將Python-Solvespace的資料庫建構完成。 Netbeans的支援 : 其實Netbeans與$GNU開發者工具包$周邊的軟體都有良好的相依性，因此在撰寫Makefile時方便不少。 在編寫完Makefile時，可以在個別的Makefile上點擊右鍵，選擇需要的命令讓make執行，諸如all、clean等等的功能可以選擇。 Makefile中可以撰寫功能讓工程師執行，連基本的clean功能也可以自訂要刪除哪些檔案。 當然利用這點，Makefile中也可以利用Echo做help的功能，Whitequark的Solvespace就有支援。 編寫Makefile : 原本Python-Solvespace的Makefile是將檔案分類，再一類類用一樣的式子做轉換，而且語法冗長還有許多錯誤。若有新增檔案，就必須填入參數的名單中登記。 一個小型程式專案的Makefile事實上只需要下列的式子就能轉換： $(ADIR)/%.obj: $(BDIR)/%.cpp $(HEADERS) $(CXX) $(FLAGS) -c -o $@ $＜ 意思是ADIR中的obj檔都與BDIR的cpp檔、標頭檔有關聯，而每個obj檔是由每個cpp檔透過＄(CXX)命令式產生的。 $後面的＄＠表示每個目標項（包括其位置）$；同理，$＄＜亦代表每個參照項$，不過＄＜是只包含第一個條件的參照項，所以後面的多個標頭檔就不會帶入＄(CXX)命令中。 若要在命令式中使用所有條件的參照項，要使用＄+，但是更好的選擇是使用＄&#94;，會自動排除重複名稱的參照項。 這樣寫固然簡單，但是每個檔案都在不同的資料夾中，要如何讓make搜尋？ 所以必須加上VPath這個參數，讓尋找參照檔案時可以搜尋到所有符合的項目。 make在找檔案時最大的特性就是$按邏輯去找$。 也因為這點，不用顧慮產生檔案的順序問題。只要\"填寫\"檔案是如何產生的，make就會根據需要的檔案來做順序調整。 make會先忽略還沒產生的參照檔案，尋找已經備齊參照檔案的項目先做，指令亦可使用外部程式來執行。 編譯瓶頸 : 經過重新整理的Makefile，應該是沒有問題了，都將指令分配完整沒有衝突。 但是仍然遇到Makefile以外的一些問題。 已解決 Stdint.h 這個原先是C語言的額外函式庫，幫助統一化使用的格式，但是如果沒裝，就會選擇作者寫的指令。 不過這個地方應該是寫錯了，會一直認為這些是未定義的格式。 其實導入\"stdint.h\"的地方也只有上圖的前半段，所以最快的解決方法就是讓solvespace.h擁有stdint.h一部份的能力。 在上面這張Netbeans的比較圖中，直接把前半段的功能插進來用了，並成功解決問題。 Min & Max Funtions 下列solvespace.h的函式出了問題。 #ifndef min #define min(x, y) ((x) < (y) ? (x) : (y)) #endif #ifndef max #define max(x, y) ((x) > (y) ? (x) : (y)) #endif 上網搜尋了一下，找到基本款的用法： #define min(x, y) (((x)＜(y)) ? (x):(y)) #define max(x, y) (((x)>(y)) ? (x):(y)) 加上括弧其實非必要，因為三元運算子的優先度本身就比大於小於還低。 不過這個判斷式使用上怪怪的，移除後直接define就沒這個問題了。 Object-oriented problem 在surface.h中有一段是這樣描述的： class STrimBy { ... static STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool bkwds); ... }; 到stackoverflow.com的論壇尋找後，有相似的問題。 是物件導向的從屬錯誤，不應該重複稱呼，但是編譯器通常不會抓這種錯誤，解決方法是刪掉前面的父項名稱。 最後變成： class STrimBy { ... static EntireCurve(SShell *shell, hSCurve hsc, bool bkwds); ... }; 也是成功解決。 未解決 Icons 首先是圖示(icon)的問題。 Python-Solvespace的作者使用另一個語言$Perl$的程式來做出\"icons.h\"這個檔案。 Perl是一個高階語言，特點就是除了自己的寫法，還可以安裝大量模組來改變撰寫方式，甚至還繼承許多C語言的標準式。 安裝方式跟Python相同，複製檔案跟設定環境變數就能使用了。 作者用了\"GD\"這個模組來導出\"icons.h\"。 Netbeans雖然也有Perl的附加元件，但是功能比SciTE還陽春，就沒使用它了。 Perl的副檔名是pl，專案中有\"png2c.pl\"和\"pngchar2c.pl\"，應該就是將PNG檔導入C語言中的意思，Makefile中是要執行\"png2c.pl\"並產生出\"icons.h\"和\"icons-proto.h\"的樣子，不過\"icons-proto.h\"不會用到。 以下是\"png2c.pl\"的內容： #!/usr/bin/perl use GD; my ($out, $proto) = @ARGV; open(OUT, \">$out\") or die \"$out: $!\"; open(PROTO, \">$proto\") or die \"$proto: $!\"; for $file ( ) { next if $file =~ /char-/; $file =~ m#.*/(.*)\\.png#; $base = \"Icon_$1\"; $base =~ y/-/_/; open(PNG, $file) or die \"$file: $!\\n\"; $img = newFromPng GD::Image(\\*PNG) or die; $img->trueColor(1); close PNG; ($width, $height) = $img->getBounds(); die \"$file: $width, $height\" if ($width != 24) or ($height != 24); print PROTO \"extern unsigned char $base\\[24*24*3\\];\"; print OUT \"unsigned char $base\\[24*24*3] = {\\n\"; for($y = 0; $y < 24; $y++) { for($x = 0; $x < 24; $x++) { $index = $img->getPixel($x, 23-$y); ($r, $g, $b) = $img->rgb($index); if($r + $g + $b < 11) { ($r, $g, $b) = (30, 30, 30); } printf OUT \" 0x%02x, 0x%02x, 0x%02x,\\n\", $r, $g, $b; } } print OUT \"};\\n\\n\"; } 在Netbeans中似乎無法呼叫外部程式，會顯示無法找到Perl指令的訊息。 可是到CMD中執行時又會發生無法回應的情況，接著make就會因為找不到\"icons.h\"而無法編譯。 ld.exe does not find libraries 在exposed資料的Makefile中，g++的參數中需要導入資料庫\"-lslvs\"。 而在上一個步驟中，\"libslvs.so\"確定已經產生，但是找不到的狀況。 網路上普遍都是需要資料連結和打錯名稱，但是好像沒這種狀況，莫非是\"libslvs.so\"產生失敗，或是並非\"slvs\"這個名稱？ Python-Solvespace的作者有特別指名不要使用DLL做副檔名。 這次學到了編譯程式重要的一環，雖然make的過程中很煩人，也要一直注意是否出錯，但是成功後滿有成就感的。 有些錯誤當下想不出來，不過換一種想法後就能克服許多障礙，訓練眼光放遠也是一件重要的事情。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050718.html","title":"40323230日誌 - 105/07/18"},{"tags":"2016g1","text":"關於目前設計3dprinter clouds domain name可能想要的名子(IPV6還沒弄) kmolprint.mde.tw 目前我們這組規劃圖設計以及目前擁有的功能 今天將攝影機的模組mjpg串流做好了","url":"http://project.mde.tw/blog/kmolprint-0716.html","title":"KmolPrint 0716"},{"tags":"2016bg2","text":"閱讀GNU-Make相關的知識。 嘗試了解Python-Solvespace的Makefile運作方式。 Makefile簡介 : 閱讀資料來源： http://mropengate.blogspot.tw/2015/06/makefile-makefile.html http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80) GNU-Make在開發者工具包有著極其重要的地位，最大的好處就是「自動化編譯」。 相較於要用shell來執行編譯的Script，GNU-Make可以只針對部分內容作測試，相當有自由度。 make.exe依靠著Makefile的設定來將整個專案按照原作者的設定，編譯成可執行文件或是連結庫。 也因為如此，只要是願意加入專案協同的工程師，裝好原作者使用的工具，無論使用哪個編譯程式，就能利用一個make命令，從頭到尾將專案編譯好進行測試或除錯。 注意事項 : GNU-Make在閱讀一份Makefile時有幾個重點。 首先若直接執行make指令，會尋找當前目錄中叫\"Makefile\"或\"makefile\"的文件。若Makefile並非這兩個名稱（亦能自訂附檔名），可以加上\"-f\"參數指定Makefile的名稱。 Makefile中包含了 ： 1. 顯式規則 ：說明如何生成一個或多個文件，有使用工具、依賴文件、使用參數等等。 2. 隱晦規則 ：不太瞭解這個功能，大約是利用自動推導原則，可以比較簡略地寫定義，篩選檔案。 3. 變量 ：自訂參數的功能，能自由更改位置或目標名稱、使用工具和參數等等。 4. 文件指示 ：Makefile之間是可以互相溝通的，也可以透過情況作出判斷。 5. 註解 ：Makefile的註解符號是\"#\"，如果要使用井字符號，必須使用反斜線\"#\"。 特別注意，在Makefile中，命令項的起始一定要使用Tab縮排，不可使用空白字元。 一般撰寫程式的編譯器都能檢視空白字元的類型。 SciTE ：View -> Whitespace Netbeams ：View -> Show Non-printable Characters 在此會發現Tab（→）和空白字元（.）的差異。 不過某些像是SciTE的編譯器，在按下Tab鍵時，會幫使用者轉換成四個空白字元，甚至會用空白字元補齊縮排，所以使用上需要注意。 Makefile中的目錄分隔號是斜線\"/\"，換行閱讀符號是反斜線\"\\\"。 GNU-Make在執行途中遇到錯誤就會停止並跳出，所以必須要整個Makefile和編譯過程都沒有干擾執行問題，才會編譯完畢。 主要規則 : 語法的結構就是目標文件（未生成）後方加上冒號和空格，接著同一行中必須接上會利用到的檔案名稱（不包含工具和include參數的項目）。 第二行是寫下如何產生目標文件的命令。 一個項目中有多個檔案時會用一個空白字元分隔。換行時如果想縮排以便閱讀，必須使用空白字元縮排，不然Tab起始的項目都會視為命令。 而如果命令不能執行時就會中斷操作。 Makefile中的參數定義和大部分的語言雷同。不過為了明顯標示，大部分使用者習慣大寫字母。 定義項目後，使用\"＄( )\"符號括住來使用變數。變數可以是目錄位置、命令名稱、參數名稱，亦有如\"＄＄(basename ＄＄(notdir ＄＄@))\"內定的用法。 編譯結果 : 途中用Netbeams作輔助檢查檔案關聯性和編寫文件，並make專案。 不過用cmd下指令也是可行。只是直接打make會用到MinGW的make，必須先指定MSYS的make。 Python-Solvespace中的Makefile編寫有一些小缺漏，是Tab和空白字元的問題，後來改正就沒問題了。 不過後來在Netbeams編譯外層\"Solvespace\"時出現了一些問題： 檢查了一下，似乎中間的檔案\"＄(SRFOBJS)\"找不到？而\"＄(SRFOBJS)\"的檔案是從\"srf\\＄(@B).cpp\"和\"＄(HEADERS)\"產生的。 其中\"srf\\＄(@B).cpp\"應該就是取下所有\\srf資料夾的cpp檔案，配上標頭檔後生成obj檔。途中不知道什麼原因obj檔沒有產生，所以才會無法找到？ 但是只編譯exposed資料夾的Makefile時又有這個問題： 上網檢查了一下這段的用途是編碼對應，可是語法照常來講應該沒錯才是。 而且後面對應的檔案導入時都出錯，所以就停止了。 Makefile和cmake的CMakelist.txt一樣都是工程師自己要創建的，所以又是一項工程，不過除了一些內定代號，其他都滿好理解的。 找了一下Python-Solvespace相關的網站，但是內容都好少。不過在Github的說明已經滿詳盡了，只是倉儲內的資料時間有點久遠，所以要花些時間偵錯。","url":"http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html","title":"40323230紀錄 - Makefile的建構"},{"tags":"2016bg2","text":"V-rep 程式應用 從 irb360 程式中找尋可能用到的並嘗試解釋和整理。 simGetObjectHandle - 對物件命名 用法： number objectHandle=simGetObjectHandle(string objectName) simSetJointTargetPosition - 設置目標位置(if the joint is in torque/force mode)(motor and position control are enabled) 用法： number result=simSetJointTargetPosition(number objectHandle,number targetPosition) simGetJointPosition - 得到軸的位置(不能使用在關節上 , 用simGetJointMatrix取代) 用法： number position=simGetJointPosition(number objectHandle) simSwitchThread - 轉換到另一個程式 用法： number result=simSwitchThread() simAddStatusbarMessage - 增加一則訊息到狀態欄 用法： number result=simAddStatusbarMessage(string message) simSetIkElementProperties - 設置性質的特定反向運動元素 用法： number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil 補充： IK = Inverse kinematics(在左邊功能區第三個裡) simSetJointMode - 設置joint的操作模式 用法： number result=simSetJointMode(number jointHandle,number jointMode,number options) 補充： option(現在設定為0是可以被使用，如果設定為1會啟用hybrid mode) jointMode sim_jointmode_passive sim_jointmode_motion_deprecated sim_jointmode_ik sim_jointmode_ikdependent sim_jointmode_dependent sim_jointmode_force simGetObjectAssociatedWithScript - 擷取角本附加到物體處理 用法： number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle) 補充： scriptHandle = sim_handle_self simRMLMoveToJointPositions - 在同一時間幾個關節一起使用Reflexxes Motion Library type IV移動（驅動）。這功能只能在child scripts中一個thread中運行（因為這是一個阻塞的操作），而且C-API的不可使用。 用法：number result , table newPos , table newVel , table newAccel , number timeLeft = simRMLMoveToJointPositions ( table jointHandles , number flags , table currentVel , table currentAccel , table maxVel , table maxAccel , table maxJerk , table targetPos , table targetVel , table direction) 補充： jointHandles: 要驅動的joint flags: RML flags. -1 for default flags. currentVel: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used. currentAccel: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used. maxVel: the maximum allowed velocity of the joints maxAccel: the maximum allowed acceleration of the joints maxJerk: the maximum allowed jerk of the joints targetPos: the desired target positions of the joints targetVel: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used. direction: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints (待補充)","url":"http://project.mde.tw/blog/40323218ri-zhi-1050715.html","title":"40323218日誌 - 105/07/15"},{"tags":"2016g1","text":"將OctoPrint標題替換成KMOL 先來看關於下圖的框框處，是如何更動的 一開始用grepwin 尋找OctoPrint然後找了蠻久的，終於在下圖的地方找到了 不過後來重啟ocopi之後，發現在還沒有完全載入前，是有變換成KMOL的，不過後來又變回去OctoPrint，後來在網頁按下F12查看原始碼，發現到在下圖中框框處， load 到框框前都是KMOL，不過框框後發現到又變回去OctoPrint了 所以去查看那些檔案裡頭的程式碼，裡頭也是很多關於物件導向的東西，不過還好有惡補了一下，所以不是太難，又想到裡頭它可能有重新指向一個物件，導致它又重置了，所以又在下圖的地方發現了他有定義一個屬性項，去執行底下的程式 於是為了找webassets 這個物件，又費了一番功夫，網頁的話，想到會不會跟 .js檔有關呢? 於是到了網頁原始碼裡找，終於在下圖的地方找到了 不過由於無法直接在網頁原始碼上頭進行修改，要在設定檔裡頭修改，於是朝天花板發呆了大約5分鐘，思考了一下大概的檔案位置，於是在下圖找到了檔案位置了，將裡頭的OctoPrint修改成KMOL之後再重啟OctoPi 就會變成這樣，成功的更動，之後的小圖檔也修改成KMOL的圖示了 關於要修改裡的設定檔，跟我原本預期的不太一樣，要進到蠻底層的，才能修改到，不過也多虧了grepwin這個工具，幫了我蠻多忙，因為有進行大約一個多禮拜的python課程惡補一下，對於裡頭的程式碼大概都看得懂七八成了，所以覺得還ok，對於我的組員們，我感謝他們通融我這一個多禮拜沒什麼做事情，另外老師說的同時控制10個馬達的東西，我找過櫃子了，沒有找到，另外在櫃子裡也發現到有蠻多學長留下來的論文可以參考，所以拿給模擬作動的組別參考用了，裡頭有關平面四連桿、史都華平台機構、逆向運動學等等......","url":"http://project.mde.tw/blog/40323131ri-zhi-1050715.html","title":"40323131日誌 105/07/15"},{"tags":"2016g1","text":"解決手臂動力問題 日記: 今天決定了動力不足的解決方案，選擇的方案是更換馬達，原因是因為可以迅速的解決問題。於是便將除了驅動旋盤的馬達外全部換成一般型的伺服馬達。控制程式找了別人寫的馬達控制程式修改，還沒有改完。 原本打算嘗試看看減速機，但可能會多花很多時間，之後可能會再找時間看看。 今天還想了一套只用一個馬達的夾取手臂，最後因為更換馬達的決定而放棄這個方案沒有做出來。 今天還看了看研究室裡名叫創意性機構設計分析的書，覺得我先前做試的順序有很多問題，還沒有整理出來。 新手臂構想: 做一個四連桿，曲桿和搖桿等長，再將連接桿延長安裝夾頭，用馬達去驅動曲桿來控制。 初始位置為曲桿垂直地面，夾取位置為[ r sinT+C , r - r cosT +C ] T為角度，C為補正。 構想圖 備註: 1.伺服馬達是在虎尾的無名電子買的。 別人寫的馬達控制程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <Servo.h> Servo servoLeft ; // 宣告左邊伺服馬達 Servo servoRight ; // 宣告右邊伺服馬達 void setup () { servoLeft . attach ( 10 ); // 將 Pin 10 指定為左邊伺服馬達 servoRight . attach ( 9 ); // 將 Pin 9 指定為右邊伺服馬達 } void loop () { initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 same_degree (); // 左右伺服馬達同樣各轉30度 delay ( 2000 ); // 執行後停止兩秒 initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 dif_degree (); // 左伺服馬達轉30度，右伺服馬達轉150度 delay ( 2000 ); // 執行後停止兩秒 } void initial (){ servoLeft . write ( 0 ); servoRight . write ( 0 ); } void same_degree () { servoLeft . write ( 30 ); servoRight . write ( 30 ); } void dif_degree () { servoLeft . write ( 30 ); servoRight . write ( 150 ); } 來源: 修改後的程式: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <Servo.h> Servo servo1 ; Servo servo2 ; Servo servo3 ; void setup () { servo1 . attach ( 8 ); servo2 . attach ( 9 ); servo3 . attach ( 10 ); } void loop () { initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 same_degree (); // 伺服馬達同樣各轉40度 delay ( 2000 ); // 執行後停止兩秒 initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 dif_degree (); // 伺服馬達同樣各轉90度 delay ( 2000 ); // 執行後停止兩秒 } void initial (){ servo1 . write ( 0 ); servo2 . write ( 0 ); servo3 . write ( 0 ); } void same_degree () { servo1 . write ( 40 ); servo2 . write ( 40 ); servo3 . write ( 40 ); } void dif_degree () { servo1 . write ( 90 ); servo2 . write ( 90 ); servo3 . write ( 90 ); } 結語: 發現自己的思考有很多問題，有點混亂、挫折，想整理整理，看看書。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-15ri.html","title":"40323143 -  日誌  105年7月15日"},{"tags":"2016g1","text":"關於目前設計3dprinter clouds 目前我們的網站 將原本的網站做一次更新，並且讓設定檔做好，接下來會把setting中再加入指令檔，就可以啟動攝影機和server的從新啟動以及開關server。 網址位置在:140.130.17.107 未來是想要加damain name 讓140.130改成自己的網址，好讓自己的網站發展，以及學習如何加入自己的網址。","url":"http://project.mde.tw/blog/kmolprint-0715.html","title":"KmolPrint 0715"},{"tags":"2016bg2","text":"研究Python-Solvespace。 更新Anaconda3 : 從官方網站下載最新的Anaconda 3，配有Python 3.5.2。 https://www.continuum.io/downloads 使用Path指令檢查環境變數。 確定無誤後放入可攜式環境中，並把原本的Python 3.5移除，將start.bat的環境位置改成Anaconda的資料夾。 接著再檢查Anaconda程式的運作狀態。 安裝了其他工具，也包含Leo 5.3。 說明 : Python-Solvespace 是由BBBSnowball所開發的Solvespace函式庫，另外能調用Solid-python來協助運算。 Python-Solvespace最後一次更新是在2013年，所以使用的是Python 2，SWIG可能也是舊版的。 而根據協同者們留下的\"VbDemo.vb\"紀錄，應該是用VC來編譯它的。 若要使用Solid-python，必須用\"git submodule update --init\"指令額外下載它，不然只有空資料夾。 不過目前沒有要使用Solid-python，所以可以不用下載。 按照Readme的說明，要用make指令來編譯檔案。 但是在make的時候出錯了，顯示\"missing separator. Stop.\"的錯誤，查了下面的網站，貌似是make.exe的新版本讀取舊的Makefile的問題，必須改寫他們的Makefile或使用舊版的MSYS。 http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/ 而顯示的錯誤如下圖： 與Whitequark的版本比較 : 不過Python-Solvespace有留下來interface的檔案，但是它的檔案結構已經跟Whitequark的版本不一樣了，所以也不能直接讓interface對應新版的檔案來創建。 好消息是SWIG的interface檔案改變不大，新版仍能使用。只要切換到\\exposed資料夾，使用下列指令就能生成\"slvs_wrap.cxx\"。 swig -c++ -python -py3 slvs.i 新版有用到cmake來建置檔案，但是Python-Solvespace沒有，所以沒有CMakelist的清單。而CMakelist是要手動編寫的，視規模大小來分配。 Python-Solvespace似乎是只有原本Solvespace的\"src\"資料夾部分（不過外面原本就是給編譯器介紹用）。 並將\"exposed\"、\"extlib\"、\"win32\"等資料夾放了進來，並且將總標頭檔\"slvs.h\"和DLL的\"lib.cpp\"加入\"exposed\"中，讓CDemo成為主幹，調用Solvespace裡的約束函式。 但是\"exposed\"中除了原本的CDemo，還有一個h++的標頭檔\"slvs_python.hpp\"、一個\"DOC.txt\"說明Python要如何呼叫編譯好的函式列表，以及一些Python的小程式。 test.py : py檔總共有3個，其中一個是使用Solid-python的呼叫工具，其他的\"test.py\"分別用\"2.scad\"和\"3.scad\"命名。 檢查了一下Python-Solvespace附上的py檔，最後作者做了3個測試，並寫下了一些註解。 第一個\"test.py\"，展示了Python要如何取用slvs.dll的函式，長得跟原先的\"CDemo.c\"十分相似。 在這裡，可以注意到SWIG轉換後的函式名稱還是一樣，用法也極其相似。 第二個\"test2.scad.py\"匯入了slvs和solid。 由於Python只要在附近資料中尋找到宣告的項目就可運作，所以不太確定它們的副檔名究竟是DLL還是SO、PYD之類的連結庫或Python程式。 第三個\"test3.scad.py\"明顯使用了\"slvs_solid.py\"的內容，不過只有稍微閱讀過Solid-python的Readme，所以不太知道它的函式，但是看似比Solvespace更方便。 這次在Python-Solvespace碰上一些小瓶頸。 主要是MSYS的Makefile問題，論壇上滿多人討論它在編譯時的障礙，有時連參數前加個空格都會顯示錯誤，無法進行。 而Python-Solvespace應該是用不到cmake（因為原作者是用VC），如果需要用到Netbeams，就要自行撰寫一份CMakelist，或是在編譯器中捨棄它的功能。 至於需要Python 2轉Python 3的部分比較少，除非要動用Solid-python的內容。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050715.html","title":"40323230日誌 - 105/07/15"},{"tags":"2016bg2","text":"之後的 V-rep模擬Pronter都整理於本文章中","url":"http://project.mde.tw/blog/40323250ri-zhi-v-rep-3d-printer.html","title":"40323250日誌 - V-rep & 3D-Printer"},{"tags":"2016bg2","text":"3DP碰到的問題及解決 第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。 在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床? 解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。 在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為\"+\"\"-\"\"S\"顏色分別為\"紅\"\"藍\"\"黑\"，夢工老師接的是\"+\"接紅，\"-\"接藍，\"S\"接黑。網路是\"+\"接紅，\"-\"接黑，\"S\"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。 問題:1. \"+\"\"-\"\"S\"如何接? 2.為何線路有的接兩條有的接三條? 限位開關分兩種: 1. 機械微動開關接法 機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 \"S\" 跟 \"-\" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。 2. 光學限位開關接法(我們的) 光學限位開關則是需要用到3條線，接到RAMPS上的\"S\"、\"-\"及\"+\" 3個腳位。 1.S為藍，+為紅，-為黑 2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接 今天進度 組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作","url":"http://project.mde.tw/blog/40323231ri-zhi-1050714.html","title":"40323231日誌 - 105/07/14"},{"tags":"2016g1","text":"寫Arduino控制程式 3 日記: 今天知道Arduino不能夠同時使兩個馬達作動，於是今天將馬達的控制程式改成有順序的動作，達成利用Arduino控制兩個馬達，但在測試的過程發現懸盤上的馬達在手臂伸出去後沒辦法收回來，原因可能是馬達的力量不夠，目前有兩個方案:(1).減速機 (2)馬達變更為可控制角度的馬達。 減速機優點: 1.提高馬達的輸出力。 2.加長手臂移動的時間，控制馬達運轉時間的方法會更精確。 3.馬達到定位後受慣性和重力的影響會變小，因為馬達本身的阻尼透過減速機會變大。 缺點: 複雜 更換馬達優點: 用了可以解決大部分問題 缺點: 目前沒想到 應該是利用第二種方案的可能性比較大，還沒有決定好。 備註: 1.今天將控制兩個馬達的程式完成 ( 程式1 )，若採用減速機來解決馬達輸出力不足的問題，這套就接上旋盤旋轉的程式完成。 2.若採用更換馬達來解決馬達輸出力不足的問題，會在新增角度控制的程式到程式中，還沒有寫出來。 程式1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <Servo.h> Servo myservo1 ; Servo myservo2 ; void setup () { Serial . begin ( 9600 ); myservo1 . attach ( 9 ); myservo2 . attach ( 10 ); } void loop () { int d ; int e ; //att.write(90); myservo1 . write ( 90 ); //啟動時固定 myservo2 . write ( 90 ); //啟動時固定 if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 130 ){ //e=1000*asin(d/130)*180/PI/144; //將輸入的距離轉換成需要旋轉的時間 myservo1 . write ( 175 ); //1固定正轉 delay ( 250 ); //旋轉此時間會讓馬達與安裝面垂直 myservo1 . write ( 5 ); //慣性補正 delay ( 10 ); myservo1 . write ( 91 ); //引力補正 delay ( 1000 ); myservo2 . write ( 175 ); //2固定正轉 delay ( 250 ); //旋轉此時間會讓馬達與安裝面垂直 myservo2 . write ( 5 ); //慣性補正 delay ( 10 ); myservo2 . write ( 91 ); //引力補正 delay ( 1000 ); myservo2 . write ( 175 ); //2固定正轉 delay ( 375 ); //正轉移動到目的地所需的時間 myservo2 . write ( 5 ); //慣性補正 delay ( 10 ); myservo2 . write ( 91 ); //引力補正 delay ( 1000 ); myservo1 . write ( 175 ); //1固定正轉 delay ( 375 ); //正轉移動到目的地所需的時間 myservo1 . write ( 5 ); //慣性補正 delay ( 10 ); myservo1 . write ( 89 ); //引力補正 delay ( 1000 ); myservo1 . write ( 5 ); //固定反轉 delay ( 375 ); //反轉相同時間復歸 myservo1 . write ( 5 ); //固定反轉 delay ( 270 ); myservo2 . write ( 5 ); //固定反轉 delay ( e ); //反轉相同時間復歸 myservo2 . write ( 5 ); //固定反轉 delay ( 270 ); } } } 結語: 手臂總算有一個能夠控制的程式出來了，等到輸出力不足的問題解決後測試的手臂就算完成了，接下來就可以依使用尺寸做一個實際使用的手臂。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-14ri.html","title":"40323143 -  日誌  105年7月14日"},{"tags":"2016bg2","text":"試圖解決SWIG問題 撰寫批次檔 : 依照 http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html 提供的gcc指令，撰寫了3個批次檔來執行。 第一個命名為interface.bat，用來讓swig生成\"_wrap.c\"檔，並建立\"build\"和\"dist\"兩個資料夾。 @echo off set interface_name=example echo 編譯接口 swig -python -py3 %interface_name%.i echo 編譯完成 pause REM MKDIR echo 正在建立目錄 MKDIR \"build\" MKDIR \"dist\" echo 目錄已建立 pause 第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。 原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成\".o\"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成\".pyd\"檔。 @echo off set target_name=example set module_name=example echo 正在建立暫存檔 gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include move %target_name%.o build\\%target_name%.o move %target_name%_wrap.o build\\%target_name%_wrap.o echo 暫存檔建立 pause echo 正在建立PYD gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd echo PYD建立 copy /Y runme.py dist\\runme.py python dist\\runme.py pause 第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。 @echo off set target_name=example echo RMDIR... RMDIR /S /Q .\\build RMDIR /S /Q .\\dist echo DEL... del /F /S /Q %target_name%_wrap.c del /F /S /Q %target_name%.py pause 檔案如下圖： 將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。 執行測試 : 之前的example.c和example.i內容並沒有更動。 第一次執行後，發現會出現以下錯誤： 然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。 這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。 但是這個舉動實在是太耗費時間了，所以後來放棄了。 不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖： 估計是這裡有錯誤： 不過不知道怎麼調整。 SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。 另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050714.html","title":"40323230日誌 - 105/07/14"},{"tags":"2016bg2","text":"V-rep 翻譯文章重點 原文章網址： http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm Building the visible shapes： 1. Automatic mesh division： [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes] (自動分割物件，有時候會無作用) [Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes] (使選擇的物件組合在一起) 2. Extract the convex hull： [Menu bar --> Edit --> Morph selection into convex shapes] (使物件轉換成convex hull) 3. Decimate the mesh： [Menu bar --> Edit --> Decimate selected shape...] (減少mesh三角形量) 4. Remove the inside of the mesh： [Menu bar --> Edit --> Extract inside of selected shape] (此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。) 上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。 下圖說明上述功能應用到imported mesh（沒有第一項）： 再來我們要分割imported mesh，有兩種方式可使用。 1. Automatic mesh division：跟上面一樣 2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。 Building the joints 再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。 我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。 右鍵→Add→Joint→Revolute(創建一個Revolute joint)， 再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。 Building the dynamic shapes 如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是： 1. dynamic or static： dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。 static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著 運動移動。 2. respondable or non-respondable： respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。 non-respondable shapes 是相反，他們不會造成碰撞運動。 respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀： 1. Pure shapes： [Menu bar --> Add --> Primitive shape] 一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。 2. Pure compound shapes： [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] 它是由多個Pure shape組合而成的，功能跟Pure shape雷同。 3. Convex shapes： [Menu bar --> Add --> Convex hull of selection] [Menu bar --> Edit --> Morph selection into convex shapes] Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。 4. Compound convex shapes, or convex decomposed shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] [Menu bar --> Add --> Convex decomposition of selection...] [Menu bar --> Edit --> Morph selection into its convex decomposition...] 它是由多個convex shapes組合而成的，功能跟convex shapes雷同。 5. Random shapes： 一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。 因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。","url":"http://project.mde.tw/blog/40323218ri-zhi-1050714.html","title":"40323218日誌 - 105/07/14"},{"tags":"2016g1","text":"今日讀的進度，以及筆記 For python3的部分 現在已經可以利用python讀取DHT11的值並且畫出圖形，主要程式部分我會列在下方，大致的作法是分析資料和切開資料 1.先確認Arduino部分送出來的值 可以發現是有下列三個值 temperature:溫度值 Humidity:濕度值 Flag:控制指標值 在Arduino程式碼的部分可以看到有serial write #include #define dht_dpin A0 //定義訊號要從Pin A0 進來 dht DHT; boolean flagPlot = true; void setup(){ Serial.begin(9600); delay(300); //Let system settle //Serial.println(\"Humidity and temperature\\n\\n\"); //Wait rest of 1000ms recommended delay before //accessing sensor } void loop(){ DHT.read11(dht_dpin); //去library裡面找DHT.read11 Serial.print(\"temperature:\"); Serial.println(DHT.temperature); delay(200); Serial.print(\"Humidity:\"); Serial.println(DHT.humidity); //Serial.print(\"% \"); delay(200); Serial.print(\"Flag:\"); Serial.println(flagPlot); delay(200); } 在python程式的部分程式有使用Tkinter #!/usr/bin/python3 import serial import sys import numpy as np import tkinter from matplotlib import pyplot, rcParams port = serial.Serial('COM6', 9600, timeout=1) # Tkinter canvas top = tkinter.Tk() top.title(\"Tkinter + matplotlib\") # Create flag to work with indefinite while loop flag = tkinter.BooleanVar(top) flag.set(True) def cleanText(data): data = data.replace(\"\\r\\n\", \"\") return data def onStartButtonPress(): while True: if flag.get(): line = port.readline().decode('UTF-8') reading = line.split(':') # print (reading) if len(reading) == 2: for i in range(2): if reading[0] == \"temperature\": TempLabel.config(text=cleanText(reading[1])) TempUnitLabel.config(text=\"C\") TempUnitLabel.update_idletasks() # if reading[0] == \"Temperature(F)\": # TempLabel.config(text=cleanText(reading[1])) # TempUnitLabel.config(text=\"F\") # TempUnitLabel.update_idletasks() if reading[0] == \"Humidity\": HumdLabel.config(text=cleanText(reading[1])) pData.append(float(reading[1])) del pData[0] # if reading[0] == \"Light(lx)\": # LighLabel.config(text=cleanText(reading[1])) if reading[0] == \"Flag\": # print (reading[1]) if int(reading[1]) == 1: try: print (\"In flag\") print (\"In flag -> if \") l1.set_xdata(np.arange(len(pData))) l1.set_ydata(pData) # update the data pyplot.ylim([0, 100]) pyplot.draw() # update the plot except: print (\"In flag except\") pyplot.figure() pyplot.title('Humidity') ax1 = pyplot.axes() l1, = pyplot.plot(pData) pyplot.ylim([0, 100]) if int(reading[1]) == 0: try: pyplot.close('all') l1 = None except: continue port.flushInput() top.update() else: flag.set(True) break def onExitButtonPress(): print (\"Exiting....\") flag.set(False) port.close() top.quit() top.destroy() print (\"Done.\") sys.exit() pyplot.ion() rcParams['toolbar'] = 'None' pData = [0] * 25 tkinter.Label(top, text=\"Temperature\").grid(column=1, row=1) tkinter.Label(top, text=\"Humidity\").grid(column=1, row=2) tkinter.Label(top, text=\"Light\").grid(column=1, row=3) TempLabel = tkinter.Label(top, text=\" \") TempLabel.grid(column=2, row=1) HumdLabel = tkinter.Label(top, text=\" \") HumdLabel.grid(column=2, row=2) LighLabel = tkinter.Label(top, text=\" \") LighLabel.grid(column=2, row=3) TempUnitLabel = tkinter.Label(top, text=\" \") TempUnitLabel.grid(column=3, row=1) HumdUnitLabel = tkinter.Label(top, text=\"%\") HumdUnitLabel.grid(column=3, row=2) LighUnitLabel = tkinter.Label(top, text=\"lx\") LighUnitLabel.grid(column=3, row=3) # Create Start button and associate with onStartButtonPress method StartButton = tkinter.Button(top, text=\"Start\", command=onStartButtonPress) StartButton.grid(column=1, row=4) # Create Exit button and destroy the window ExitButton = tkinter.Button(top, text=\"Exit\", command=onExitButtonPress) ExitButton.grid(column=2, row=4) top.mainloop() 可以得到這兩個畫面 底下為實際接線圖","url":"http://project.mde.tw/blog/pythontong-xun-0713.html","title":"Python通訊 0713"},{"tags":"2016g1","text":"寫Arduino控制程式 2 日記: 今天對控制程式做了一些修改，程式新增了抵抗地心引力的補正，以及抵抗慣性的補正。 今天嘗試用一片Arduino控制兩個馬達，試著寫了兩種程式，一種不會動，另一種作動方式不對，輸入4次訊號前兩次1號馬達動，後兩次2號馬達動，都不能用。 備註: 1.移動距離轉換的數學式是 1000 (acos(d/150)/144) ，將d設成所要移動的距離，將d除以承臂長度( 150 )求出比值，再用acos轉換成需要旋轉的角度，除以角速度(144)的出需要旋轉的毫秒，在 1000得出需要的秒數。 2.角速度是由myservo.write(172); 旋轉5秒轉4圈算出來的，只有目測沒有量測。為什麼用myservo.write(172)，因為其他的速度不會轉回同個位置。 3.引力補正是用與引力相反的微速轉動馬達來對抗引力。 4.慣性補正是用與運動相反的方向相反的高速 delay(100) 來抵抗慣性。 5.新增補正的原因是因為我們的馬達是連續旋轉型的，沒辦法讓他固定，所以用補正解決。 程式: 加了補正的程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <Servo.h> Servo myservo ; //旋盤上 void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 ); } void loop () { int d ; int e ; myservo . write ( 90 ); //啟動時固定 if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ e = 1000 * ( acos ( d / 150 ) / 144 ); //將輸入的距離轉換成需要旋轉的時間 myservo . write ( 172 ); //固定正轉 delay ( 270 ); //旋轉此時間會讓馬達與安裝面垂直 myservo . write ( 172 ); //慣性補正 delay ( 100 ); myservo . write ( 91 ); //引力補正 delay ( 1000 ); myservo . write ( 172 ); //固定正轉 delay ( e ); // myservo . write ( 8 ); //慣性補正 delay ( 100 ); myservo . write ( 91 ); //引力補正 delay ( 1000 ); myservo . write ( 8 ); //固定反轉 delay ( e ); //反轉相同時間復歸 myservo . write ( 8 ); //固定反轉 delay ( 270 ); } } } 嘗試控制兩個馬達的程式(一個忘了存) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <Servo.h> Servo myservo1 ; Servo myservo2 ; int x = 100 ; void setup () { Serial . begin ( 9600 ); myservo1 . attach ( 9 ); myservo2 . attach ( 9 ); } void loop () { int d ; myservo2 . write ( 90 ); if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo2 . write ( 180 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); myservo2 . write ( 90 ); delay ( 1000 ); myservo2 . write ( 0 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); myservo1 . write ( 90 ); if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo1 . write ( 180 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); myservo1 . write ( 90 ); delay ( 1000 ); myservo1 . write ( 0 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); } } } } } 問題: 每次程式跑到 1000*(acos(d/150)/144) 這一行馬達就會像失去動力般一小段時間，然後直接回到原點，將這段數學式改成常數後就沒有問題，想請問是什麼原因? 結語: 今天原本想說能至少把單個馬達的控制程式完成，看來有點高估自己了。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-13ri.html","title":"40323143 -  日誌  105年7月13日"},{"tags":"2016g1","text":"今日讀的進度，以及筆記 For python3的部分 安裝要有的原始碼 1.安裝pyserial pip install pyserial 2.安裝Firmata 下載新版Arduino中就有了 3.安裝pyfirmata pip install pyFirmata 4.下載測試程式 Firmata Test http://www.firmata.org/wiki/Main_Page 5.啟動.exe 就有底下的畫面 利用python畫圖(利用亂數取產生點) ※需要安裝matplotlib (pip install matplotlib) from matplotlib import pyplot import random x = range(0,25) y = [random.randint(0,100) for r in range(0,25)] fig1 = pyplot.figure() pyplot.plot(x, y, '-') #繪畫的座標以及表現方法 pyplot.title('First Plot - Random integers') pyplot.xlabel('X Axis') #兩軸標示 pyplot.ylabel('Y Axis') pyplot.show() 接下來就可以導入CSV或者數學方程式畫出我們想要的圖形 以及將範例code的部分放到data裡面了","url":"http://project.mde.tw/blog/pyfirmata-tong-xun.html","title":"PyFirmata 通訊"},{"tags":"2016bg2","text":"Python 3.5.2軟體更新 軟體更新目標 : 之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。 以W:為主，Y:用來撰寫網誌暫不需要更新。 1.Python 3.5及之前安裝的套件。 2.Leo 5.3正式版。 Python及套件更新步驟 : 將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。 Python 3.5.2下載處： https://www.python.org/downloads/ 刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。 在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。 pip freeze > rq.txt 清單中列的就是Python 3.4安裝的套件版本。 進入Python 3.5後使用pip指令時出現類似\"Fatal error in launcher\"的訊息，原因是官方的pip版本較舊。 如果不更新，只能用\"python -m pip\"的方式驅動它，所以先命令它為自己升級。 python -m pip install pip --upgrade 然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。 接著利用下列指令更新： pip install -r rq.txt 就會裝回所有的套件了。 使用下列指令可以查看已安裝的套件。 而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。 //已安裝套件 pip freeze //過期套件 pip list --outdated Leo更新步驟 : 至於安裝Leo，到 http://sourceforge.net/projects/leo/files/Leo/ 下載5.3的安裝檔，並暫時解壓縮到根目錄。 接著進入\\Leo-5.3-final\\leo\\dist資料夾，執行下面指令： python setup.py install 安裝完後，接著就能把解壓縮的檔案刪除了。 不過在pip的紀錄中還是5.0 Bata2的樣子。 新版的Leo介面（設定檔複製之前的）。 上次的swig還是沒成功，\"_wrap.c\"中似乎還要加一些python3的判斷式。 http://python3porting.com/cextensions.html#module-initialization 這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050713.html","title":"40323230日誌 - 105/07/13"},{"tags":"2016g1","text":"寫Arduino控制程式 日記: 今日找了3套別人寫的Arduino控制程式來常是控制馬達，其中兩套完全不能用，因為使用的馬達為連續旋轉型的伺服馬達，與兩套程式控制的伺服馬達不同，一套是用可變電阻來控制馬達旋轉角度，一套是直接指定馬達旋轉角度直接控制。在用第三套程式控制馬達時發現沒有產生預期的效果，後來發現原因是因為在使用前馬達必須通電調整馬達上的可變電阻校正，經過校正馬達變如程式所寫的運動，後來這套程式用來校正馬達。 備註: 1.今天只能把馬達控制到可以動，還不知道能不能準確的定位。 2.馬達實際跑過後，馬達的輸出可以讓手臂正常的運動，但旋盤的外接件在手臂動作時會產生晃動，原因可能是固定的鐵芯轉的不夠緊。 3.程式中距離轉換成徑度是因為我有印象有老師說過機器讀的是徑度不是角度。 程式: 第三套程式(前兩套因為用不到，所以沒有放上來) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <Servo.h> Servo myservo ; void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 ); } void loop () { int d ; if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo . write ( d ); } } } 來源: 葉難: Arduino練習：連續旋轉伺服馬達GWS S35 因應測試需要修改後的程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <Servo.h> Servo myservo ; int x = 100 ; void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 ); } void loop () { int d ; myservo . write ( 90 ); #啟動時固定 if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo . write ( 180 ); #固定正轉 delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); #將 d變成所要移動的距離 ，再將其轉換為所需時間 myservo . write ( 90 ); #到定點固定 delay ( 1000 ); myservo . write ( 0 ); #固定反轉 delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); #喊轉相同時間復歸 } } } 結語: 以目前自己的能力沒辦法寫一套控制程式出來，連參考別人的程式也很吃力，今天修改出來的程式只能夠控制一個馬達，而且我只知道他能動能固定了，旋轉角度是否正確我就不知道了，還有極限開關也還沒寫進去，還得再努力。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-12ri.html","title":"40323143 -  日誌  105年7月12日"},{"tags":"2016g1","text":"發現極限開關繪製的重大錯誤 測試的手臂組裝完成 控制程式未完成 日記: 今天發現了第二種極限開關及底座裝配的問題，原因是因為在繪製第二種極限開關的固定孔時出錯，圖上的孔與實際的孔位置是相反的，導致底座列印出來時裝配出問題，己決方法是變更極限開關方向及電路配置，補救醒的讓極限開關及底座配合。 今天列印底座後發現底座中安裝馬達的槽的長度尺寸小0.3mm，使馬達安裝有問題，原因可能是因為列印的些微誤差，解決方法是用銼刀將槽挫大，以及修改繪圖尺寸。 機構的部分大概是如此，剩下的控制程式今天試著寫了一些，但是離實際上可用還有很多問題。 控制程式的構想: 1.承臂控制想利用控制通電時間來控制各個法達旋轉的角度，通電時間利用 [ acos(欲移動距離/承臂長度) ]/馬達角速度 ]求。 2.極限位置用極限開關訊號加上if來控制。 3.底座馬達的控制可能會是固定的旋轉時間 4.我還在學習怎麼寫 備註: 1.因為原先設計時極限開關的長邊中心線是通過底座中心點的，所以可以直接將極限開關反過來用，只改變電路配置。 2.與底座極限開關相撞的桿子也是用免洗筷剪短裝上去的，免洗筷是由先前的免洗筷殘留部分加工而來的，同樣十分堅固。 3.原先底座極限開關的電路配置是直接由接頭接去安裝在底座的arduino上，因安裝位置修改變更為繞過旋盤下方接上arduino。 4.這次的極限開關繪製錯誤時分嚴重，若不是因為剛好有辦法可以補救，製造成本就完全浪費了。 5.程式若沒辦法寫出來可能只會先讓手臂座固定的運動。 6.等測試用的手臂完成後就會進入夾頭的部分。 安裝完後的底座極限開關線路配置 由上往下看 底座馬達安裝孔因應誤差所做的變更 手臂組合完成圖 提問: 請問實際上在設計時常使用什麼方法來檢查特徵錯誤，或是特定的機制?","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-11ri.html","title":"40323143 -  日誌  105年7月11日"},{"tags":"2016g1","text":"整數(int)與浮點數(float) 整數(int) 在Python語言裡由型式int代表，在2.x版裡，分為固定精確度的整數型別int與無窮精確度的長整數型別long，一旦數值超過界限，便自動轉程長整數型別，長整數會在尾巴加上(L)作標示 在3.x版裡則統和為一，只有型別int(無窮精確度) 浮點數(float) 在電腦裡會以二進位表示法來表示，但使用二進位表示法的話，有些值並無法以二進位表示法完美表示，只能儲存近似值 當浮點數要比較大小時，不該直接使用 == 運算子，而是應該設定誤差值，例如:0.001，然後比較兩數差值之絕對值是否小於此誤差，若在誤差值內應視為相等。 整數的表示法 整數的字面值，除了以十進位(decimal)書寫，也能以二進位(binary)、十六進位(hexadecimal)、八進位(octal)書寫，分別在數字之前加上 0b 、0x 、0o即可 浮點數的表示法 除了一般帶有小數點 . 的表示法，也能使用科學記號法，以指數來表示，例如: 300 等於3乘上10的2次方，寫在程式碼裡會以 e 隔開前後 ，寫成3e2 運算 數值型別的運算子 (+、-、 、 *、/、//、%)，相關內建函式abs()絕對值，divmod()商和餘數，pow()冪次方，round()四捨五入，須特別注意round() 模組math有很多數學運算相關函式，想求 x 的 1/n次方。傳入參數，必須注意 1/3 在2.x版與3.x版裡代表不同意思 條件運算式(三元運算子) x if y else z 其中 x 、 y 、z可以是任何運算式，當 y 為真時，運算式的結果會是 x ，當 y 為假時，結果是 z 物件 型別 方法 將運算子與內建函式視同\"方法(method)\" 方法幾乎等同於函式，只不過方法附屬於某種型別的物件，當要呼叫方法時，其一般型式為\"物件.方法(參數)\"。舉例: li是個串列， li.append(3)便可將整數物件3附加在此串列的尾端。 複數(complex) 由實部(real part)與虛部(imaginary part)組合而成，皆為浮點數。 跟int、float一樣，complex為不可變物件，一但建立就不能修改，有內建函式complex()，接受一或兩個數字作為參數，或一個符合格式的字串，建立出complex物件 屬性項 當想取出複數的實部或虛部，並沒有運算子或內建函式可用，僅能透過型別complex的屬性項real與imag來取用 支援complex的運算子與內建函式，跟int與 float差不多，其中須特別注意的有 : complex不支援比較運算子(<、<=、>、>=)，3.x版的複數不支援運算子(//、%)與內建函式 divmod 模組cmath含有跟comple相關的函式，如直角座標系(笛卡兒座標系)與極座標系的轉換 轉型 在運算式中若混用不同的數值型別，須轉成相同的型別才可運算， 'hello'+5 其實是'hello'. add (5)，而Python並不會自動把數字5轉成字 '5' 。 repr ，與__str__非常類似，也是回傳字串表示，但__repr__回傳的字串可當作程式碼，再給直譯器的話，建立出相同的物件，而__str__的用意是回傳給我們易讀易懂得字串來表示該物件 底下的部分，因為不太常接觸到，所以就稍微提到而已，如果需要的話，會再補充 十進位數(Decimal): Decimal物件屬於不可變物件 分數(Fraction):有時只需處理有理數，也就是以(分子/分母)型式所表示出來的數字;用 float 無法精確表示1/10，用Decimal也不能完美表示無限位數 1 / 3 ，需要能夠記錄分子與分母的型別，用 Fraction，屬於不可變 位元運算: 不把數字當做(一個數值)，而是把數字當做\"一連串的位元(bit)\"，以位元為單位進行運算。運算元只能是整數，因為浮點數的位元運算並無意義 結語 主要重心在於了解型別int跟 float ，以及新概念:方法跟屬性項，對於型別跟物件的了解有更進一步","url":"http://project.mde.tw/blog/40323131ri-zhi-1050711-python-shu-zhi-xing-bie.html","title":"40323131日誌 105/07/11 Python 數值型別"},{"tags":"2016bg2","text":"瞭解SWIG的用法。 軟體修正 : NetBeans 為NetBeans安裝python的附加元件，使其可以編譯python文件。 這些附加元件還包含了jython2.7.0。 SWIG 上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。 https://sourceforge.net/projects/swig/files/swigwin/ 解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。 接著就能用它下參數了。 SWIG簡介 : SWIG的功能就是利用自己的Interface檔案\".i\"，產生出一個\"_wrap.c\"檔，如果DLL專案一起將這個\".c\"編譯的話，就可以讓其他高階語言呼叫了。 SWIG內有個\\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。 諸如：D語言、java、javascript、lua、php、python、ruby。 練習應用 : 參考範例： /Examples/python/simple/index.html 先寫一個\".c\"程式碼。 /* File : example.c */ /* A global variable */ double Foo = 3.0; /* Compute the greatest common divisor of positive integers */ int gcd(int x, int y) { int g; g = y; while (x > 0) { g = x; x = y % x; y = g; } return g; } 然後再寫一個Interface的\".i\"文件。 至於格式可能要參考手冊的其他內容。 /* File: example.i */ %module example extern int gcd(int x, int y); extern double Foo; 然後用cmd到/Examples/python/simple中下指令： swig -python example.i 然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。 但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。 而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。 SWIG的操作大致知道了，但是仍有些許不瞭解的地方。 像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現\".i\"文件格式錯誤的訊息。 而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。 另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。 今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050712.html","title":"40323230日誌 - 105/07/12"},{"tags":"2016bg2","text":"V-rep 嘗試四連桿機構 理想狀態： 前期嘗試： 前期階級排列： 查詢資料： (在兩個dynamic item之間不能有static item) 修改後： 未來嘗試：製作搖擺機構 參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm","url":"http://project.mde.tw/blog/40323218ri-zhi-1050711.html","title":"40323218日誌 - 105/07/11"},{"tags":"2016g1","text":"發現極限開關繪製的重大錯誤 測試的手臂組裝完成 控制程式未完成 今天發現了第二種極限開關及底座裝配的問題，原因是因為在繪製第二種極限開關的固定孔時出錯，圖上的孔與實際的孔位置是相反的，導致底座列印出來時裝配出問題，己決方法是變更極限開關方向及電路配置，補救醒的讓極限開關及底座配合。 今天列印底座後發現底座中安裝馬達的槽的長度尺寸小0.3mm，使馬達安裝有問題，原因可能是因為列印的些微誤差，解決方法是用銼刀將槽挫大，以及修改繪圖尺寸。 機構的部分大概是如此，剩下的控制程式今天試著寫了一些，但是離實際上可用還有很多問題。 控制程式的構想: 1.承臂控制想利用控制通電時間來控制各個法達旋轉的角度，通電時間利用 [ cos&#94;-1(欲移動距離/承臂長度) ]/馬達角速度 求。 2.極限位置用極限開關訊號加上if來控制。 3.底座馬達的控制可能會是固定的旋轉時間 4.我還在學習怎麼寫 備註: 1.因為原先設計時極限開關的長邊中心線是通過底座中心點的，所以可以直接將極限開關反過來用，只改變電路配置。 2.與底座極限開關相撞的桿子也是用免洗筷剪短裝上去的，免洗筷是由先前的免洗筷殘留部分加工而來的，同樣十分堅固。 3.原先底座極限開關的電路配置是直接由接頭接去安裝在底座的arduino上，因安裝位置修改變更為繞過旋盤下方接上arduino。 4.這次的極限開關繪製錯誤時分嚴重，若不是因為剛好有辦法可以補救，製造成本就完全浪費了。 5.程式若沒辦法寫出來可能只會先讓手臂座固定的運動。 6.等測試用的手臂完成後就會進入夾頭的部分。 安裝完後的底座極限開關線路配置 由上往下看 底座馬達安裝孔因應誤差所做的變更 手臂組合完成圖 提問: 請問實際上在設計時常使用什麼方法來檢查特徵錯誤，或是特定的機制?","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-8ri.html","title":"40323143 -  日誌  105年7月8日"},{"tags":"2016bg2","text":"使用2015cp範本練習\".py\"呼叫\".pyd\"。 編譯出Python的動態連結庫 : 從 https://github.com/coursemdetw/2015cp 下載老師的範本練習。 C程式的部分分成pymod和pyfun。 這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。 button裡的內容如下： ... # compile os.system(\"Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include -MMD -MP -MF build/\"+target_name+\".o.d -o build/\"+target_name+\".o \"+filename) # link 因為 .c 程式中起始為 PyInit_sum, 因此 os.system(\"Z:/C/MinGW/bin/gcc.exe -shared -o dist/\"+module_name+\".pyd build/\"+target_name+\".o V:/IDE/Python33/libs/libpython33.a\") g.es(\"done\") 在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。 ... # compile os.system(\"gcc -c -g -IW:/Python34/include -MMD -MP -MF build/\"+target_name+\".o.d -o build/\"+target_name+\".o \"+filename) # link 因為 .c 程式中起始為 PyInit_sum, 因此 os.system(\"gcc -shared -o dist/\"+module_name+\".pyd build/\"+target_name+\".o W:/Python34/libs/python34.lib\") g.es(\"pymod done\") 而另一邊的pyfun同理。 接著就能在\\dist資料夾中編譯出sum.pyd和pyfun.pyd了。 使用mypy.py : 接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。 mypy.py中導入sum，並使用它裡面的函式sum()。 print(sum.sum(1, 30)) 在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。 // 定義內部運算的函式內容 int sum2(int a, int b) { return a+b; } // sum 函式的 interface static PyObject* mod_sum(PyObject *self, PyObject *args) { int a; int b; int s; // ii 表示兩個輸入變數都是整數 if (!PyArg_ParseTuple(args,\"ii\",&a;,&b;)) return NULL; // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係 s = sum2(a,b); // i 表示 s 為整數 return Py_BuildValue(\"i\",s); } // 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function) // Mod_Methods 為函式 (方法) 結構定義 static struct PyMethodDef Mod_Methods[] = { {\"sum\", mod_sum, METH_VARARGS, \"Description..\"}, {NULL,NULL,0,NULL} }; sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。 另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。 這次是加入一段字串。 print(pyfun.pyfun(\"我的字串\")) 在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。 pyfun(PyObject *self,PyObject *args) { const char *to_who; if(!PyArg_ParseTuple(args,\"s\",&to;_who)) return NULL; // pyfun 函式會將輸入字串變數傳回 return PyUnicode_FromString(to_who); } 執行後的結果： 不過這兩個pyd的結尾不太一樣。 sum.pyd // 模組啟始, PyInit_ 後必須使用\"名稱\".pyd 中的模組名稱, 以便啟動 // 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum PyMODINIT_FUNC PyInit_sum(void) { // 建立模組的起始, 輸入為模組結構名稱之 address (void) PyModule_Create(&ModMethods;); } pyfun.pyd // 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同 PyInit_pyfun(void) { PyObject *m; m = PyModule_Create(&moduledef;); return m; } 意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。 若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。 延伸應用 : 只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。 在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。 添加了下列指令： //導入 #include \"math.h\" //宣告 int sum3(int a, int b); //副程式sum3 int sum3(int a, int b) { return sqrt(a+b)*10; } //定義輸入值和sum3的外部名稱score static PyObject* mod_score(PyObject *self, PyObject *args) { int a; int b; int t; if (!PyArg_ParseTuple(args,\"ii\",&a;,&b;)) return NULL; t = sum3(a,b); return Py_BuildValue(\"i\",t); } 並在PyMethodDef Mod_Methods[]中再新增一串： {\"score\", mod_score, METH_VARARGS, \"Description..\"}, 接著在mypy.py中呼叫sum.score()就行了。 Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。 這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？ 不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。","url":"http://project.mde.tw/blog/40323230lian-xi-1050711.html","title":"40323230練習 - 105/07/11"},{"tags":"2016bg2","text":"由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。 編譯出C的動態連結庫 : 找到了一個別人學校的DLL簡單範例。 http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/ 雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。 使用NetBeans建立了一個C/C++ Dynamic Library。 若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。 新建完成後，Projects的欄位就會幫使用者分類： Header Files, Resource Files, Source Files, Test Files. 這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。 如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇\"Add Existing Item...\"，再選擇想加入的檔案就行了。 按照範例先在SciTE中寫好了三個檔案。 編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。 DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。 DLLIMPORT char* Add(char*str, int a, int b) { printf(\"This is your ID(8):\\n\"); printf(\"Your ID: %s\\n\", str); printf(\"%d+%d=%d:\\n\", a, b, a+b); return \"OK\"; } 標頭檔中也有這一段匯入，供可執行檔呼叫。 DLLIMPORT char* Add(char*, int, int); 這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。 在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。 這時候會顯示成功，並在\\dist\\Debug\\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。 編譯出C的可執行檔 : 這時再把call DLL.c加入Source File中。 call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。 call DLL.c的主程式如下： int main(void) { int i1, i2; char str1[9]; printf(\"Key in:\\n\"); scanf(\"%s,%d,%d\", &str1;, i1, i2); printf(\"\\n\"); HMODULE hInst=LoadLibrary(\"DLLtest.dll\"); if(hInst==NULL){ printf(\"Can't load library.\\n\"); system(\"PAUSE\"); return 1; } char* (*CallDll)(char*, int, int); (FARPROC*)(CallDll)=GetProcAddress(hInst, \"Add\"); if(CallDll==NULL){ printf(\"NO Value.\\n\"); system(\"PAUSE\"); return 2; } printf(\"Result: %s\\n\", CallDll(str1, i1,i2)); FreeLibrary(hInst); system(\"PAUSE\"); return 0; } 然而在編譯時，NetBeans卻顯示了下列訊息： 顯示是在這段出了問題： (FARPROC*)(CallDll)=GetProcAddress(hInst, \"Add\"); 這裡的問題是定義項和被定義項的關係錯誤。 上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。 由於是內建函式，所以不太了解其格式甚麼的。 於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段： DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg); 完全不用呼叫dll名稱什麼的。 因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的\"Slvs_\"指派計算。 編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。 至於工程師規定的格式在slvs.h的註解中有所說明。 雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。 下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。","url":"http://project.mde.tw/blog/40323230lian-xi-1050710.html","title":"40323230練習 - 105/07/10"},{"tags":"2016bg2","text":"安裝SWIG 並檢視下列檔案： CDemo.exe CDemo.c 安裝工具 : 除了英文的資料，另外還讀了一下關於SWIG的相關中文資料： 1.Python的資料庫形式 https://read01.com/PnGeDg.html 2.Python在Windows中用SWIG呼叫C/C++的函式（VC） http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html 3.SWIG概念 http://user.frdm.info/ckhung/b/mi/swig.php 接著從 swig.org 下載最新版的SWIG 3.0.10，將壓縮包解至W:內。 SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的\".tar.gz\"。 解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。 如果該步驟需要完整的流程，\\Doc\\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。 在閱讀\\Doc\\Manual\\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。 只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。 手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。 CDemo.exe : CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。 在原本的\\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。 為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。 由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。 顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。 CDemo.c : 由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。 用SciTE開啟CDemo.c，可以發現CDemo的原始碼。 而為了方便，將它部分的原始碼貼在下面： /*----------------------------------------------------------------------------- * Some sample code for slvs.dll. We draw some geometric entities, provide * initial guesses for their positions, and then constrain them. The solver * calculates their new positions, in order to satisfy the constraints. * * Copyright 2008-2013 Jonathan Westhues. *---------------------------------------------------------------------------*/ #ifdef HAVE_CONFIG_H ... #endif #ifdef WIN32 ... #endif #include #include #include #ifdef HAVE_STDINT_H ... #endif #include static Slvs_System sys; static void *CheckMalloc(size_t n) { void *r = malloc(n); if(!r) { printf(\"out of memory!\\n\"); exit(-1); } return r; } /*----------------------------------------------------------------------------- * An example of a constraint in 3d. We create a single group, with some * entities and constraints. *---------------------------------------------------------------------------*/ void Example3d() { ... } /*----------------------------------------------------------------------------- * An example of a constraint in 2d. In our first group, we create a workplane * along the reference frame's xy plane. In a second group, we create some * entities in that group and dimension them. *---------------------------------------------------------------------------*/ void Example2d() { ... } int main() { sys.param = CheckMalloc(50*sizeof(sys.param[0])); sys.entity = CheckMalloc(50*sizeof(sys.entity[0])); sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0])); sys.failed = CheckMalloc(50*sizeof(sys.failed[0])); sys.faileds = 50; /*Example3d();*/ for(;;) { Example2d(); sys.params = sys.constraints = sys.entities = 0; break; } return 0; } 在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。 所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。 void Example2d() { Slvs_hGroup g; double qw, qx, qy, qz; g = 1; /* First, we create our workplane. Its origin corresponds to the origin * of our base frame (x y z) = (0 0 0) */ sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0); sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0); sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0); sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3); /* and it is parallel to the xy plane, so it has basis vectors (1 0 0) * and (0 1 0). */ Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0, &qw;, &qx;, &qy;, &qz;); sys.param[sys.params++] = Slvs_MakeParam(4, g, qw); sys.param[sys.params++] = Slvs_MakeParam(5, g, qx); sys.param[sys.params++] = Slvs_MakeParam(6, g, qy); sys.param[sys.params++] = Slvs_MakeParam(7, g, qz); sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7); sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102); /* Now create a second group. We'll solve group 2, while leaving group 1 * constant; so the workplane that we've created will be locked down, * and the solver can't move it. */ g = 2; /* These points are represented by their coordinates (u v) within the * workplane, so they need only two parameters each. */ sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0); sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12); sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0); sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14); /* And we create a line segment with those endpoints. */ sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g, 200, 301, 302); /* Now three more points. */ sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0); sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16); sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0); sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18); sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0); sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20); /* And arc, centered at point 303, starting at point 304, ending at * point 305. */ sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102, 303, 304, 305); /* Now one more point, and a distance */ sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0); sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22); sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0); sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23); /* And a complete circle, centered at point 306 with radius equal to * distance 307. The normal is 102, the same as our workplane. */ sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200, 306, 102, 307); /* The length of our line segment is 30.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 1, g, SLVS_C_PT_PT_DISTANCE, 200, 30.0, 301, 302, 0, 0); /* And the distance from our line segment to the origin is 10.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 2, g, SLVS_C_PT_LINE_DISTANCE, 200, 10.0, 101, 0, 400, 0); /* And the line segment is vertical. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 3, g, SLVS_C_VERTICAL, 200, 0.0, 0, 0, 400, 0); /* And the distance from one endpoint to the origin is 15.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 4, g, SLVS_C_PT_PT_DISTANCE, 200, 15.0, 301, 101, 0, 0); #if 0 /* And same for the other endpoint; so if you add this constraint then * the sketch is overconstrained and will signal an error. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 5, g, SLVS_C_PT_PT_DISTANCE, 200, 18.0, 302, 101, 0, 0); #endif /* 0 */ /* The arc and the circle have equal radius. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 6, g, SLVS_C_EQUAL_RADIUS, 200, 0.0, 0, 0, 401, 402); /* The arc has radius 17.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 7, g, SLVS_C_DIAMETER, 200, 17.0*2, 0, 0, 401, 0); /* If the solver fails, then ask it to report which constraints caused * the problem. */ sys.calculateFaileds = 1; /* And solve. */ Slvs_Solve(&sys;, g); if(sys.result == SLVS_RESULT_OKAY) { printf(\"solved okay\\n\"); printf(\"line from (%.3f %.3f) to (%.3f %.3f)\\n\", sys.param[7].val, sys.param[8].val, sys.param[9].val, sys.param[10].val); printf(\"arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\\n\", sys.param[11].val, sys.param[12].val, sys.param[13].val, sys.param[14].val, sys.param[15].val, sys.param[16].val); printf(\"circle center (%.3f %.3f) radius %.3f\\n\", sys.param[17].val, sys.param[18].val, sys.param[19].val); printf(\"%d DOF\\n\", sys.dof); } else { int i; printf(\"solve failed: problematic constraints are:\"); for(i = 0; i < sys.faileds; i++) { printf(\" %d\", sys.failed[i]); } printf(\"\\n\"); if(sys.result == SLVS_RESULT_INCONSISTENT) { printf(\"system inconsistent\\n\"); } else { printf(\"system nonconvergent\\n\"); } } } \"Slvs_hGroup g\"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。 之後便能用\"sys.param[sys.params++]\"或是\"sys.entity[sys.entities++]\"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。 比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。 畫完圖之後，最後解決的程式是使用Slvs_Solve(&sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。 閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。 不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。 雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。","url":"http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html","title":"40323230紀錄 - 瞭解SWIG & CDemo的資源"},{"tags":"2016bg2","text":"嘗試用C語言解題 BUG fix : W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。 只要修改cpp.properties的路徑就可以了。 Nutcracker Solution : 上學期的 Nutcracker網誌內容 。 之前的python題目，稍微研究一下後轉成C語言。 不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。 先做了兩個程式，不過第一是介面而已，第二個才是主要架構。 撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。 有時候會偷吃步測試一些解法。 第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。 演算法概念： 途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。 #include #include int k=40; int h=10; int a=40; int b=80; double r=10; double pi=M_PI; int num=1000; int main() { double deg =pi/180; for (int j=45*num; j<=180*num; j++){ double num0=num; double th=j/num0*deg; double x1=a*cos(th); double y1=a*sin(th); double x2=x1+sqrt(b*b-y1*y1); double m=tan(th); double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1)); printf(\"%g\\n\", (int)(j/num0*100000+.5)/100000.); if(r1<=r){ printf(\"(%f,%f) (%f,0)\\n%f\\n%f r=%f\\nm=%f\\n\", x1, y1, x2, th/deg, r, r1, m); break; } } return 0; } 第二支程式的最後成果。 最後精確度還是沒有很高，不知道問題出在哪裡。 第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。 後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。 #include #include int a, b, k, h, r, lim; double o, wp, thmin, thmax; double pi=M_PI; int num=1000; double solve_minpath(int, int, int, int, int); double solve_maxangle(int, int, int, int, int); double solve_maxpath(int, int, int, int); double solve_minangle(int, int, int, int); int main() { scanf(\"%d,%d,%d,%d,%d,%d\", &a;, &b;, &k;, &h;, &r;, &lim;); //強制正值 a=abs(a); b=abs(b); h=abs(h); k=abs(k); r=abs(r); lim=abs(lim); printf(\"\\n---\\n\"); printf(\"Used pi= %f\\n\", pi); printf(\"---\\n\"); printf(\"Connecting Rod:\\n\"); printf(\"a= %d b= %d\\n\", a, b); printf(\"Rod radius= %d\\n\", r); printf(\"Rod width= %d\\n\", r*2); printf(\"Space Usage:\\n\"); printf(\"h= %d k= %d\\n\", h, k); printf(\"Work Path= %d\\n\", lim); printf(\"---\\n\\n\"); //相關參數代入副程式解題 o=solve_minpath(k, h, a, b, r); wp=solve_maxpath(lim, a, b, r)-o; thmin=solve_minangle(lim, a, b, r); thmax=solve_maxangle(k, h, a, b, r); if(a*b*lim==0){ printf(\"---ERRO---\\nSome value can't be zero.\\n\"); return 1; } else{ if(o+r>lim){ printf(\"---ERRO---\\nSpace is not enough.\\n\"); return 2; } else{ printf(\"\\n---\\n---Result---\\n\"); printf(\"Distance:\\n\"); printf(\"Offset distance:\\n\"); printf(\"o= %f\\n\", o); printf(\"Work distance:\\n\"); printf(\"wp= %f\\n\", wp); printf(\"Angle(Degree):\\n\"); printf(\"min= %f max= %f\\n---\\n\", thmin, thmax); return 0; } } } double solve_minpath(int k, int h, int a, int b, int r) { double deg =pi/180; for (int j=45*num; 180*num>=j; j++){ double num0=num; double th=j/num0*deg; double x1=a*cos(th); double y1=a*sin(th); double x2=x1+sqrt(b*b-y1*y1); double m=tan(th); double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1)); if(r>=r1){ printf(\"(%f,%f) (%f,0)\\n%f\\n%f r=%f\\nm=%f\\n\", x1, y1, x2, th/deg, r, r1, m); return x2; break; } } return 0; } double solve_maxangle(int k, int h, int a, int b, int r) { double deg =pi/180; for (int j=45*num; 180*num>=j; j++){ double num0=num; double th=j/num0*deg; double x1=a*cos(th); double y1=a*sin(th); double x2=x1+sqrt(b*b-y1*y1); double m=tan(th); double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1)); if(r>=r1){ printf(\"(%f,%f) (%f,0)\\n%f\\n%f r=%f\\nm=%f\\n\", x1, y1, x2, th/deg, r, r1, m); return th/deg; break; } } return 0; } double solve_maxpath(int lim, int a, int b, int r) { double n; double th; if (lim>a+b+r){ n=a+b; th=0; } else{ n=lim-r; th=acos((a*a+n*n-b*b)/2*a*n); } return n; } double solve_minangle(int lim, int a, int b, int r) { double n; double th; if (lim>a+b+r){ n=a+b; th=0; } else{ n=lim-r; th=acos((a*a+n*n-b*b)/(2*a*n)); } return th; } 最後執行的結果： 剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。 後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。","url":"http://project.mde.tw/blog/40323230lian-xi-1050709.html","title":"40323230練習 - 105/07/09"},{"tags":"2016g1","text":"承臂和馬達組裝完成 發現極限開關固定桿問題 新增旋盤外接件 電路配置構想 日記: 今天將兩個承臂與馬達和極限開關組裝固定 ，馬達固定是利用單心線的線芯穿過馬達與承臂上的固定孔鎖緊，因為昨天新增的凹槽可以承受馬達扭轉的力量，只需要讓他不會脫落即可。另外今天還發現固定設計在承臂上極限開關的固定桿強度不足，原因可能是因為列印的方向為桿件的徑向，導致桿在承受外力時列印接合面沒有足夠的強度支撐而產生破壞，解決方法是買5分的自攻螺釘將其鎖固。 今天新增了一個新物件，目的是為了要使馬達可以有效的對懸盤輸出，與承臂上馬達安裝位置一樣。並且在旋盤底部新增了兩個直徑2.5的孔，其目的是為了配合今天新增的物件鎖固。 今天將這旋盤以上除了夾頭外的東西組裝完，並由實物來預估線路的配置，線路配置目前的方案是將電線拉的比元件與電源的距離更長，讓電線在空中以圓弧狀放置，然後在底座上極限開關接點指向方向上將所有的線集中，然後拉到安裝在底座的arduino上。實際把線抓在安裝的預備位置轉動手臂測試時，目測在旋盤再碰觸到兩個極限開關的位置間旋轉應該是沒有問題，但今天沒有足夠的時間將底座印出來，沒有實際測試。 備註: 1.5分的自攻螺釘是在虎尾的大盤大買的。單心線的線芯是在工具箱拿的，固定大概用10公分。 2.與極限開關相撞的桿子是用免洗筷剪短裝上去的，免洗筷是從系館後面的7-11跟店員要來的，十分堅固。 3.目前的線路配置絕對不是個好方法，真的絕對不是個好方法。 4.不直接在旋盤底面新增新特徵，而是新增新物件，原因是為了方便列印旋盤。 斷裂的固定桿及其光滑的斷面 承臂與馬達固定 極限開關的鎖固 觸發極限開關的桿子 底座上電線大概的集中位置 旋盤新增的孔 新增的零件 提問: 實際上在設計機構，機構上的電路配置有什麼重點需要注意?有沒有固定的配置方式?","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-7ri.html","title":"40323143 -  日誌  105年7月7日"},{"tags":"2016g1","text":"學習python 因為遇到了一些問題，所以打算從頭學起，希望可以真正了解問題點在哪裡，也希望可以幫到其他人 先從最基本的名稱、物件、型別、指派 命名規則 當我們要在程式裡取名時，必須遵守Python的規則 : 1. 可使用英文字母小寫 a ~ z 大寫 A ~ Z 數字 0 ~ 9 底線 _ 2. 第一個字不能是數字 Python的名稱區分大小寫，所以money跟Money代表不同的名稱，不過有些識別字被Python拿去用了，稱為保留字(reserved word)或關鍵字(keyword)，代表特定的意思，有其特殊用途，不能拿來命名，下圖為Python保留字 串列(list) 除了整數(int)、浮點數(float)、字串(str)外;叫做串列(list)，此種型別可放入任何型別的物件。想建立串列物件時，語法是方括號[]，放入想含有的物件，範例 當我們說串列內可存放物件時，是讓該串列能以索引的方是指向別的物件 可變與不可變 型別int、float、str的物件，都有不可變(immutable)的特性，一旦建立之後，其值就無法更動;可以讓名稱轉而指向別的物件，但無法修改不可變物件 別名 因為Python有不可變(int,float,str)跟可變(list)物件之分，而且名稱跟物件其實是獨立的兩樣東西，所以要注意當兩個(或以上)的名稱都指向同一個物件時的狀況，別名(alias)也叫做共享參考(shared reference) tuple(元組) 就是不可變的list(串列)，須使用小括號()放入想含有的物件 運算式 算術運算子 包括(+, -, , /, %, //, )，*是乘法， 是冪次方，/是除法，//是地板除法，%餘數運算子，來看例子 str字串跟list與tuple也可以使用 + , * 作運算 比較運算子 <, <=, >, >=, !=, <>, == :作大小比較 in, not in :檢查某元素是否在容器型物件裡頭 is , is not :判斷兩個物件是否為同一個 結果會產生bool(布林)型別的物件，True與False 邏輯運算子 and, or, not ，當and運算時，只有左右兩邊皆為True時，運算結果才會是True，其餘皆為False; or則只要有一個為True，得到的結果就是True，not則 是反轉真假值 一般的數值運算子，如(+, , /)等等，其優先順序都高於比較運算子，如(<=, !=, is not)等 述句 是Python程式裡最小最基本的執行單位，每種數據都有其獨特的語法和語意，不符合述句語法的話，就是不合法的程式碼，就不能被直譯器執行 指派述句 多重指派 序列指派 增強型指派述句 if 條件判斷述句 if述句可根據運算式結果(True或False)，作為條件來判斷應該執行哪部分的程式碼，控制走向，稱此類的述句為程式流程控制，if, elif, else那一行的最後面要加上冒號(:)，表是後面將接著一組程式述句，而裡頭的述句必須縮排。 Python因使用縮排來標示程式碼的層級，不同於C / C++ / Java / C# / JavaScript 以大括號{}來包住程式碼的方式 pass述句 pass述句什麼也不做，因為根據Python語法，有時須放進述句，但不需要或不知道該寫什麼，就放pass述句，這樣便可符合語法，否則將發生錯誤 while迴圈述句 for迴圈述句 break述句與continue述句 述句總覽表 函式 定義函式的語法 def 函式名稱 (參數0, 參數1, ......): 參數 呼叫函式時可傳入參數，這個動作跟指派幾乎一模一樣，所謂傳入參數，也就是說呼叫方把某物件指派給參數的名稱，要小心的是，如果參數是可變物件，那麼函式拿到該參數後，也可以改變該物件 return述句 可視範圍(scope) 名稱的可視範圍，決定了在程式的什麼地方能夠看到該名稱，進而存取該名稱指向的物件，在尚未定義函式的程式範圍裡，所有名稱通通都擁有[全域(global)]可視範圍，這些名稱定義在程式最高最外圍的地方，如下圖 a ,b, foo, x, y ，一旦定義後，就能存取名稱指向的物件，簡稱為(全域名稱);而定義在函式範圍裡的名稱(包括參數)，如下圖的n, m，只擁有[區域(local)]可視範圍，只有在該函式內才看得到這些名稱，簡稱(區域名稱)。 在函式(區域)裡，雖可以自由取用全域名稱，但只能讀 不能寫，該如何把新物件指派給全域名稱呢?一但在函式裡把全域名稱放在指派述句的左邊，會產生區域名稱，而不是把新物件指派給全域名稱。辦法是使用(global述句)，便可在函式內重新指派全域名稱到新物件 內建函式 跟算術相關的內建函式 求總合函式sum(), 求串列長度len() range()是建立出(能提供一連串東西的物件)，可用在for迴圈 abs()絕對值, pow()冪次方，等同於**運算子, round()四捨五入到小數點後第二位, divmod()商和餘數 跟邏輯相關的內建函式 all(), any() 有些可得知關於物件的資訊 id(), type()物件的型別, callable()是不是可被呼叫 模組(module) 當Python程式越寫越大，不可能將所有程式碼都放在一起，而應該經適當的切割，根據功能特色劃分成一個又一個的模組(module)，由主程式匯入取用。Python模組可以是Python程式碼 也可以是C語言(或其他)的程式碼 我們先建立兩個檔案，一個是主程式檔，一個是模組檔，將這兩個檔案放在同一個目錄裡(檔名自取)，不一定要跟下圖一樣 在主程式檔裡，我們使用了(import 述句)匯入模組，例如(import 模組檔名)在import後加上模組名，注意，不需要加上 .py副檔名 。 在主執行檔裡使用(import 述句)的作用，就如同去執行模組檔一樣，只不過執行後得到的名稱，會被放入模組物件裡，因為Python 模組物件具有命名空間(namespace)的功能，可存放東西(名稱); 匯入後，可使用(模組名.名稱)的語法，去存取模組裡的名稱(與其指向的物件)。 import 述句還有其它變形，把 (import 模組名) 改為(from 模組名 import * )的話，等於直接把模組名裡的名稱，直接匯到主執行檔的全域範圍裡，就能直接使用(pi, gcd, factorial)等名稱，不需要再加(模組名.)，不過這種匯入方式比較容易出問題，萬一模組名裡的名稱跟你執行檔裡的名稱一樣? 或匯入多個模組，模組名之間重疊? 可以改用(from 模組名 import 名稱)，明確的指定想匯入的名稱。 另一種import 述句變形是(import 模組名 as m)，m是為模組新取的較短名稱，然後以(模組名.名稱)的語法，來存取模組內的名稱，例如: (m.pi) (m.gcd)。 標準程式庫模組 在模組keyword裡，串列kwlist含有Python的保留字，而函式iskeyword可判定某字串是否為保留字 有個模組含有Python全部的內建名稱，包括函式、常數、異常等，名稱是__builtins__，呼叫內建函式dir可列出模組內容。2.x版是模組__builtin__、3.x版是模組builtins 模組math裡含有各種常用的數學函數，如:sqrt(x)計算平方根、pow(x, y)可算出x的y次方、log10(x)可求出x的對數、sin(x)與cos(x)等三角函數、pi與 e 等數學常數 模組random跟隨機亂數相關，提供各種產生亂數的函式，不過Python模組的ranndom提供的是虛擬亂數(pseudo random 或稱假亂數)，非真正的亂數，不可用於密碼、加密、安全等方面。這種亂數屬於(亂中有序)，若了解其機制與規則，便能知道會產生哪個亂數 模組搜尋路徑 當使用import匯入模組時，Python直譯器會根據一份模組搜尋路徑清單，逐一到路徑裡去找模組，然後載入。透過模組sys的串列path得知模組搜尋路徑 模組之名( name ) 模組具備命名空間的功能，可放進名稱，除了各個模組自行提供的常數、函式之外，Python模組預設有一些名稱，其中之一( name )，指向代表模組名的字串物件，透過這個名稱，便能判斷.py檔是被當做主程式檔交給直譯器執行，還是當做模組檔被import述句匯入 結論 最重要的重點，是搞懂名稱(name)與物件(object)的概念，以及相關的型別(type)、指派(assignment)、綁定(binding)，了解基本知識，並明白在 \"Python\"裡任何東西都是物件","url":"http://project.mde.tw/blog/40323131ri-zhi-1050707.html","title":"40323131日誌 105/07/07"},{"tags":"2016bg2","text":"由原始碼編譯出Solvespace和CDemo的執行檔 安裝工具 : 必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。 連結為下載處。 1.MinGW (Not official version), https://nuwen.net/mingw.html 2.msys (Official version), http://www.mingw.org/wiki/msys 3.CMake (Official version), https://cmake.org/download/ 4.NetBeans (Our storage), http://140.130.17.17/public/Netbeans/ 存放位置除了CMake之外皆為W:內，CMake存於W:\\app資料夾中。 下載Solvespace原始碼 : 從 Whitequark的倉儲 git clone最新的原始碼到W:\\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。 NetBeans設定 : 從\\NetBeans\\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。 在Tools->Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。 大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。 若有必要可以為NetBeans安裝CMake的附加元件。 在Tools->Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。 執行Build : 接著按下New Project...新增專案。 選擇Project with Existing Sources繼續。 然後選擇Whitequark的Solvespace原始碼目錄。 並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。 這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。 這時開啟專案內的\\src\\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。 註：如果不是填在最後一項會有讀取順序錯誤的問題。 修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\\src和\\exposed資料夾下。 接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。","url":"http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html","title":"40323230紀錄 - 編譯Solvespace流程"},{"tags":"2016g1","text":"第二種極限開關的繪圖及安裝設計 第一種極限開關的安裝測試 承臂和馬達的安裝問題 日記: 今天將第二種極限開關新增到零件庫中，並在底座上依其尺寸新增了一個安裝位置，以及在懸盤上新增了一個用來安裝觸發極限開關突出物的安裝孔，和觸發極限開關的圓桿。 今天還發現原本馬達和承臂的組合方式在實際使用上的問題，問題原因是原本的組合方式是想將馬達上原本就有的固定孔與承臂上的固定孔用螺絲或桿件等連接材將兩個元件結合，但因為孔徑的問題使中心的連接材找不到適合的東西使用，所以今天在承臂與馬達組裝的位置新增了配合實驗室馬達尺寸的凹槽，列印出來安裝測試效果很不錯，實際使用應該就是如此了。 備註: 1.原先想用滑環或是其他具相同用途的機構解決線路纏繞的問題，但這些要在這禮拜內完成有難度，所以目前決定在底座設置極限開關作極限點，還會看情況修改。 2.馬達在Onshape上分為兩部分，在Onshape上分別是Part3和Part4，為了配合承臂上的組合點修改，馬達旋轉端( Part4 )的圖也修改為實際上馬達的外型。 3.夾頭部分因為在這禮拜完成極限開關的安裝有很大的困難，經討論後決定暫時將這部分放置，等安裝測試完成後繼續。 Oshape上的極限開關 底座上極限開關裝置結果 安裝觸發極限開關突出物的安裝孔 承臂與馬達組裝位置 承臂與馬達組裝位置實際測試結果 舊的承臂上安裝馬達極極限開關","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-6ri.html","title":"40323143 -  日誌  105年7月6日"},{"tags":"2016bg2","text":"V-rep 與 Solvespace的結合應用 最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 (檔案位於solvespace官網的 tutorial : linkages) 壓縮檔載點 由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤 軸都放好了 ,只是從屬關係還是不太清楚要如何放置 結果我又弄了一個圖 ,試圖從這邊學習從屬設定 目前只會讓它亂轉 感覺和各個旋轉軸速度也有關係 105 - 07/10更新 現在能夠讓連桿旋轉了 想要測試能否以固定角度來回旋轉 但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間... 目前先以控單軸為主 ,但是遇到以下狀況 如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了 參考 : Joint types and operation Child Scripts 105 - 07/11更新 Joint 種類分成以下4種 : 1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。 2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。 4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。 Control the joint : 1.simSetJointPosition : when your joint is not in force/torque mode 2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled 3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled 今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試: 只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。 105 - 07/12更新 今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... little_car.ttt 105 - 07/14更新 今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了 printer_new.ttt printer_new_2.ttt 105 - 07/15更新 今天開始研究Inverse Kinematic 逆向運動學(IK) ,透過矩正及向量運算 ,就可以得到參數 ,且恰巧有學長論文和此相關 ,從中學到了不少 ,但還沒能弄懂 ,最後要結合進V-rep模擬中 ,腳步要加快了","url":"http://project.mde.tw/blog/40323250ri-zhi-1050705.html","title":"40323250日誌 - 105/07/05"},{"tags":"2016g1","text":"第一種極限開關的繪圖及安裝設計以及夾頭極限開關安裝問題 日記: 今天將買了三種不同接觸點種類的極限開關，並將其中一種新增進入零件庫，且由其尺寸在承臂上新增其安裝位置，在Onshape上目測沒有和其他零件有接觸，承臂上的極限開關配置應該已經確定了，但夾頭座的極限開關配置找不到適合的位置，可能需要變更夾頭座的外型，或是在畫外接的零件，底座的極限開關配置還沒有畫出來，但應該會是在底座配置極限開關，在旋盤上設置接觸點觸發極限開關。 備註: 1.應祐生要求，將會在極限開關配置完成後利用3D列印印出一組非工作尺寸的手臂。 2.Onshape上只有話接觸點最長的極限開關，實際使用時會依照實際狀況運用三種不同階典的極限開關。 3.極限開關是在虎尾的國輝電子買的，三種接頭各三顆，原先想連滑環一起買，但沒有賣。 4.想自己做滑環，但是怕會燒掉。 極限開關的實體圖及量測尺寸 承臂上極限開關裝置位置 極限開關 極限開關組合完-1 極限開關組合完-2","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-5ri.html","title":"40323143 -  日誌  105年7月5日"},{"tags":"2016bg2","text":"找到的Solvespace原始碼版本 目前可攜式環境內存放的Solvespace原始碼 : 超連結為下載處。 1. Whitequark的倉儲 ：非官方人員開發的原始碼。 2. Solvespace 2.0 ：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。 3. Solvespace 2.1 ：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和 solvespace/libdxfrw 有關聯。 4. Solvespace的倉儲 ：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。 相關連結：版本差異紀錄- Solvespace的倉儲 NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。 點開記錄錯誤的視窗：","url":"http://project.mde.tw/blog/40323230ji-lu-solvespace.html","title":"40323230紀錄 - Solvespace"},{"tags":"2016bg2","text":"NetBeans的相關探索-2 註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。 目前NetBeans的 官方網站 並沒有很詳盡的介紹，只有放一些改版的導覽影片。 基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。 NetBeans啟動 : 每次啟動可攜式環境，NetBeans portable都會保留之前的設定。 只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。 另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。 不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。 設定start.bat在啟動後自動打開NetBeans。 NetBeans在啟動時載入專案的提示。 NetBeans介面 : 跟大部分的文字編譯軟體差不多的介面。 在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。 行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。 捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。 NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。 主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。 另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。 上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？ Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。 以下是File的檔案目錄和檔案總管顯示的比較。 服務頁籤中會顯示一些工具，不過不知道怎麼使用。 讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。 在物件上點擊兩下會移到該物件所在的檔案位置。 在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。 工具列的功能說明： 1：Source-切換至編輯原始碼模式。 2：History-切換至編輯記錄模式。 3：Last Edit-回到上次編輯（插入／刪除）過的位置。 4：Go back to-上一個瀏覽過的檔案。 5：Forward-下一個瀏覽過的檔案。 6：Find Selection-在本檔案搜尋框選的文字。 7：Find Previous Occurrence-尋找前一個關鍵字。 8：Find Next Occurrence-尋找後一個關鍵字。 9：Toggle Highlight Search-切換高亮度標示。 10：Toggle Rectangular Selection-切換矩形框選模式。 11：Previous Bookmark-前一個書籤。 12：Next Bookmark-下一個書籤。 13：Toggle Bookmark-切換書籤。 14：Shift Line Left-往左縮排。 15：Shift Line Right-往右縮排。 16：Start Macro Recording-開始巨集（腳本）錄製。 17：Stop Macro Recording-停止巨集錄製。 18：Comment-註解。 19：UNcomment-刪掉註解。 20：Go to Header/Source-開啟源頭檔。 使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。 以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050705.html","title":"40323230日誌 - 105/07/05"},{"tags":"2016bg2","text":"V-rep 熟悉 V-Rep 基本操作 1. 2D移動 2. 3D旋轉 3. 遠近 4. 移動畫面至物體 5. 物體定位(x,y,z) 6. 物體旋轉(x,y,z) 7. 開始模擬 8. 暫停模擬 9. 結束模擬 10. 慢速 11. 加速 嘗試製作 one_link_robot File→import→Mesh...(從資料夾中輸入 stl檔) 選擇單位和方向 點選物體使用\"object shift\"調整Z軸距離 點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體) 右鍵→Add→Joint→Revolute(增加旋轉軸) 連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑 接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ... 再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用\"object shift\"在XYZ都點Apply to selection , 在\"Orientation/Rotations\"也點 Apply , 使兩軸重疊 點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動) 使圓柱降階成為旋轉軸的Child 使旋轉物降階成為圓柱的Child 使旋轉軸降階成為底座的Child 按左側\"Script\" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座. double - click the child script, 在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) 點選\"Start simulation\" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~ 製作影片： V-Rep one_link_robot from Li Steven on Vimeo .","url":"http://project.mde.tw/blog/40323218ri-zhi-1050704.html","title":"40323218日誌 - 105/07/04"},{"tags":"2016g1","text":"針對承臂的設計及修改以及夾頭的不成功構想 日記: 今天將Onshape平台上的因馬達尺寸測量錯誤導致機械手臂零件與馬達不能配合的錯誤修正，並增加馬達的外部特徵(電線接頭)及新增參數。以及因應手臂上馬達線路的配置改變設計，目前修改的有承臂末端新增一個槽及一個孔。還有嘗試一個夾頭的連桿構想，但是沒有成功。 備註: 1.馬達固定端的寬度由和馬達邊相等的20mm改成實際尺寸18mm，因應改變馬達固定孔中心距由原本的12mm變成10mm。 2.新增arm_fixhole_diameter(承臂及馬達連接孔的孔徑)和arm_fixhole_disdance(承臂及馬達連接孔的中心距)兩個參數，arm_fixhole_diameter=1.5，arm_fixhole_disdance=21。 3.承臂末端新增一個11*10的槽，以及一個直徑為6的孔。 4.夾頭的連桿構想在Assembly 3裡，原先想將兩根從動桿分別裝在主動桿不同位置，利用其旋轉時不同的位移來帶動前方橫桿的作動，達成像握住般的夾持，結果兩側的夾持變得太少，所以沒有成功。 馬達固定孔的尺寸修改 承臂與馬達連接孔尺寸修改 夾頭構想圖 提問: 請問有沒有機構能讓有連接線的物體作360度旋轉，卻不會讓線纏住的機構？","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-4ri.html","title":"40323143 -  日誌  105年7月4日"},{"tags":"2016bg2","text":"NetBeans的相關探索 NetBeans設定 : 從 MinGW Distro - nuwen.net 下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。 下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。 這個MinGW裡還配有一個比較簡單的git工具。 NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。 先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。 設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。 NetBeans專案 : 之後新建專案，選擇C語言已有源代碼的專案。 選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。 基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。 接下來是清理和建置指令，就和打在CMD視窗裡的一樣。 幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。 按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。 下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。 左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。 左下的導航欄似乎能執行CMake的指令。 這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。 雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html","title":"40323230日誌 - 105/07/04-2"},{"tags":"2016bg2","text":"改用CMD設定CMake CMD命令cmake連接Solvespace原始碼 : Readme的Command-line build 使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。 然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。 到CMD中下Readme中提供的指令。 接著下nmake的指令。 但是在最後出現一些錯誤，不知道原因為何。 與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。 如果要改用NetBeans，就不用下nmake的指令。 Readme的MSVC build 這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。 接著同樣按照Readme的說明用CMD下指令。 不過後面的make指令會說無法讀取makefile檔。 Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050704.html","title":"40323230日誌 - 105/07/04"},{"tags":"2016g1","text":"學習python3 物件導向 稍微讀了一下老師提供的有關物件導向的資料，對於物件導向有個概念了，也有稍微做了一些筆記，放在資料夾裡頭，不過對於上次的問題，還是無法順利的解決，所以只好先跳過那一部分，先解決其他部分 下面幾張圖都是有關於上次遇到無法解決的那部分，於是我將那裏先行註解掉 略過上述的那些問題，再將一些語法問題排除後，終於成功讓控制器介面跑出來了，不過跟原本的好像又差蠻多的，沒有圖片...，那部分可能還要花時間去了解，內部的一些按鈕的功能也不確定能不能使用，還有上述的那個問題，也要解決畢竟那是有關於顏色參數那方面的問題，所以非常重要，而且看指令列那邊，在執行的時候也還是出現蠻多錯誤的，而且又不知道問題出在哪裡了，所以還有好一大段路要走阿...","url":"http://project.mde.tw/blog/40323131ri-zhi-1050703.html","title":"40323131日誌 105/07/03"},{"tags":"2016bg2","text":"關於編譯 Solvespace(更新) 使用CMake連接Solvespace原始碼 : Readme的GUI build 下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。 在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。 CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。 一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。 要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。 Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。 雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。 Configure的部分嘗試選擇MinGW的選項。 下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。 上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。 暫時用Visual Studio的設定，但是結果似乎不理想。 參考資料： 1. 教學影片-Visual Studio 2. 教學影片-Mingw 目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html","title":"40323230日誌 - 105/07/03-2"},{"tags":"2016g1","text":"今日讀的進度，以及筆記 改成執行緒的方式收值 import serial from threading import * import sys import time def handleClient(): while(True): print(\"waiting for client\") time.sleep(3) #with serial.Serial('COM6',9600,timeout = 1) as ser: def recevive(): my_list = [12] # CRLF[10]=\"\\r\\n\" with serial.Serial() as ser: ser.baudrate = 9600 ser.port = 'COM6' ser.open() #print(ser.name) while(True): text = ser.read().decode('utf-8') text = text.replace('\\r','\\n') my_list = text #想要整理成矩陣 目前無頭緒 print (my_list,end ='') if my_list[0] ==\"S\": print(\"perfect\") else: print(\"failed\") time.sleep(0.1) if __name__ == \"__main__\": t = Timer(3.0,handleClient) s = Timer(3.0,recevive) s.start() 有關執行緒的部分有多種方式可以使用，上面只是其中一個，還有別種方法是利用class的方法，不過在python3中用的方法都比較嚴謹，沒辦法隨意使用，以及他使用的語法和C其實差蠻多的，有可能後面做法做看看，利用python控制C的程式，說不定會簡單一點，但是不一定，也要實作才知道，最主要python2和python3的差別來自於他們對於編碼的方式不同，而且相對於他們使用的嚴謹，for example (encode . decode)部分的可能要需要再研讀一陣子。","url":"http://project.mde.tw/blog/pyserial-wen-ti-0703.html","title":"PySerial 問題0703"},{"tags":"2016bg2","text":"關於編譯 Solvespace 編譯 Solvespace 前的準備 : 從 Active State 下載了 ActivePerl，使用的是5.24.0／x64版。 從 Microsoft 下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。 從 GitHub 下載Solvespace的原始碼，另外在 Solvespace 提供下載的頁面中也有一個較舊版的原始碼。 裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。 用CMD從安裝目錄的\\VC\\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。 關於NMAKE的使用方法，找了幾個中國的網站介紹： 1. NMAKE的指令 2. NMAKE的開發環境設置","url":"http://project.mde.tw/blog/40323230ri-zhi-1050703.html","title":"40323230日誌 - 105/07/03"},{"tags":"2016g1","text":"今日讀的進度，以及筆記 發現到的問題 主要是安裝wxpython phoenix 和他原本使用的wxpython不一樣，因此需要更改一些兩者的不同，但是在wxTerminal的部分可以跑出gui介面，但是再傳收值得部分，有些許問題，來自於wxpython和wxpython phoenix 的部分他們不互相支援，可能是他們還有些問題 主要出問題的部分是來自於line 349 git clone :https://github.com/pyserial/pyserial 在example裡面的wxTerminal.py啟動收值部分有些許問題 底下為我寫的測試的程式 import serial with serial.Serial() as ser: ser.baudrate = 9600 ser.port = 'COM6' ser.open() print(ser.name) # ser.write(b'hello') while(1): # transform data #ser.write(b\"hello\") x = ser.read().decode print(x) 實際測試部分 最後補上 認真==鑽牛角尖的第二組 量螺絲","url":"http://project.mde.tw/blog/pyserial-wen-ti.html","title":"PySerial 問題"},{"tags":"2016bg2","text":"V-REP從範本學得的一些紀錄 V-REP Example Learning Reviews 嘗試用英文說明 Notes : The \"Scene hierarchy\" panel can show whole of outward and entity in a tree. Scene hierarchy Description page In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group. Any parts can insert a script to control them. \"Dummy\" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application. Dummy Description page 組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。 目前整理完幾何部件的檔案。存於\\users\\g2_files\\VREP_Simulation.ttt中。","url":"http://project.mde.tw/blog/40323230ji-lu.html","title":"40323230紀錄"},{"tags":"2016g1","text":"python2語法 修改成python3語法 下圖框框處，原本的程式碼是 gettext.install(domain, './locale', unicode = 1)，我是將unicode = 1 拿掉 底下的程式碼原本為imp.reload(sys) sys.setdefaultencoding('utf-8') ，在這裡我是將後面的sys.setdefaultencoding('utf-8') 拿掉，因為好像python3默認的編碼原本就是utf-8了 目前遇到的問題 下面的錯誤是說模組沒有被loaded，所以無法導入，不過我去找了一下它的目錄裡頭是有bufferedcanvas這個檔案的，所以就不清楚錯誤出在哪裡 接著底下的這個問題大概是我卡最久的地方，self.bgcolor = wx.Colour()，錯誤是說Colour這個物件沒有歸類在SetFromName裡頭，我試了蠻多次，結果都差不多.... 於是我又進到wx套件裡頭去找有沒有Colour這個物件，是找到蠻多有Colour字母的檔案，不過我不清楚要import哪一個 由於自己對於python的物件導向沒什麼概念，class跟__init__這些都不是很熟，感覺整天修改下來根本沒改什麼東西，所以感覺蠻有挫折感的...，另外用python3裡頭內建的2to3.py檔下去修改python2轉成python3語法的錯誤，感覺方便許多，我用的指令是python y:\\Python34\\Tools\\Scipts\\2to3.py -w 要修改的py檔，y:\\Python34\\Tools\\Scipts\\2to3.py 這裡是給定2to3.py檔的位置給它，-w是write的意思，然後才是要修改的py檔案","url":"http://project.mde.tw/blog/40323131ri-zhi-1050701.html","title":"40323131日誌 105/07/01"},{"tags":"2016bg2","text":"V-rep 的使用與學習 ★暑期第一個禮拜的 星期四 - 06/30★ 心得 : 今天在網路上找了一堆範例影片 ,每一部片都快一個小時 ,然後都不知道怎麼運用 ,但至少對V-rep功能多了解一些了。 ★暑期第一個禮拜的 星期五 - 07/01★ 基本功能 : 導入stl檔案 先點選導入的檔案 ,然後點選Edit選單下的Grouping / Merging ,點選 Divide selected shapes 分離零件 分離完成 拆解可能遇到的問題 加入旋轉軸 : 在右側視窗點選右鍵 , 新增 → 節點 → 旋轉軸 新增完成 ,快點兩下圖示 ,可以設定相關性質 橘色框框為旋轉軸長度及直徑 ,旋轉軸最後可以設定隱藏 移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質 綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 如果相關參數都設定好了 ,點選右鍵→編輯→使旋轉軸與零件結合成一物件 結合後的從屬關係 心得 : V-rep很好玩 ,但是它組裝的層次又比creo2.0又更上一檔次了 , 俗話說的好 「良藥苦口」,好用的東西種剛開始總是特別棘手。 ★暑期第一個禮拜的 星期六 - 07/02★ 工廠認證 及 探查狀況 傳統機臺幾乎沒有精度可言 ,一年級時故障的機臺也都沒有維修 ,只怕使用傳統機臺會成為受害者 ,不敢使用!! 旋轉軸(馬達)設定 先將各部位組立完成 設定底座Dynamic性質 , ( X = 不打勾 ) 設定Revolute_joint(馬達)性質 設定旋轉軸Dynamic性質 ,設為動態物件 設定旋轉桿Dynamic性質 都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式 在Assciated object選擇STL_Imported_sub(主體) 之後打開左方script ,並加入下面那行程式 設定完之後就可以按start ,跑老師的python範例了 ★暑期第二個禮拜的 星期一 - 07/04★ 加入攝影機 在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型 vision_sensor類型可分為 : a.為orthographic type 及 b.為perspective type 點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 , 綠色框框為範圍內的解析度 (2&#94;n ,2~256) ,棕色框框為攝影機大小 將旋轉桿和攝影機結合並設定從屬關係 在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗 點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭 下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭 下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 啟動程式來跑看看囉~ ★暑期第三個禮拜的 星期五 - 07/15★ dummy ( 虛擬座標 ) : dummy 能夠讓不是從屬性質的物件做相對移動, 常用於close chain, 以irb360範例來說 : a. b.桿為示範物件 將a.及b.桿實體隱藏之後 ,能夠看到從屬於a、b桿下的dummy為重疊狀態 ,並且為互相對應(target) 目的是因為 ,若a桿做出任何動作(移動) ,在它從屬下的dummy會隨著target的dummy做相對運動 ,因此兩桿距離始終會保持固定","url":"http://project.mde.tw/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html","title":"40323250日誌 - V-rep 功能 (持續更新中)"},{"tags":"2016g1","text":"今日讀的進度，以及筆記 三個要件 1.pyserial 2.wxpython with Phoenix 3.python3以上的版本 2.7版的wxxpython和phoenix wxpython api比較 網站連結 PySerial documation about io control 網站連結 Wxxpython API Module 網站連結 Wxxpython GUI Bulider wxGlade 今日寫程式遇到的問題點 1.在wxTeriminal中遇到問題來自於他沒辦法顯示我傳給他的值 2.以及他的pyserial中，需要詳細測試他所收到以及送的值的格式 3.才能自己寫一套for python3 Gui的程式控制 要能成功執行下方的程式必須要安裝 1.python 3.4+ 2.wxPython Phoenix 3.pyserial 關於程式碼有更改後的 #file name wxSerialConfigDialog.py import wx import serial import serial.tools.list_ports SHOW_BAUDRATE = 1 << 0 SHOW_FORMAT = 1 << 1 SHOW_FLOW = 1 << 2 SHOW_TIMEOUT = 1 << 3 SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT class SerialConfigDialog(wx.Dialog): \"\"\"\\ Serial Port configuration dialog, to be used with pySerial 2.0+ When instantiating a class of this dialog, then the \"serial\" keyword argument is mandatory. It is a reference to a serial.Serial instance. the optional \"show\" keyword argument can be used to show/hide different settings. The default is SHOW_ALL which corresponds to SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be found in this module (not the class). \"\"\" def __init__(self, *args, **kwds): # grab the serial keyword and remove it from the dict self.serial = kwds['serial'] del kwds['serial'] self.show = SHOW_ALL if 'show' in kwds: self.show = kwds.pop('show') # begin wxGlade: SerialConfigDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.label_2 = wx.StaticText(self, -1, \"Port\") self.choice_port = wx.Choice(self, -1, choices=[]) self.label_1 = wx.StaticText(self, -1, \"Baudrate\") self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN) self.sizer_1_staticbox = wx.StaticBox(self, -1, \"Basics\") self.panel_format = wx.Panel(self, -1) self.label_3 = wx.StaticText(self.panel_format, -1, \"Data Bits\") self.choice_databits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_4 = wx.StaticText(self.panel_format, -1, \"Stop Bits\") self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_5 = wx.StaticText(self.panel_format, -1, \"Parity\") self.choice_parity = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, \"Data Format\") self.panel_timeout = wx.Panel(self, -1) self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, \"Use Timeout\") self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, \"\") self.label_6 = wx.StaticText(self.panel_timeout, -1, \"seconds\") self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, \"Timeout\") self.panel_flow = wx.Panel(self, -1) self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, \"RTS/CTS\") self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, \"Xon/Xoff\") self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, \"Flow Control\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade # attach the event handlers self.__attach_events() def __set_properties(self): # begin wxGlade: SerialConfigDialog.__set_properties self.SetTitle(\"Serial Port Configuration\") self.choice_databits.SetSelection(0) self.choice_stopbits.SetSelection(0) self.choice_parity.SetSelection(0) self.text_ctrl_timeout.Enable(False) self.button_ok.SetDefault() # end wxGlade self.SetTitle(\"Serial Port Configuration\") if self.show & SHOW_TIMEOUT: self.text_ctrl_timeout.Enable(0) self.button_ok.SetDefault() if not self.show & SHOW_BAUDRATE: self.label_1.Hide() self.combo_box_baudrate.Hide() if not self.show & SHOW_FORMAT: self.panel_format.Hide() if not self.show & SHOW_TIMEOUT: self.panel_timeout.Hide() if not self.show & SHOW_FLOW: self.panel_flow.Hide() # fill in ports and select current setting preferred_index = 0 self.choice_port.Clear() self.ports = [] for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())): self.choice_port.Append('{} - {}'.format(portname, desc)) self.ports.append(portname) if self.serial.name == portname: preferred_index = n self.choice_port.SetSelection(preferred_index) if self.show & SHOW_BAUDRATE: preferred_index = None # fill in baud rates and select current setting self.combo_box_baudrate.Clear() for n, baudrate in enumerate(self.serial.BAUDRATES): self.combo_box_baudrate.Append(str(baudrate)) if self.serial.baudrate == baudrate: preferred_index = n if preferred_index is not None: self.combo_box_baudrate.SetSelection(preferred_index) else: self.combo_box_baudrate.SetValue('{}'.format(self.serial.baudrate)) if self.show & SHOW_FORMAT: # fill in data bits and select current setting self.choice_databits.Clear() for n, bytesize in enumerate(self.serial.BYTESIZES): self.choice_databits.Append(str(bytesize)) if self.serial.bytesize == bytesize: index = n self.choice_databits.SetSelection(index) # fill in stop bits and select current setting self.choice_stopbits.Clear() for n, stopbits in enumerate(self.serial.STOPBITS): self.choice_stopbits.Append(str(stopbits)) if self.serial.stopbits == stopbits: index = n self.choice_stopbits.SetSelection(index) # fill in parities and select current setting self.choice_parity.Clear() for n, parity in enumerate(self.serial.PARITIES): self.choice_parity.Append(str(serial.PARITY_NAMES[parity])) if self.serial.parity == parity: index = n self.choice_parity.SetSelection(index) if self.show & SHOW_TIMEOUT: # set the timeout mode and value if self.serial.timeout is None: self.checkbox_timeout.SetValue(False) self.text_ctrl_timeout.Enable(False) else: self.checkbox_timeout.SetValue(True) self.text_ctrl_timeout.Enable(True) self.text_ctrl_timeout.SetValue(str(self.serial.timeout)) if self.show & SHOW_FLOW: # set the rtscts mode self.checkbox_rtscts.SetValue(self.serial.rtscts) # set the rtscts mode self.checkbox_xonxoff.SetValue(self.serial.xonxoff) def __do_layout(self): # begin wxGlade: SerialConfigDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_flow_staticbox.Lower() sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL) self.sizer_timeout_staticbox.Lower() sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL) self.sizer_format_staticbox.Lower() sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL) grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0) self.sizer_1_staticbox.Lower() sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL) sizer_basics = wx.FlexGridSizer(3, 2, 0, 0) sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0) sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0) sizer_basics.AddGrowableCol(1) sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0) sizer_2.Add(sizer_1, 0, wx.EXPAND, 0) grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0) self.panel_format.SetSizer(sizer_format) sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0) sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0) sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) self.panel_timeout.SetSizer(sizer_timeout) sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0) sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add((10, 10), 1, wx.EXPAND, 0) self.panel_flow.SetSizer(sizer_flow) sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK) wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel) if self.show & SHOW_TIMEOUT: wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout) def OnOK(self, events): success = True self.serial.port = self.ports[self.choice_port.GetSelection()] if self.show & SHOW_BAUDRATE: try: b = int(self.combo_box_baudrate.GetValue()) except ValueError: with wx.MessageDialog( self, 'Baudrate must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.baudrate = b if self.show & SHOW_FORMAT: self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()] self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()] self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()] if self.show & SHOW_FLOW: self.serial.rtscts = self.checkbox_rtscts.GetValue() self.serial.xonxoff = self.checkbox_xonxoff.GetValue() if self.show & SHOW_TIMEOUT: if self.checkbox_timeout.GetValue(): try: self.serial.timeout = float(self.text_ctrl_timeout.GetValue()) except ValueError: with wx.MessageDialog( self, 'Timeout must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.timeout = None if success: self.EndModal(wx.ID_OK) def OnCancel(self, events): self.EndModal(wx.ID_CANCEL) def OnTimeout(self, events): if self.checkbox_timeout.GetValue(): self.text_ctrl_timeout.Enable(True) else: self.text_ctrl_timeout.Enable(False) # end of class SerialConfigDialog class MyApp(wx.App): \"\"\"Test code\"\"\" def OnInit(self): wx.InitAllImageHandlers() ser = serial.Serial() print(ser) # loop until cancel is pressed, old values are used as start for the next run # show the different views, one after the other # value are kept. for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL): dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser, show=flags) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break # the user can play around with the values, CANCEL aborts the loop while True: dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break return 0 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop() 主程式部分 #file name wxTerminal.py import codecs import serial import threading import wx import wxSerialConfigDialog # ---------------------------------------------------------------------- # Create an own event type, so that GUI updates can be delegated # this is required as on some platforms only the main thread can # access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave # could be used too, but an event is more elegant. SERIALRX = wx.NewEventType() # bind to serial data receive events EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0) class SerialRxEvent(wx.PyCommandEvent): eventType = SERIALRX def __init__(self, windowID, data): wx.PyCommandEvent.__init__(self, self.eventType, windowID) self.data = data def Clone(self): self.__class__(self.GetId(), self.data) # ---------------------------------------------------------------------- ID_CLEAR = wx.NewId() ID_SAVEAS = wx.NewId() ID_SETTINGS = wx.NewId() ID_TERM = wx.NewId() ID_EXIT = wx.NewId() ID_RTS = wx.NewId() ID_DTR = wx.NewId() NEWLINE_CR = 0 NEWLINE_LF = 1 NEWLINE_CRLF = 2 class TerminalSetup: \"\"\" Placeholder for various terminal settings. Used to pass the options to the TerminalSettingsDialog. \"\"\" def __init__(self): self.echo = False self.unprintable = False self.newline = NEWLINE_CRLF class TerminalSettingsDialog(wx.Dialog): \"\"\"Simple dialog with common terminal settings like echo, newline mode.\"\"\" def __init__(self, *args, **kwds): self.settings = kwds['settings'] del kwds['settings'] # begin wxGlade: TerminalSettingsDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.checkbox_echo = wx.CheckBox(self, -1, \"Local Echo\") self.checkbox_unprintable = wx.CheckBox(self, -1, \"Show unprintable characters\") self.radio_box_newline = wx.RadioBox(self, -1, \"Newline Handling\", choices=[\"CR only\", \"LF only\", \"CR+LF\"], majorDimension=0, style=wx.RA_SPECIFY_ROWS) self.sizer_4_staticbox = wx.StaticBox(self, -1, \"Input/Output\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade self.__attach_events() self.checkbox_echo.SetValue(self.settings.echo) self.checkbox_unprintable.SetValue(self.settings.unprintable) self.radio_box_newline.SetSelection(self.settings.newline) def __set_properties(self): # begin wxGlade: TerminalSettingsDialog.__set_properties self.SetTitle(\"Terminal Settings\") self.radio_box_newline.SetSelection(0) self.button_ok.SetDefault() # end wxGlade def __do_layout(self): # begin wxGlade: TerminalSettingsDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_4_staticbox.Lower() sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL) sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4) sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4) sizer_4.Add(self.radio_box_newline, 0, 0, 0) sizer_2.Add(sizer_4, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId()) self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId()) def OnOK(self, events): \"\"\"Update data wil new values and close dialog.\"\"\" self.settings.echo = self.checkbox_echo.GetValue() self.settings.unprintable = self.checkbox_unprintable.GetValue() self.settings.newline = self.radio_box_newline.GetSelection() self.EndModal(wx.ID_OK) def OnCancel(self, events): \"\"\"Do not update data but close dialog.\"\"\" self.EndModal(wx.ID_CANCEL) # end of class TerminalSettingsDialog class TerminalFrame(wx.Frame): \"\"\"Simple terminal program for wxPython\"\"\" def __init__(self, *args, **kwds): self.serial = serial.Serial() self.serial.timeout = 0.5 # make sure that the alive event can be checked from time to time self.settings = TerminalSetup() # placeholder for the settings self.thread = None self.alive = threading.Event() # begin wxGlade: TerminalFrame.__init__ kwds[\"style\"] = wx.DEFAULT_FRAME_STYLE wx.Frame.__init__(self, *args, **kwds) # Menu Bar self.frame_terminal_menubar = wx.MenuBar() wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_CLEAR, \"&Clear;\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.Append(ID_SAVEAS, \"&Save; Text As...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_TERM, \"&Terminal; Settings...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_EXIT, \"&Exit;\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"&File;\") wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_RTS, \"RTS\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_DTR, \"&DTR;\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_SETTINGS, \"&Port; Settings...\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"Serial Port\") self.SetMenuBar(self.frame_terminal_menubar) # Menu Bar end self.text_ctrl_output = wx.TextCtrl(self, -1, \"\", style=wx.TE_MULTILINE | wx.TE_READONLY) self.__set_properties() self.__do_layout() self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS) self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) # end wxGlade self.__attach_events() # register events self.OnPortSettings(None) # call setup dialog on startup, opens port if not self.alive.isSet(): self.Close() def StartThread(self): \"\"\"Start the receiver thread\"\"\" self.thread = threading.Thread(target=self.ComPortThread) self.thread.setDaemon(1) self.alive.set() self.thread.start() self.serial.rts = True self.serial.dtr = True self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts) self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr) def StopThread(self): \"\"\"Stop the receiver thread, wait until it's finished.\"\"\" if self.thread is not None: self.alive.clear() # clear alive event for thread self.thread.join() # wait until thread has finished self.thread = None def __set_properties(self): # begin wxGlade: TerminalFrame.__set_properties self.SetTitle(\"Serial Terminal\") self.SetSize((546, 383)) self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, \"\")) # end wxGlade def __do_layout(self): # begin wxGlade: TerminalFrame.__do_layout sizer_1 = wx.BoxSizer(wx.VERTICAL) sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0) self.SetSizer(sizer_1) self.Layout() # end wxGlade def __attach_events(self): # register events at the controls self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey) self.Bind(EVT_SERIALRX, self.OnSerialRead) self.Bind(wx.EVT_CLOSE, self.OnClose) def OnExit(self, event): # wxGlade: TerminalFrame. \"\"\"Menu point Exit\"\"\" self.Close() def OnClose(self, event): \"\"\"Called on application shutdown.\"\"\" self.StopThread() # stop reader thread self.serial.close() # cleanup self.Destroy() # close windows, exit app def OnSaveAs(self, event): # wxGlade: TerminalFrame. \"\"\"Save contents of output window.\"\"\" with wx.FileDialog( None, \"Save Text As...\", \".\", \"\", \"Text File|*.txt|All Files|*\", wx.SAVE) as dlg: if dlg.ShowModal() == wx.ID_OK: filename = dlg.GetPath() with codecs.open(filename, 'w', encoding='utf-8') as f: text = self.text_ctrl_output.GetValue().encode(\"utf-8\") f.write(text) def OnClear(self, event): # wxGlade: TerminalFrame. \"\"\"Clear contents of output window.\"\"\" self.text_ctrl_output.Clear() def OnPortSettings(self, event): # wxGlade: TerminalFrame. \"\"\" Show the port settings dialog. The reader thread is stopped for the settings change. \"\"\" if event is not None: # will be none when called on startup self.StopThread() self.serial.close() ok = False while not ok: with wxSerialConfigDialog.SerialConfigDialog( self, -1, \"\", show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW, serial=self.serial) as dialog_serial_cfg: dialog_serial_cfg.CenterOnParent() result = dialog_serial_cfg.ShowModal() # open port if not called on startup, open it on startup and OK too if result == wx.ID_OK or event is not None: try: self.serial.open() except serial.SerialException as e: with wx.MessageDialog(self, str(e), \"Serial Port Error\", wx.OK | wx.ICON_ERROR)as dlg: dlg.ShowModal() else: self.StartThread() self.SetTitle(\"Serial Terminal on {} [{},{},{},{}{}{}]\".format( self.serial.portstr, self.serial.baudrate, self.serial.bytesize, self.serial.parity, self.serial.stopbits, ' RTS/CTS' if self.serial.rtscts else '', ' Xon/Xoff' if self.serial.xonxoff else '', )) ok = True else: # on startup, dialog aborted self.alive.clear() ok = True def OnTermSettings(self, event): # wxGlade: TerminalFrame. \"\"\"\\ Menu point Terminal Settings. Show the settings dialog with the current terminal settings. \"\"\" with TerminalSettingsDialog(self, -1, \"\", settings=self.settings) as dialog: dialog.CenterOnParent() dialog.ShowModal() def OnKey(self, event): \"\"\"\\ Key event handler. If the key is in the ASCII range, write it to the serial port. Newline handling and local echo is also done here. \"\"\" code = event.GetUnicodeKey() if code < 256: # XXX bug in some versions of wx returning only capital letters code = event.GetKeyCode() if code == 13: # is it a newline? (check for CR which is the RETURN key) if self.settings.echo: # do echo if needed self.text_ctrl_output.AppendText('\\n') if self.settings.newline == NEWLINE_CR: self.serial.write(b'\\r') # send CR elif self.settings.newline == NEWLINE_LF: self.serial.write(b'\\n') # send LF elif self.settings.newline == NEWLINE_CRLF: self.serial.write(b'\\r\\n') # send CR+LF else: char = chr(code) if self.settings.echo: # do echo if needed self.WriteText(char) self.serial.write(char.encode('UTF-8', 'replace')) # send the character def WriteText(self, text): if self.settings.unprintable: text = ''.join([c if (c >= ' ' and c != '\\x7f') else chr(0x2400 + ord(c)) for c in text]) self.text_ctrl_output.AppendText(text) def OnSerialRead(self, event): \"\"\"Handle input from the serial port.\"\"\" self.WriteText(event.data.decode('UTF-8', 'replace')) def ComPortThread(self): \"\"\"\\ Thread that handles the incoming traffic. Does the basic input transformation (newlines) and generates an SerialRxEvent \"\"\" while self.alive.isSet(): b = self.serial.read(self.serial.in_waiting or 1) if b: # newline transformation if self.settings.newline == NEWLINE_CR: b = b.replace(b'\\r', b'\\n') elif self.settings.newline == NEWLINE_LF: pass elif self.settings.newline == NEWLINE_CRLF: b = b.replace(b'\\r\\n', b'\\n') event = SerialRxEvent(self.GetId(), b) self.GetEventHandler().AddPendingEvent(event) def OnRTS(self, event): # wxGlade: TerminalFrame. self.serial.rts = event.IsChecked() def OnDTR(self, event): # wxGlade: TerminalFrame. self.serial.dtr = event.Checked() # end of class TerminalFrame class MyApp(wx.App): def OnInit(self): wx.InitAllImageHandlers() frame_terminal = TerminalFrame(None, -1, \"\") self.SetTopWindow(frame_terminal) frame_terminal.Show(True) return 1 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop()","url":"http://project.mde.tw/blog/pyserialjin-du.html","title":"PySerial進度"},{"tags":"Tutorial","text":"RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算. # https://github.com/flukeskywalker/PyRGA # 原始程式為 Python2 修改為 Python3 格式 # 除了原先的最大化適應值外, 增加最小化方法設定 import numpy as np import random from math import * # 請注意各代族群數必須為 4 的倍數 class GA: # popsize must be multiple of 4 def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min): self.EPSILON = 10e-6 self.INFINITY = 10e6 self.pop = [] self.fits = [] self.obj = obj self.dim = dim self.popsize = popsize self.ngen = ngen self.pc = pc self.pm = pm self.etac = etac self.etam = etam # min = 1 表最小化, min = -1 表最大化 self.min = min self.RIGID = 0 self.lowb = -self.INFINITY*np.ones(self.dim) self.highb = self.INFINITY*np.ones(self.dim) self.tourneylist = range(0, self.popsize) self.tourneysize = 2 # works for 2 for now self.bestmemyet = np.zeros(self.dim) # 若是求最大值 if self.min == -1: self.bestfityet = -np.inf else: # 若是求最小值 self.bestfityet = np.inf self.pop_init() def pop_init(self): self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)] for member in self.pop: for i in range(self.dim): member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i]) self.fits = [self.obj(member) for member in self.pop] #self.pop_print() return def setbounds(self, lows, highs): for i in range(self.dim): self.lowb[i] = lows[i] self.highb[i] = highs[i] self.pop_init() return def run(self): for gen in range(self.ngen): print(\"Generation \", gen) self.pop = self.getnewpop() self.eval_pop() #self.pop_print() return [self.bestmemyet, self.bestfityet] def getnewpop(self): newpop = [] #self.tourneylist = range(0, self.popsize) random.shuffle(list(self.tourneylist)) self.tourneypos = 0 for i in range(0, self.popsize, 2): [p1, p2] = self.getparents() #return parents, not just indices [c1, c2] = self.xover(p1, p2) #return children, not just indices c1 = self.mutate(c1) c2 = self.mutate(c2) newpop.append(c1) newpop.append(c2) return newpop def getparents(self): if (self.popsize - self.tourneypos) < self.tourneysize: random.shuffle(list(self.tourneylist)) self.tourneypos = 0 if self.min == -1: if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]): p1 = self.pop[self.tourneylist[self.tourneypos]] else: p1 = self.pop[self.tourneylist[self.tourneypos+1]] else: if (self.fits[self.tourneylist[self.tourneypos]] self.fits[self.tourneylist[self.tourneypos+1]]): p2 = self.pop[self.tourneylist[self.tourneypos]] else: p2 = self.pop[self.tourneylist[self.tourneypos+1]] else: if (self.fits[self.tourneylist[self.tourneypos]] p2: p1, p2 = p2, p1 # p1 must be smaller mean = (p1+p2)*0.5 diff = (p2-p1) dist = max(min(p1-low, high-p2), 0) if (self.RIGID and diff > self.EPSILON): alpha = 1.0 + (2.0*dist/diff) umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0))) seed = umax*random.random() else: seed = random.random() beta = self.getbeta(seed) if (abs(diff*beta) > self.INFINITY): beta = self.INFINITY/diff c2 = mean + beta*0.5*diff c1 = mean - beta*0.5*diff c1 = max(low, min(c1, high)) c2 = max(low, min(c2, high)) return [c1, c2] def getbeta(self, seed): if (1 - seed) < self.EPSILON: seed = 1 - self.EPSILON seed = max(0.0, seed) if seed < 0.5: beta = pow(2.0*seed, (1.0/(self.etac+1.0))) else: beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0))) return beta def getdelta(self, seed, delta_low, delta_high): if seed >= 1.0 - (self.EPSILON/1e3): return delta_high if seed <= (self.EPSILON/1e3): return delta_low if seed <= 0.5: dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0)) delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0 else: dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0)) delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0))) return delta def mutate(self, member): mut_member = np.zeros_like(member) for i in range(member.size): low = self.lowb[i] high = self.highb[i] if random.random() <= self.pm: # pm is simply the prob of a variable to mutate if self.RIGID: value = member[i] delta_low = max((low-value)/(high-low), -1.0) delta_high = min((high-value)/(high-low), 1.0) if abs(delta_low) self.bestfityet: # 則將此最大適應值指為目前為止最佳適應值 self.bestfityet = bestfitness # 並且將最佳族群成員指向目前最佳成員 self.bestmemyet = bestmember else: if bestfitness < self.bestfityet: self.bestfityet = bestfitness self.bestmemyet = bestmember print(\"Current best: \", bestfitness, \"Best yet: \", self.bestfityet) def pop_print(self): for i in range(self.popsize): print(self.pop[i], self.fits[i]) return # 若單獨存在則需導入 GA 所有方法 #import GA #from GA import * import numpy as np def square(x): term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0) term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0) term3 = term1+term2 return term3 # 最大化體積題目 def volume(x): surface = 80.0 z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1])) volume = x[0]*x[1]*z return volume def miniex1(x): '''Minimizing Beale's function (optimal value f(3, 0.5) = 0): ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1) ga.setbounds(np.zeros(10), 10*np.ones(10)) ''' term1 = 1.5 - x[0] + x[0]*x[1] term2 = 2.25 - x[0] + x[0]*x[1]*x[1] term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1] return term1*term1 + term2*term2 + term3*term3 def miniex2(x): '''Schaffer function #2. Minimium at (0,0), equal to 0 ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1) ga.setbounds(np.zeros(10), 10*np.ones(10)) ''' return 0.5 + (pow(sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2) ''' 開始四連桿運算 ''' class Point(object): '''Creates a point on a coordinate plane with values x and y.''' def __init__(self, x, y): '''Defines x and y variables''' self.x = x self.y = y def triangletip_coord(x0, y0, R0, R1, x1, y1, localt): mech_loop = -1 tip_coord = Point(0,0) if (localt >= 0 and localt < pi): # 計算 tip 點的 x 座標 tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0 # 計算 tip 點的 y 座標 tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0 else: # 計算 tip 點的 x 座標 tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0 # 計算 tip 點的 y 座標 tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0 return tip_coord def distance(x0, y0, x1, y1): return sqrt(pow((x1-x0),2) + pow((y1-y0),2)) def rr(L1, dd, theta): return sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta)) # input_angles = [] 也就是必須為 list 且各樹為 NUM_OF_POINTS def mechanism(x0, y0, x1, y1, L1, L2, L3, L5, L6, input_angles): ''' mechanism(0,0,10,0,5,20,10,10,10,input_angles) x0 = 0.0; y0 = 0.0; x1 = 10.0; y1 = 0.0; L1 = 5.0; L2 = 10; L3 = 10; L5 = 10; L6 = 10; ''' link1_tip = Point(0,0) link2_tip = Point(0,0) output_points = list() degree = pi/180. NUM_OF_POINTS = 5 dd_length = distance(x0, y0, x1, y1) # 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5)); for i in range(NUM_OF_POINTS): angle = input_angles[i]*degree rr_length = rr(L1, dd_length, angle) # 第一次三角形疊代 link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle) #print(angle, rr_length, link1_tip.x, link1_tip.y) # 第二次三角形疊代 # 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length)) link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2) # 第三次三角形疊代 (改為以 finaltip_coord() 取值, 而非第三次疊代 ''' triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); ''' # 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負 output_points.append(finaltip_coord(link1_tip, link2_tip, L5, L6)) return output_points def finaltip_coord(tip1_coord, tip2_coord, r1, r2): tip3_coord = Point(0,0) length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2)) length4 = sqrt(pow(r1,2) + pow(r2,2)) theta3 = acos((tip2_coord.x - tip1_coord.x) / length3) theta4 = acos(r1/length4) tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4) tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4) return tip3_coord # 誤差函式 def error_function(output_points, target_points): NUM_OF_POINTS = 5 error = 0 for i in range(NUM_OF_POINTS): error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y)) return error # 組成機構的變數個樹 9 + 通過點數所對應的角度值, 若通過 5 點則共有 14 個變數 # mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points); def fourbar(x): PENALITY = 1000 NUM_OF_POINTS = 10 # x0 與 x1 點位於 -50 與 50 中間, 0, 1, 2, 3 for i in range(4): if(x[i] < -50 or x[i] > 50): return PENALITY # 三個連桿值, 一定要為正, 4, 5, 6, for i in range(4, 7): if(x[i] < 0 or x[i] >50): return PENALITY # L5 L6 可以為 0 或負值, 7, 8 for i in range(7, 9): if(x[i] < -50 or x[i] > 50): return PENALITY # 角度值一定要大於 0 for i in range(NUM_OF_POINTS): if(x[9+i] < 0): return PENALITY result = 0 target_points = list() output_points = list() input_angles = list() # 定義四連桿關鍵點所要通過的點 p1 = Point(1, 1) p2 = Point(2, 2) p3 = Point(3, 3) p4 = Point(4, 4) p5 = Point(5, 5) p6 = Point(6, 6) p7 = Point(7, 7) p8 = Point(8, 8) p9 = Point(9, 9) p10 = Point(10, 10) target_points = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10] for i in range(9, 9+NUM_OF_POINTS): input_angles.append(x[i]) # 這裡要加入查驗各參數是否符合四連桿組成條件 try: output_points = mechanism(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],input_angles) except: return PENALITY result = error_function(output_points, target_points) return result #ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1) # min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化 #ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1) # 請注意 popsize 必須為 4 的倍數 #ga=GA(miniex1, dim=2, popsize=12, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1) ga=GA(fourbar, dim=19, popsize=120000, ngen=10000, pc=0.9, pm=0.5, etac=2, etam=100, min=1) #ga.setbounds(np.zeros(10), 10*np.ones(10)) #ga.setbounds(-10*np.ones(10), 10*np.ones(10)) ga.setbounds(-50*np.ones(20), 50*np.ones(20)) #ga.pop_init() print(ga.run()) 利用 C 與 Differential Evolution 解上述相同問題的原始碼: // 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散?? /*************************************************************** ** ** ** D I F F E R E N T I A L E V O L U T I O N ** ** ** ** Program: de.c ** ** Version: 3.6 ** ** ** ** Authors: Dr. Rainer Storn ** ** c/o ICSI, 1947 Center Street, Suite 600 ** ** Berkeley, CA 94707 ** ** Tel.: 510-642-4274 (extension 192) ** ** Fax.: 510-643-7684 ** ** E-mail: storn@icsi.berkeley.edu ** ** WWW: http://http.icsi.berkeley.edu/~storn/ ** ** on leave from ** ** Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6 ** ** D-81739 Muenchen, Germany ** ** Tel: 636-40502 ** ** Fax: 636-44577 ** ** E-mail: rainer.storn@zfe.siemens.de ** ** ** ** Kenneth Price ** ** 836 Owl Circle ** ** Vacaville, CA 95687 ** ** E-mail: kprice@solano.community.net ** ** ** ** This program implements some variants of Differential ** ** Evolution (DE) as described in part in the techreport ** ** tr-95-012.ps of ICSI. You can get this report either via ** ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z ** ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html* ** A more extended version of tr-95-012.ps is submitted for ** ** publication in the Journal Evolutionary Computation. ** ** ** ** You may use this program for any purpose, give it to any ** ** person or change it according to your needs as long as you ** ** are referring to Rainer Storn and Ken Price as the origi- ** ** nators of the the DE idea. ** ** If you have questions concerning DE feel free to contact ** ** us. We also will be happy to know about your experiences ** ** with DE and your suggestions of improvement. ** ** ** ***************************************************************/ /**H*O*C************************************************************** ** ** ** No.!Version! Date ! Request ! Modification ! Author ** ** ---+-------+------+---------+---------------------------+------- ** ** 1 + 3.1 +5/18/95+ - + strategy DE/rand-to-best/1+ Storn ** ** + + + + included + ** ** 1 + 3.2 +6/06/95+C.Fleiner+ change loops into memcpy + Storn ** ** 2 + 3.2 +6/06/95+ - + update comments + Storn ** ** 1 + 3.3 +6/15/95+ K.Price + strategy DE/best/2 incl. + Storn ** ** 2 + 3.3 +6/16/95+ - + comments and beautifying + Storn ** ** 3 + 3.3 +7/13/95+ - + upper and lower bound for + Storn ** ** + + + + initialization + ** ** 1 + 3.4 +2/12/96+ - + increased printout prec. + Storn ** ** 1 + 3.5 +5/28/96+ - + strategies revisited + Storn ** ** 2 + 3.5 +5/28/96+ - + strategy DE/rand/2 incl. + Storn ** ** 1 + 3.6 +8/06/96+ K.Price + Binomial Crossover added + Storn ** ** 2 + 3.6 +9/30/96+ K.Price + cost variance output + Storn ** ** 3 + 3.6 +9/30/96+ - + alternative to ASSIGND + Storn ** ** 4 + 3.6 +10/1/96+ - + variable checking inserted + Storn ** ** 5 + 3.6 +10/1/96+ - + strategy indic. improved + Storn ** ** ** ***H*O*C*E***********************************************************/ #include \"stdio.h\" #include \"stdlib.h\" #include \"math.h\" #include \"memory.h\" #include <time.h> // 最大族群數, NP #define MAXPOP 5000 // 最大向量維度, D #define MAXDIM 35 #define MAXIMAPROBLEM 0 #define PENALITY 1000 /*------Constants for rnd_uni()--------------------------------------------*/ #define IM1 2147483563 #define IM2 2147483399 #define AM (1.0/IM1) #define IMM1 (IM1-1) #define IA1 40014 #define IA2 40692 #define IQ1 53668 #define IQ2 52774 #define IR1 12211 #define IR2 3791 #define NTAB 32 #define NDIV (1+IMM1/NTAB) #define EPS 1.2e-7 #define RNMX (1.0-EPS) // 與機構合成相關的常數定義 #define PI 3.1415926 #define degree PI/180.0 #define mech_loop -1 #define NUM_OF_POINTS 10 /*------------------------Macros----------------------------------------*/ /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */ /* quick copy by Claudio */ /* works only for small */ /* arrays, but is faster.*/ /*------------------------Globals---------------------------------------*/ long rnd_uni_init; /* serves as a seed for rnd_uni() */ double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM]; double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM]; /*---------Function declarations----------------------------------------*/ void assignd(int D, double a[], double b[]); double rnd_uni(long *idum); /* uniform pseudo random number generator */ double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */ // 與機構合成相關的函式宣告 double distance(double x0, double y0, double x1, double y1); double rr(double L1, double dd, double theta); struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt); void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]); double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]); struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2); /*---------Function definitions-----------------------------------------*/ // 指定向量 b 為 a void assignd(int D, double a[], double b[]) /**C*F**************************************************************** ** ** ** Assigns D-dimensional vector b to vector a. ** ** You might encounter problems with the macro ASSIGND on some ** ** machines. If yes, better use this function although it's slower. ** ** ** ***C*F*E*************************************************************/ { int j; for (j=0; j<D; j++) { a[j] = b[j]; } } // 產生 0 ~ 1 間的亂數 double rnd_uni(long *idum) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :rnd_uni() ** ** LONG_NAME :random_uniform ** ** AUTHOR :(see below) ** ** ** ** DESCRIPTION :rnd_uni() generates an equally distributed ran- ** ** dom number in the interval [0,1]. For further ** ** reference see Press, W.H. et alii, Numerical ** ** Recipes in C, Cambridge University Press, 1992. ** ** ** ** FUNCTIONS :none ** ** ** ** GLOBALS :none ** ** ** ** PARAMETERS :*idum serves as a seed value ** ** ** ** PRECONDITIONS :*idum must be negative on the first call. ** ** ** ** POSTCONDITIONS :*idum will be changed ** ** ** ***C*F*E*************************************************************/ { long j; long k; static long idum2=123456789; static long iy=0; static long iv[NTAB]; double temp; if (*idum <= 0) { if (-(*idum) < 1) *idum=1; else *idum = -(*idum); idum2=(*idum); for (j=NTAB+7;j>=0;j--) { k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; if (j < NTAB) iv[j] = *idum; } iy=iv[0]; } k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; k=idum2/IQ2; idum2=IA2*(idum2-k*IQ2)-k*IR2; if (idum2 < 0) idum2 += IM2; j=iy/NDIV; iy=iv[j]-idum2; iv[j] = *idum; if (iy < 1) iy += IMM1; if ((temp=AM*iy) > RNMX) return RNMX; else return temp; }/*------End of rnd_uni()--------------------------*/ // 將上下限轉為全域變數 double inibound_h; /* upper parameter bound */ double inibound_l; /* lower parameter bound */ // 與機構合成相關的全域變數 // 宣告一個座標結構 struct Coord { double x; double y; // 這裡保留 double z; }; main(int argc, char *argv[]) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :main() ** ** LONG_NAME :main program ** ** AUTHOR :Rainer Storn, Kenneth Price ** ** ** ** DESCRIPTION :driver program for differential evolution. ** ** ** ** FUNCTIONS :rnd_uni(), evaluate(), printf(), fprintf(), ** ** fopen(), fclose(), fscanf(). ** ** ** ** GLOBALS :rnd_uni_init input variable for rnd_uni() ** ** ** ** PARAMETERS :argc #arguments = 3 ** ** argv pointer to argument strings ** ** ** ** PRECONDITIONS :main must be called with three parameters ** ** e.g. like de1 <input-file> <output-file>, if ** ** the executable file is called de1. ** ** The input file must contain valid inputs accor- ** ** ding to the fscanf() section of main(). ** ** ** ** POSTCONDITIONS :main() produces consecutive console outputs and ** ** writes the final results in an output file if ** ** the program terminates without an error. ** ** ** ***C*F*E*************************************************************/ { char chr; /* y/n choice variable */ char *strat[] = /* strategy-indicator */ { \"\", \"DE/best/1/exp\", \"DE/rand/1/exp\", \"DE/rand-to-best/1/exp\", \"DE/best/2/exp\", \"DE/rand/2/exp\", \"DE/best/1/bin\", \"DE/rand/1/bin\", \"DE/rand-to-best/1/bin\", \"DE/best/2/bin\", \"DE/rand/2/bin\" }; int i, j, L, n; /* counting variables */ int r1, r2, r3, r4; /* placeholders for random indexes */ int r5; /* placeholders for random indexes */ int D; /* Dimension of parameter vector */ int NP; /* number of population members */ int imin; /* index to member with lowest energy */ int refresh; /* refresh rate of screen output */ int strategy; /* choice parameter for screen output */ int gen, genmax, seed; long nfeval; /* number of function evaluations */ double trial_cost; /* buffer variable */ // 將上下限轉為全域變數, 可能要根據各變數加以設定 //double inibound_h; /* upper parameter bound */ //double inibound_l; /* lower parameter bound */ double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members */ double cost[MAXPOP]; /* obj. funct. values */ double cvar; /* computes the cost variance */ double cmean; /* mean cost */ double F,CR; /* control variables of DE */ double cmin; /* help variables */ FILE *fpin_ptr; FILE *fpout_ptr; // 計算執行過程所需時間起點, 需要導入 time.h clock_t start = clock(); /*------Initializations----------------------------*/ //if (argc != 3) /* number of arguments */ //{ //printf(\"\\nUsage : de <input-file> <output-file>\\n\"); //exit(1); //} // 將結果寫入 out.dat fpout_ptr = fopen(\"out.dat\",\"w\"); /* open output file for reading, */ /* to see whether it already exists */ /* if ( fpout_ptr != NULL ) { printf(\"\\nOutput file %s does already exist, \\ntype y if you \",argv[2]); printf(\"want to overwrite it, \\nanything else if you want to exit.\\n\"); chr = (char)getchar(); if ((chr != 'y') && (chr != 'Y')) { exit(1); } fclose(fpout_ptr); } */ /*-----Read input data------------------------------------------------*/ //fpin_ptr = fopen(argv[1],\"r\"); /* if (fpin_ptr == NULL) { printf(\"\\nCannot open input file\\n\"); exit(1); }*/ //fscanf(fpin_ptr,\"%d\",&strategy); /*---choice of strategy-----------------*/ //fscanf(fpin_ptr,\"%d\",&genmax); /*---maximum number of generations------*/ //fscanf(fpin_ptr,\"%d\",&refresh); /*---output refresh cycle---------------*/ //fscanf(fpin_ptr,\"%d\",&D); /*---number of parameters---------------*/ //fscanf(fpin_ptr,\"%d\",&NP); /*---population size.-------------------*/ //fscanf(fpin_ptr,\"%lf\",&inibound_h); /*---upper parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&inibound_l); /*---lower parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&F); /*---weight factor----------------------*/ //fscanf(fpin_ptr,\"%lf\",&CR); /*---crossing over factor---------------*/ //fscanf(fpin_ptr,\"%d\",&seed); /*---random seed------------------------*/ // 目前已經採用 strategy 3 可以得到最佳結果 strategy = 3; genmax = 2000; refresh = 100; // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值 D = 19; NP = 200; inibound_h = 50.; inibound_l = 0.; /*得到最佳解 F = 0.85; CR 必須介於 0 to 1. 之間 CR = 1.; */ F = 0.85; CR = 1.; seed = 3; //fclose(fpin_ptr); /*-----Checking input variables for proper range----------------------------*/ if (D > MAXDIM) { printf(\"\\nError! D=%d > MAXDIM=%d\\n\",D,MAXDIM); exit(1); } if (D <= 0) { printf(\"\\nError! D=%d, should be > 0\\n\",D); exit(1); } if (NP > MAXPOP) { printf(\"\\nError! NP=%d > MAXPOP=%d\\n\",NP,MAXPOP); exit(1); } if (NP <= 0) { printf(\"\\nError! NP=%d, should be > 0\\n\",NP); exit(1); } if ((CR < 0) || (CR > 1.0)) { printf(\"\\nError! CR=%f, should be ex [0,1]\\n\",CR); exit(1); } if (seed <= 0) { printf(\"\\nError! seed=%d, should be > 0\\n\",seed); exit(1); } if (refresh <= 0) { printf(\"\\nError! refresh=%d, should be > 0\\n\",refresh); exit(1); } if (genmax <= 0) { printf(\"\\nError! genmax=%d, should be > 0\\n\",genmax); exit(1); } if ((strategy < 0) || (strategy > 10)) { printf(\"\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n\",strategy); exit(1); } if (inibound_h < inibound_l) { printf(\"\\nError! inibound_h=%f < inibound_l=%f\\n\",inibound_h, inibound_l); exit(1); } /*-----Open output file-----------------------------------------------*/ //fpout_ptr = fopen(argv[2],\"w\"); /* open output file for writing */ //if (fpout_ptr == NULL) //{ //printf(\"\\nCannot open output file\\n\"); //exit(1); //} /*-----Initialize random number generator-----------------------------*/ rnd_uni_init = -(long)seed; /* initialization of rnd_uni() */ nfeval = 0; /* reset number of function evaluations */ /*------Initialization------------------------------------------------*/ /*------Right now this part is kept fairly simple and just generates--*/ /*------random numbers in the range [-initfac, +initfac]. You might---*/ /*------want to extend the init part such that you can initialize-----*/ /*------each parameter separately.------------------------------------*/ for (i=0; i<NP; i++) { for (j=0; j<D; j++) /* spread initial population members */ { c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l); } cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */ } cmin = cost[0]; imin = 0; for (i=1; i<NP; i++) { if(MAXIMAPROBLEM == 1) { // 改為最大化 if (cost[i]>cmin) { cmin = cost[i]; imin = i; } } else { // 最小化問題 if (cost[i]<cmin) { cmin = cost[i]; imin = i; } } } assignd(D,best,c[imin]); /* save best member ever */ assignd(D,bestit,c[imin]); /* save best member of generation */ pold = &c; /* old population (generation G) */ pnew = &d; /* new population (generation G+1) */ /*=======================================================================*/ /*=========Iteration loop================================================*/ /*=======================================================================*/ gen = 0; /* generation counter reset */ while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */ { /* is accepted by compiler */ gen++; imin = 0; for (i=0; i<NP; i++) /* Start of loop through ensemble */ { do /* Pick a random population member */ { /* Endless loop for NP < 2 !!! */ r1 = (int)(rnd_uni(&rnd_uni_init)*NP); }while(r1==i); do /* Pick a random population member */ { /* Endless loop for NP < 3 !!! */ r2 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r2==i) || (r2==r1)); do /* Pick a random population member */ { /* Endless loop for NP < 4 !!! */ r3 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r3==i) || (r3==r1) || (r3==r2)); do /* Pick a random population member */ { /* Endless loop for NP < 5 !!! */ r4 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3)); do /* Pick a random population member */ { /* Endless loop for NP < 6 !!! */ r5 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4)); /*=======Choice of strategy===============================================================*/ /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/ /*=======DE : stands for Differential Evolution==========================================*/ /*=======x : a string which denotes the vector to be perturbed==========================*/ /*=======y : number of difference vectors taken for perturbation of x===================*/ /*=======z : crossover method (exp = exponential, bin = binomial)=======================*/ /* */ /*=======There are some simple rules which are worth following:===========================*/ /*=======1) F is usually between 0.5 and 1 (in rare cases > 1)===========================*/ /*=======2) CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/ /*=======3) To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/ /* happens. */ /*=======4) If you increase NP, F usually has to be decreased============================*/ /*=======5) When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/ /*=======EXPONENTIAL CROSSOVER============================================================*/ /*-------DE/best/1/exp--------------------------------------------------------------------*/ /*-------Our oldest strategy but still not bad. However, we have found several------------*/ /*-------optimization problems where misconvergence occurs.-------------------------------*/ if (strategy == 1) /* strategy DE0 (not in our paper) */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/1/exp-------------------------------------------------------------------*/ /*-------This is one of my favourite strategies. It works especially well when the-------*/ /*-------\"bestit[]\"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/ /*-------as a first guess.---------------------------------------------------------------*/ else if (strategy == 2) /* strategy DE1 in the techreport */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/ /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/ /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/ /*-------should play around with all three control variables.----------------------------*/ else if (strategy == 3) /* similiar to DE2 but generally better */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/ else if (strategy == 4) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/ else if (strategy == 5) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/ /*-------DE/best/1/bin--------------------------------------------------------------------*/ else if (strategy == 6) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand/1/bin-------------------------------------------------------------------*/ else if (strategy == 7) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/ else if (strategy == 8) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); } n = (n+1)%D; } } /*-------DE/best/2/bin--------------------------------------------------------------------*/ else if (strategy == 9) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*-------DE/rand/2/bin--------------------------------------------------------------------*/ else { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/ trial_cost = evaluate(D,tmp,&nfeval); /* Evaluate new vector in tmp[] */ if(MAXIMAPROBLEM == 1) { // 改為最大化 if (trial_cost >= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost>cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } else { // 最小化問題 if (trial_cost <= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost<cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } } /* End mutation loop through pop. */ assignd(D,bestit,best); /* Save best population member of current iteration */ /* swap population arrays. New generation becomes old one */ pswap = pold; pold = pnew; pnew = pswap; /*----Compute the energy variance (just for monitoring purposes)-----------*/ cmean = 0.; /* compute the mean value first */ for (j=0; j<NP; j++) { cmean += cost[j]; } cmean = cmean/NP; cvar = 0.; /* now the variance */ for (j=0; j<NP; j++) { cvar += (cost[j] - cmean)*(cost[j] - cmean); } cvar = cvar/(NP-1); /*----Output part----------------------------------------------------------*/ if (gen%refresh==1) /* display after every refresh generations */ { /* ABORT works only if conio.h is accepted by your compiler */ printf(\"\\n\\n PRESS ANY KEY TO ABORT\"); printf(\"\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n\",cmin); for (j=0;j<D;j++) { printf(\"\\n best[%d]=%-15.10g\",j,best[j]); } printf(\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); printf(\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); } fprintf(fpout_ptr,\"%ld %-15.10g\\n\",nfeval,cmin); } /*=======================================================================*/ /*=========End of iteration loop=========================================*/ /*=======================================================================*/ /*-------Final output in file-------------------------------------------*/ fprintf(fpout_ptr,\"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n\",cmin); for (j=0;j<D;j++) { fprintf(fpout_ptr,\"\\n best[%d]=%-15.10g\",j,best[j]); } fprintf(fpout_ptr,\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); fprintf(fpout_ptr,\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); fclose(fpout_ptr); /* Code you want timed here */ printf(\"Time elapsed: %f\\n\", ((double)clock() - start) / CLOCKS_PER_SEC); return(0); } /*-----------End of main()------------------------------------------*/ // 適應函式 fittness function (cost function) double evaluate(int D, double tmp[], long *nfeval) { // 先處理通過 5 個點的四連桿問題 // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1] // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3] // L1 為第一桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[4] // L2 為第二桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[5] // L3 為第三桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[6] // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值) // L5, L6 必須 > 0, 且小於 100 - 設為 tmp[7], tmp[8] // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33 // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13] // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值 // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化 /* void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/ struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS]; double input_angles[NUM_OF_POINTS], result; int i; (*nfeval)++; target_points[0].x = 1.0; target_points[0].y = 1.0; target_points[1].x = 2.0; target_points[1].y = 2.0; target_points[2].x = 3.0; target_points[2].y = 3.0; target_points[3].x = 4.0; target_points[3].y = 4.0; target_points[4].x = 5.0; target_points[4].y = 5.0; target_points[5].x = 6.0; target_points[5].y = 6.0; target_points[6].x = 7.0; target_points[6].y = 7.0; target_points[7].x = 8.0; target_points[7].y = 8.0; target_points[8].x = 9.0; target_points[8].y = 9.0; target_points[9].x = 10.0; target_points[9].y = 10.0; // 輸入角度值與 tmp[] 的設定 for(i = 0; i < NUM_OF_POINTS; i++) { input_angles[i] = tmp[i + 9]; } // 呼叫 mechanism() 以便計算 output_points[] mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points); // for debug /* if(*nfeval%3000 == 0) { for(i = 0; i < NUM_OF_POINTS; i++) { printf(\"%-15.10g : %-15.10g\\n\", output_points[i].x, output_points[i].y); } printf(\"#####################################\\n\"); } */ // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost result = error_function(output_points, target_points); // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result // x0 與 x1 點位於 -500 與 500 中間 for(i = 0; i < 4; i++) { if(tmp[i] < -50 || tmp[i] > 50){ return PENALITY; } } // 三個連桿值, 一定要為正 for(i = 4; i < 7; i++) { if(tmp[i] < 0 || tmp[i] > 50){ return PENALITY; } } // L5 L6 可以為 0 或負值 for(i = 7; i < 9; i++) { if(tmp[i] < -50 || tmp[i] > 50){ return PENALITY; } } // 角度值一定要大於 0 for(i = 1; i <= NUM_OF_POINTS; i++) { if((tmp[D-i] < 0)){ return PENALITY; } } return result; /* double result=0, surface = 80.0, z, volume, penality; (*nfeval)++; z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1])); volume = tmp[0]*tmp[1]*z; if(volume <= 0){ return PENALITY; } if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){ return PENALITY; } if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){ return PENALITY; } // volume must >0 and max volume // 目前為最小化問題 return 1+1/(volume*volume); */ } struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt) { struct Coord tip_coord; if (localt>=0 && localt <PI) { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的 sqrt 替換成 sqrtt, 以防止被 maxima 中的 subst(\"&#94;\"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼. tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0; } else { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+ pow(x1-x0,2))/2)+x0; } // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題. if (localt>=0 && localt <PI) { tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ // 利用 sqrtt 居中進行代換所得到的式子 pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } else { tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } return tip_coord; } double distance(double x0, double y0, double x1, double y1) { double distance_value; distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2)); return distance_value; } double rr(double L1, double dd, double theta) { double rr_value; rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta)); return rr_value; } // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS] void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]) { // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置 // 以下為可能的處理變數宣告 // 這裡希望能夠定義一個 struct 來處理座標點 double rr_length, dd_length, angle; struct Coord link1_tip, link2_tip, triangle_tip; double angle2, angle3; int i; // 開始進行三角形頂點座標的計算 // 以下變數由每一個體向量提供 /* x0 = 0.0; y0 = 0.0; x1 = 10.0; y1 = 0.0; L1 = 5.0; L2 = 20; L3 = 10; L5 = 10; L6 = 10; */ dd_length = distance(x0, y0, x1, y1); /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */ angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5)); for(i = 0; i < NUM_OF_POINTS; i++) { // 先建立第一點座標, 即 i=0 者 // i=0; // angle = i*degree; /* // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準 if(i > 0) { input_angles[i] = input_angles[i] + input_angles[i-1]; } */ angle = input_angles[i]*degree; rr_length = rr(L1, dd_length, angle); // 第一次三角形疊代 link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle); // 第二次三角形疊代 /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */ angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length)); link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2); // 第三次三角形疊代 //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負 output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6); } } double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]) { double error = 0.0; int i; for(i = 0; i < NUM_OF_POINTS; i++) { error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y)); } return error; } struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2) { struct Coord tip3_coord; double theta3, theta4, length3, length4; length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2)); length4 = sqrt(pow(r1,2) + pow(r2,2)); theta3 = acos((tip2_coord.x - tip1_coord.x) / length3); theta4 = acos(r1 / length4); tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4); tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4); return tip3_coord; } 為了要讓 C 程式碼可以在 Pelican 網誌 Markdown 格式編輯模式下能夠與 highlight 套件結合, 首先程式碼中的所有大於與小於符號必須轉為 html special charactor 之外, 還要全部內縮, 否則內容將會在 Pelican 轉換過程中被視為 html 而自動加入錯誤的標註符號. 以下則為 de 25 點四連桿尺寸合成參考程式: /*************************************************************** ** ** ** D I F F E R E N T I A L E V O L U T I O N ** ** ** ** Program: de.c ** ** Version: 3.6 ** ** ** ** Authors: Dr. Rainer Storn ** ** c/o ICSI, 1947 Center Street, Suite 600 ** ** Berkeley, CA 94707 ** ** Tel.: 510-642-4274 (extension 192) ** ** Fax.: 510-643-7684 ** ** E-mail: storn@icsi.berkeley.edu ** ** WWW: http://http.icsi.berkeley.edu/~storn/ ** ** on leave from ** ** Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6 ** ** D-81739 Muenchen, Germany ** ** Tel: 636-40502 ** ** Fax: 636-44577 ** ** E-mail: rainer.storn@zfe.siemens.de ** ** ** ** Kenneth Price ** ** 836 Owl Circle ** ** Vacaville, CA 95687 ** ** E-mail: kprice@solano.community.net ** ** ** ** This program implements some variants of Differential ** ** Evolution (DE) as described in part in the techreport ** ** tr-95-012.ps of ICSI. You can get this report either via ** ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z ** ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html* ** A more extended version of tr-95-012.ps is submitted for ** ** publication in the Journal Evolutionary Computation. ** ** ** ** You may use this program for any purpose, give it to any ** ** person or change it according to your needs as long as you ** ** are referring to Rainer Storn and Ken Price as the origi- ** ** nators of the the DE idea. ** ** If you have questions concerning DE feel free to contact ** ** us. We also will be happy to know about your experiences ** ** with DE and your suggestions of improvement. ** ** ** ***************************************************************/ /**H*O*C************************************************************** ** ** ** No.!Version! Date ! Request ! Modification ! Author ** ** ---+-------+------+---------+---------------------------+------- ** ** 1 + 3.1 +5/18/95+ - + strategy DE/rand-to-best/1+ Storn ** ** + + + + included + ** ** 1 + 3.2 +6/06/95+C.Fleiner+ change loops into memcpy + Storn ** ** 2 + 3.2 +6/06/95+ - + update comments + Storn ** ** 1 + 3.3 +6/15/95+ K.Price + strategy DE/best/2 incl. + Storn ** ** 2 + 3.3 +6/16/95+ - + comments and beautifying + Storn ** ** 3 + 3.3 +7/13/95+ - + upper and lower bound for + Storn ** ** + + + + initialization + ** ** 1 + 3.4 +2/12/96+ - + increased printout prec. + Storn ** ** 1 + 3.5 +5/28/96+ - + strategies revisited + Storn ** ** 2 + 3.5 +5/28/96+ - + strategy DE/rand/2 incl. + Storn ** ** 1 + 3.6 +8/06/96+ K.Price + Binomial Crossover added + Storn ** ** 2 + 3.6 +9/30/96+ K.Price + cost variance output + Storn ** ** 3 + 3.6 +9/30/96+ - + alternative to ASSIGND + Storn ** ** 4 + 3.6 +10/1/96+ - + variable checking inserted + Storn ** ** 5 + 3.6 +10/1/96+ - + strategy indic. improved + Storn ** ** ** ***H*O*C*E***********************************************************/ #include \"stdio.h\" #include \"stdlib.h\" #include \"math.h\" #include \"memory.h\" #include <time.h> // 最大族群數, NP #define MAXPOP 5000 // 最大向量維度, D #define MAXDIM 60 // 1 為最大化問題, 0 為最小化問題 #define MAXIMAPROBLEM 0 // 可能要配合最大或最小化進行變號 #define PENALITY 1.0E20 /*------Constants for rnd_uni()--------------------------------------------*/ #define IM1 2147483563 #define IM2 2147483399 #define AM (1.0/IM1) #define IMM1 (IM1-1) #define IA1 40014 #define IA2 40692 #define IQ1 53668 #define IQ2 52774 #define IR1 12211 #define IR2 3791 #define NTAB 32 #define NDIV (1+IMM1/NTAB) #define EPS 1.2e-7 #define RNMX (1.0-EPS) // 與機構合成相關的常數定義 #define PI 3.1415926 #define degree PI/180.0 #define mech_loop -1 #define NUM_OF_POINTS 25 /*------------------------Macros----------------------------------------*/ /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */ /* quick copy by Claudio */ /* works only for small */ /* arrays, but is faster.*/ /*------------------------Globals---------------------------------------*/ long rnd_uni_init; /* serves as a seed for rnd_uni() */ double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM]; double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM]; /*---------Function declarations----------------------------------------*/ void assignd(int D, double a[], double b[]); double rnd_uni(long *idum); /* uniform pseudo random number generator */ double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */ // 與機構合成相關的函式宣告 double distance(double x0, double y0, double x1, double y1); double rr(double L1, double dd, double theta); struct Coord triangletip_coord(double x0, double y0, double R0, double R1, double x1, double y1, double localt); void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]); double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]); // 用來利用 tip1 與 tip2 的座標, 以及 r1, r2 求最後的三角形頂點座標 struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2); /*---------Function definitions-----------------------------------------*/ // 指定向量 b 為 a void assignd(int D, double a[], double b[]) /**C*F**************************************************************** ** ** ** Assigns D-dimensional vector b to vector a. ** ** You might encounter problems with the macro ASSIGND on some ** ** machines. If yes, better use this function although it's slower. ** ** ** ***C*F*E*************************************************************/ { int j; for (j=0; j<D; j++) { a[j] = b[j]; } } // 產生 0 ~ 1 間的亂數 double rnd_uni(long *idum) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :rnd_uni() ** ** LONG_NAME :random_uniform ** ** AUTHOR :(see below) ** ** ** ** DESCRIPTION :rnd_uni() generates an equally distributed ran- ** ** dom number in the interval [0,1]. For further ** ** reference see Press, W.H. et alii, Numerical ** ** Recipes in C, Cambridge University Press, 1992. ** ** ** ** FUNCTIONS :none ** ** ** ** GLOBALS :none ** ** ** ** PARAMETERS :*idum serves as a seed value ** ** ** ** PRECONDITIONS :*idum must be negative on the first call. ** ** ** ** POSTCONDITIONS :*idum will be changed ** ** ** ***C*F*E*************************************************************/ { long j; long k; static long idum2=123456789; static long iy=0; static long iv[NTAB]; double temp; if (*idum <= 0) { if (-(*idum) < 1) *idum=1; else *idum = -(*idum); idum2=(*idum); for (j=NTAB+7;j>=0;j--) { k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; if (j < NTAB) iv[j] = *idum; } iy=iv[0]; } k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; k=idum2/IQ2; idum2=IA2*(idum2-k*IQ2)-k*IR2; if (idum2 < 0) idum2 += IM2; j=iy/NDIV; iy=iv[j]-idum2; iv[j] = *idum; if (iy < 1) iy += IMM1; if ((temp=AM*iy) > RNMX) return RNMX; else return temp; }/*------End of rnd_uni()--------------------------*/ // 將上下限轉為全域變數 double inibound_h; /* upper parameter bound */ double inibound_l; /* lower parameter bound */ // 與機構合成相關的全域變數 // 宣告一個座標結構 struct Coord { double x; double y; // 這裡保留 double z; }; int main(int argc, char *argv[]) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :main() ** ** LONG_NAME :main program ** ** AUTHOR :Rainer Storn, Kenneth Price ** ** ** ** DESCRIPTION :driver program for differential evolution. ** ** ** ** FUNCTIONS :rnd_uni(), evaluate(), printf(), fprintf(), ** ** fopen(), fclose(), fscanf(). ** ** ** ** GLOBALS :rnd_uni_init input variable for rnd_uni() ** ** ** ** PARAMETERS :argc #arguments = 3 ** ** argv pointer to argument strings ** ** ** ** PRECONDITIONS :main must be called with three parameters ** ** e.g. like de1 <input-file> <output-file>, if ** ** the executable file is called de1. ** ** The input file must contain valid inputs accor- ** ** ding to the fscanf() section of main(). ** ** ** ** POSTCONDITIONS :main() produces consecutive console outputs and ** ** writes the final results in an output file if ** ** the program terminates without an error. ** ** ** ***C*F*E*************************************************************/ { char chr; /* y/n choice variable */ char *strat[] = /* strategy-indicator */ { \"\", \"DE/best/1/exp\", \"DE/rand/1/exp\", \"DE/rand-to-best/1/exp\", \"DE/best/2/exp\", \"DE/rand/2/exp\", \"DE/best/1/bin\", \"DE/rand/1/bin\", \"DE/rand-to-best/1/bin\", \"DE/best/2/bin\", \"DE/rand/2/bin\" }; int i, j, L, n; /* counting variables */ int r1, r2, r3, r4; /* placeholders for random indexes */ int r5; /* placeholders for random indexes */ int D; /* Dimension of parameter vector */ int NP; /* number of population members */ int imin; /* index to member with lowest energy */ int refresh; /* refresh rate of screen output */ int strategy; /* choice parameter for screen output */ int gen, genmax, seed; long nfeval; /* number of function evaluations */ double trial_cost; /* buffer variable */ // 將上下限轉為全域變數, 可能要根據各變數加以設定 //double inibound_h; /* upper parameter bound */ //double inibound_l; /* lower parameter bound */ double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members */ double cost[MAXPOP]; /* obj. funct. values */ double cvar; /* computes the cost variance */ double cmean; /* mean cost */ double F,CR; /* control variables of DE */ double cmin; /* help variables */ FILE *fpin_ptr; FILE *fpout_ptr; // 計算執行過程所需時間起點, 需要導入 time.h clock_t start = clock(); /*------Initializations----------------------------*/ //if (argc != 3) /* number of arguments */ //{ //printf(\"\\nUsage : de <input-file> <output-file>\\n\"); //exit(1); //} // 將結果寫入 out.dat fpout_ptr = fopen(\"out.dat\",\"w\"); /* open output file for reading, */ /* to see whether it already exists */ /* if ( fpout_ptr != NULL ) { printf(\"\\nOutput file %s does already exist, \\ntype y if you \",argv[2]); printf(\"want to overwrite it, \\nanything else if you want to exit.\\n\"); chr = (char)getchar(); if ((chr != 'y') && (chr != 'Y')) { exit(1); } fclose(fpout_ptr); } */ /*-----Read input data------------------------------------------------*/ //fpin_ptr = fopen(argv[1],\"r\"); /* if (fpin_ptr == NULL) { printf(\"\\nCannot open input file\\n\"); exit(1); }*/ //fscanf(fpin_ptr,\"%d\",&strategy); /*---choice of strategy-----------------*/ //fscanf(fpin_ptr,\"%d\",&genmax); /*---maximum number of generations------*/ //fscanf(fpin_ptr,\"%d\",&refresh); /*---output refresh cycle---------------*/ //fscanf(fpin_ptr,\"%d\",&D); /*---number of parameters---------------*/ //fscanf(fpin_ptr,\"%d\",&NP); /*---population size.-------------------*/ //fscanf(fpin_ptr,\"%lf\",&inibound_h); /*---upper parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&inibound_l); /*---lower parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&F); /*---weight factor----------------------*/ //fscanf(fpin_ptr,\"%lf\",&CR); /*---crossing over factor---------------*/ //fscanf(fpin_ptr,\"%d\",&seed); /*---random seed------------------------*/ strategy = 3; genmax = 200000; // refresh 為每幾筆運算後進行資料列印 refresh = 100; // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 25 (NUM_OF_POINTS) 個通過點角度值 // tmp[0~8] 為機構尺寸, tmp[9~33] 為通過點角度值 D = 9 + NUM_OF_POINTS; NP = 200; // 機構變數值上限 inibound_h = 50.; // 機構變數值下限 inibound_l = 0.; // for strategy 1, F=0.9, CR = 1. // for strategy 2 F=0.7, CR=0.5 // 一個小時得到 9.7 的誤差 // 25 點的題目, 若 penality 只取 1000 則 F = 0.7 似乎為 最大 bound for strategy 1, CR = 1. F = 0.85; CR = 0.7; seed = 3; //fclose(fpin_ptr); /*-----Checking input variables for proper range----------------------------*/ if (D > MAXDIM) { printf(\"\\nError! D=%d > MAXDIM=%d\\n\",D,MAXDIM); exit(1); } if (D <= 0) { printf(\"\\nError! D=%d, should be > 0\\n\",D); exit(1); } if (NP > MAXPOP) { printf(\"\\nError! NP=%d > MAXPOP=%d\\n\",NP,MAXPOP); exit(1); } if (NP <= 0) { printf(\"\\nError! NP=%d, should be > 0\\n\",NP); exit(1); } if ((CR < 0) || (CR > 1.0)) { printf(\"\\nError! CR=%f, should be ex [0,1]\\n\",CR); exit(1); } if (seed <= 0) { printf(\"\\nError! seed=%d, should be > 0\\n\",seed); exit(1); } if (refresh <= 0) { printf(\"\\nError! refresh=%d, should be > 0\\n\",refresh); exit(1); } if (genmax <= 0) { printf(\"\\nError! genmax=%d, should be > 0\\n\",genmax); exit(1); } if ((strategy < 0) || (strategy > 10)) { printf(\"\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n\",strategy); exit(1); } if (inibound_h < inibound_l) { printf(\"\\nError! inibound_h=%f < inibound_l=%f\\n\",inibound_h, inibound_l); exit(1); } /*-----Open output file-----------------------------------------------*/ //fpout_ptr = fopen(argv[2],\"w\"); /* open output file for writing */ //if (fpout_ptr == NULL) //{ //printf(\"\\nCannot open output file\\n\"); //exit(1); //} /*-----Initialize random number generator-----------------------------*/ rnd_uni_init = -(long)seed; /* initialization of rnd_uni() */ nfeval = 0; /* reset number of function evaluations */ /*------Initialization------------------------------------------------*/ /*------Right now this part is kept fairly simple and just generates--*/ /*------random numbers in the range [-initfac, +initfac]. You might---*/ /*------want to extend the init part such that you can initialize-----*/ /*------each parameter separately.------------------------------------*/ for (i=0; i<NP; i++) { for (j=0; j<D; j++) /* spread initial population members */ { c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l); } cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */ } cmin = cost[0]; imin = 0; for (i=1; i<NP; i++) { if(MAXIMAPROBLEM == 1) { // 最大化問題 if (cost[i]>cmin) { cmin = cost[i]; imin = i; } } else { // 最小化問題 if (cost[i]<cmin) { cmin = cost[i]; imin = i; } } } assignd(D,best,c[imin]); /* save best member ever */ assignd(D,bestit,c[imin]); /* save best member of generation */ pold = &c; /* old population (generation G) */ pnew = &d; /* new population (generation G+1) */ /*=======================================================================*/ /*=========Iteration loop================================================*/ /*=======================================================================*/ gen = 0; /* generation counter reset */ while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */ { /* is accepted by compiler */ gen++; imin = 0; for (i=0; i<NP; i++) /* Start of loop through ensemble */ { do /* Pick a random population member */ { /* Endless loop for NP < 2 !!! */ r1 = (int)(rnd_uni(&rnd_uni_init)*NP); }while(r1==i); do /* Pick a random population member */ { /* Endless loop for NP < 3 !!! */ r2 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r2==i) || (r2==r1)); do /* Pick a random population member */ { /* Endless loop for NP < 4 !!! */ r3 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r3==i) || (r3==r1) || (r3==r2)); do /* Pick a random population member */ { /* Endless loop for NP < 5 !!! */ r4 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3)); do /* Pick a random population member */ { /* Endless loop for NP < 6 !!! */ r5 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4)); /*=======Choice of strategy===============================================================*/ /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/ /*=======DE : stands for Differential Evolution==========================================*/ /*=======x : a string which denotes the vector to be perturbed==========================*/ /*=======y : number of difference vectors taken for perturbation of x===================*/ /*=======z : crossover method (exp = exponential, bin = binomial)=======================*/ /* */ /*=======There are some simple rules which are worth following:===========================*/ /*=======1) F is usually between 0.5 and 1 (in rare cases > 1)===========================*/ /*=======2) CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/ /*=======3) To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/ /* happens. */ /*=======4) If you increase NP, F usually has to be decreased============================*/ /*=======5) When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/ /*=======EXPONENTIAL CROSSOVER============================================================*/ /*-------DE/best/1/exp--------------------------------------------------------------------*/ /*-------Our oldest strategy but still not bad. However, we have found several------------*/ /*-------optimization problems where misconvergence occurs.-------------------------------*/ // 1 為最原始的解題邏輯方法 if (strategy == 1) /* strategy DE0 (not in our paper) */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/1/exp-------------------------------------------------------------------*/ /*-------This is one of my favourite strategies. It works especially well when the-------*/ /*-------\"bestit[]\"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/ /*-------as a first guess.---------------------------------------------------------------*/ // 配合邏輯方法 2 選用 R=0.7, CR=0.5 else if (strategy == 2) /* strategy DE1 in the techreport */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/ /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/ /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/ /*-------should play around with all three control variables.----------------------------*/ // 方法 3 建議 F=0.85 CR=1. else if (strategy == 3) /* similiar to DE2 but generally better */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/ else if (strategy == 4) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/ else if (strategy == 5) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/ /*-------DE/best/1/bin--------------------------------------------------------------------*/ else if (strategy == 6) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand/1/bin-------------------------------------------------------------------*/ else if (strategy == 7) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/ else if (strategy == 8) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); } n = (n+1)%D; } } /*-------DE/best/2/bin--------------------------------------------------------------------*/ else if (strategy == 9) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*-------DE/rand/2/bin--------------------------------------------------------------------*/ else { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/ trial_cost = evaluate(D,tmp,&nfeval); /* Evaluate new vector in tmp[] */ if(MAXIMAPROBLEM == 1) { // 改為最大化 if (trial_cost >= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost>cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } else { // 最小化問題 if (trial_cost <= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost<cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } } /* End mutation loop through pop. */ assignd(D,bestit,best); /* Save best population member of current iteration */ /* swap population arrays. New generation becomes old one */ pswap = pold; pold = pnew; pnew = pswap; /*----Compute the energy variance (just for monitoring purposes)-----------*/ cmean = 0.; /* compute the mean value first */ for (j=0; j<NP; j++) { cmean += cost[j]; } cmean = cmean/NP; cvar = 0.; /* now the variance */ for (j=0; j<NP; j++) { cvar += (cost[j] - cmean)*(cost[j] - cmean); } cvar = cvar/(NP-1); /*----Output part----------------------------------------------------------*/ if (gen%refresh==1) /* display after every refresh generations */ { /* ABORT works only if conio.h is accepted by your compiler */ printf(\"\\n\\n PRESS ANY KEY TO ABORT\"); printf(\"\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n\",cmin); for (j=0;j<D;j++) { printf(\"\\n best[%d]=%-15.10g\",j,best[j]); } printf(\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); printf(\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); } fprintf(fpout_ptr,\"%ld %-15.10g\\n\",nfeval,cmin); } /*=======================================================================*/ /*=========End of iteration loop=========================================*/ /*=======================================================================*/ /*-------Final output in file-------------------------------------------*/ fprintf(fpout_ptr,\"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n\",cmin); for (j=0;j<D;j++) { fprintf(fpout_ptr,\"\\n best[%d]=%-15.10g\",j,best[j]); } fprintf(fpout_ptr,\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); fprintf(fpout_ptr,\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); fclose(fpout_ptr); /* Code you want timed here */ printf(\"Time elapsed: %f\\n\", ((double)clock() - start) / CLOCKS_PER_SEC); return(0); } /*-----------End of main()------------------------------------------*/ // 適應函式 fittness function (cost function) double evaluate(int D, double tmp[], long *nfeval) { // 先處理通過 5 個點的四連桿問題 // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1] // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3] // L1 為第一桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[4] // L2 為第二桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[5] // L3 為第三桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[6] // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值) // L5, L6 必須 > 0, 且小於 100 - 設為 tmp[7], tmp[8] // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33 // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13] // 這裡的輸入角度值, 將採用以第一角度>0 作為起點, 隨後則為角度增量, 也都必須大於零 // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值 // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化 /* void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/ struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS]; double input_angles[NUM_OF_POINTS], result, total_angle; int i; (*nfeval)++; target_points[0].x = 4.5; target_points[0].y = 6.75; target_points[1].x = 5.07; target_points[1].y = 6.85; target_points[2].x = 5.45; target_points[2].y = 6.84; target_points[3].x = 5.89; target_points[3].y = 6.83; target_points[4].x = 6.41; target_points[4].y = 6.8; target_points[5].x = 6.92; target_points[5].y = 6.58; target_points[6].x = 7.03; target_points[6].y = 5.99; target_points[7].x = 6.95; target_points[7].y = 5.45; target_points[8].x = 6.77; target_points[8].y = 5.03; target_points[9].x = 6.4; target_points[9].y = 4.6; target_points[10].x = 5.91; target_points[10].y = 4.03; target_points[11].x = 5.43; target_points[11].y = 3.56; target_points[12].x = 4.93; target_points[12].y = 2.94; target_points[13].x = 4.67; target_points[13].y = 2.6; target_points[14].x = 4.38; target_points[14].y = 2.2; target_points[15].x = 4.04; target_points[15].y = 1.67; target_points[16].x = 3.76; target_points[16].y = 1.22; target_points[17].x = 3.76; target_points[17].y = 1.97; target_points[18].x = 3.76; target_points[18].y = 2.78; target_points[19].x = 3.76; target_points[19].y = 3.56; target_points[20].x = 3.76; target_points[20].y = 4.34; target_points[21].x = 3.76; target_points[21].y = 4.91; target_points[22].x = 3.76; target_points[22].y = 5.47; target_points[23].x = 3.8; target_points[23].y = 5.98; target_points[24].x = 4.07; target_points[24].y = 6.4; // 輸入角度值與 tmp[] 的設定 for(i = 0; i < NUM_OF_POINTS; i++) { input_angles[i] = tmp[i + 9]; } // 呼叫 mechanism() 以便計算 output_points[] mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points); // for debug /* if(*nfeval%5000 == 0) { for(i = 0; i < NUM_OF_POINTS; i++) { printf(\"%-15.10g : %-15.10g\\n\", output_points[i].x, output_points[i].y); } printf(\"#####################################\\n\"); } */ // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost result = error_function(output_points, target_points); // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result // x0 與 x1 點位於 -50 與 50 中間 for(i = 0; i < 4; i++) { if(tmp[i] < -100 || tmp[i] > 100){ return PENALITY; } } // 三個連桿值, 一定要為正 for(i = 4; i < 7; i++) { if(tmp[i] < 0 || tmp[i] > 100){ return PENALITY; } } // L5 L6 可以為 0 或負值 for(i = 7; i < 9; i++) { if(tmp[i] < -100 || tmp[i] > 100){ return PENALITY; } } // 角度值不可以小於 0 for(i = 1; i <= NUM_OF_POINTS; i++) { if(tmp[D-i] < 0){ return PENALITY; } } /* for(i = 0; i < D - NUM_OF_POINTS; i++) { if((tmp[i] <= inibound_l)|| (tmp[i] >inibound_h)){ return PENALITY; } } for(i = 1; i <= NUM_OF_POINTS; i++) { if(tmp[D-i] < 0){ return PENALITY; } } */ return result; /* double result=0, surface = 80.0, z, volume, penality; (*nfeval)++; z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1])); volume = tmp[0]*tmp[1]*z; if(volume <= 0){ return PENALITY; } if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){ return PENALITY; } if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){ return PENALITY; } // volume must >0 and max volume // 目前為最小化問題 return 1+1/(volume*volume); */ } struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt) { struct Coord tip_coord; if (localt>=0 && localt <PI) { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的 sqrt 替換成 sqrtt, 以防止被 maxima 中的 subst(\"&#94;\"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼. tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0; } else { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+ pow(x1-x0,2))/2)+x0; } // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題. if (localt>=0 && localt <PI) { tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ // 利用 sqrtt 居中進行代換所得到的式子 pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } else { tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } return tip_coord; } double distance(double x0, double y0, double x1, double y1) { double distance_value; distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2)); return distance_value; } double rr(double L1, double dd, double theta) { double rr_value; rr_value = sqrt(L1*L1+dd*dd - 2*L1*dd*cos(theta)); return rr_value; } // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS] void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]) { // 這裡的輸入角度, 改採第一角度為起始角, 隨後的角度值則為增量值 // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置 // 以下為可能的處理變數宣告 // 這裡希望能夠定義一個 struct 來處理座標點 double rr_length, dd_length, angle; struct Coord link1_tip, link2_tip, triangle_tip; double angle2, angle3; int i; // 開始進行三角形頂點座標的計算 // 以下變數由每一個體向量提供 /* x0 = 0.0; y0 = 0.0; x1 = 10.0; y1 = 0.0; L1 = 5.0; L2 = 20; L3 = 10; L5 = 10; L6 = 10; */ dd_length = distance(x0, y0, x1, y1); /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */ // 假如採用 finaltip_coord, 則不需要 angle3 angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5)); for(i = 0; i < NUM_OF_POINTS; i++) { // 先建立第一點座標, 即 i=0 者 // i=0; // angle = i*degree; /* // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準 if(i > 0) { input_angles[i] = input_angles[i] + input_angles[i-1]; } */ angle = input_angles[i]*degree; rr_length = rr(L1, dd_length, angle); // 第一次三角形疊代 link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle); // 第二次三角形疊代 /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */ angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length)); link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2); // 第三次三角形疊代 //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負 output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6); } } double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]) { double error = 0.0; int i; for(i = 0; i < NUM_OF_POINTS; i++) { error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y)); } return error; } struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2) { struct Coord tip3_coord; double theta3, theta4, length3, length4; length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2)); length4 = sqrt(pow(r1,2) + pow(r2,2)); theta3 = acos((tip2_coord.x - tip1_coord.x) / length3); theta4 = acos(r1 / length4); tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4); tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4); return tip3_coord; }","url":"http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html","title":"yen - RGA 基因演算法"},{"tags":"Misc","text":"這是一個利用 Python3 的模組 blockdiag: http://blockdiag.com/en/ , 將文字敘述轉為 2D 流程圖的範例. 機械設計專題內容流程圖： 機械設計專題 隨身卡片電腦規劃 流程圖： 機械設計專題內容流程圖的文字敘述: blockdiag { default_shape = roundedbox; // 內定寬度為 128 node_width = 140; // 內定高度為 40 node_height = 50; default_fontsize = 15; default_node_color = \"lightyellow\"; edge_layout = flowchart; // 表達方式 表達 [label = \"六種表達方式\"]; 1 [label = \"口語表達(聲音)\"]; 2 [label = \"文字表達\"]; 3 [label = \"2D表達(靜態影像)\"]; 4 [label = \"3D表達(動態影像)\"]; 5 [label = \"理論表達(定量分析)\"]; 6 [label = \"實體表達\"]; 表達 -> 1; 表達 -> 2; 表達 -> 3; 表達 -> 4; 表達 -> 5; 表達 -> 6; // 學門 學門 [label = \"四種技術領域\"]; 學門1 [label = \"熱流力學\"]; 學門2 [label = \"固體力學\"]; 學門3 [label = \"電機電子\"]; 學門4 [label = \"資訊通信\"]; 學門 -> 學門1; 學門 -> 學門2; 學門 -> 學門3; 學門 -> 學門4; // 流程 流程 [label = \"四個層面\"]; 流程1 [label = \"設計\"]; 流程2 [label = \"製造\"]; 流程3 [label = \"控制\"]; 流程4 [label = \"管理\"]; 流程 -> 流程1; 流程 -> 流程2; 流程 -> 流程3; 流程 -> 流程4; //專題 專題 [label = \"機械設計專題\", stacked]; 專題 -> 表達; 專題 -> 流程; 專題 -> 學門; } 機械設計專題 隨身卡片電腦規劃 流程圖的文字敘述: blockdiag { default_shape = roundedbox; // 內定寬度為 128 node_width = 140; // 內定高度為 40 node_height = 50; default_fontsize = 15; default_node_color = \"lightyellow\"; edge_layout = flowchart; // 表達方式 表達 [label = \"六種表達方式\"]; 1 [label = \"口語表達(聲音)\"]; 2 [label = \"文字表達\", color=\"#99ff33\"]; 3 [label = \"2D表達(靜態影像)\"]; 4 [label = \"3D表達(動態影像)\"]; 5 [label = \"理論表達(定量分析)\"]; 6 [label = \"實體表達\", color=\"#99ff33\"]; 表達 -> 1; 表達 -> 2; 表達 -> 3; 表達 -> 4; 表達 -> 5; 表達 -> 6; // 學門 學門 [label = \"四種技術領域\"]; 學門1 [label = \"熱流力學\"]; 學門2 [label = \"固體力學\"]; 學門3 [label = \"電機電子\"]; 學門4 [label = \"資訊通信\", color=\"#99ff33\"]; 學門 -> 學門1; 學門 -> 學門2; 學門 -> 學門3; 學門 -> 學門4; // 流程 流程 [label = \"四個層面\"]; 流程1 [label = \"設計\", color=\"#99ff33\"]; 流程2 [label = \"製造\"]; 流程3 [label = \"控制\"]; 流程4 [label = \"管理\", color=\"#99ff33\"]; 流程 -> 流程1; 流程 -> 流程2; 流程 -> 流程3; 流程 -> 流程4; //專題 //專題 [label = \"機械設計專題\", stacked]; 專題 [label = \"隨身卡片電腦選購\", stacked, color=\"#ff5050\"]; 專題 -> 表達; 專題 -> 流程; 專題 -> 學門; }","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-de-biao-da-ji-shu-ling-yu-yu-kao-liang-ceng-mian.html","title":"yen - 機械設計專題的表達、技術領域與考量層面"},{"tags":"Tutorial","text":"機械設計專題專用的 Wordpress 必須俱備幾項特點: 能夠輸入數學公式, 能夠放入高亮顯示的程式碼, 能夠內嵌影片, 能夠利用 Gmail 帳號寄信, 能夠納入 Disqus 討論區, 能夠杜絕垃圾註冊. 當然假如能夠如 http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html 中所言, 可以利用 Leo Editor 的指令按鈕, 讓 Wordpress 網誌內容能與 Pelican 靜態網誌內容保持同步, 或許就能同時擁有改版歷程資料與即時動態維護內容的優點. Disqus 的討論區留言首推: https://wordpress.org/plugins/disqus-comment-system/ 嵌入影片專用: https://wordpress.org/plugins/iframe/ 程式碼的高亮則建議使用: https://wordpress.org/plugins/syntaxhighlighter/ 輸入數學公式: https://wordpress.org/plugins/wp-latex/ 寄信 plugin: https://wordpress.org/plugins/wp-latex/ 防止垃圾註冊 plugin: https://wordpress.org/plugins/wp-recaptcha/ 至於, 在 WordPress 網誌中利用 https://wordpress.org/plugins/wp-mail-smtp/ Plugin 與 Gmail 帳號寄信的設定, 有兩個關鍵: 第1項就是設定選項: 選擇 Send all WordPress emails via SMTP 選擇 smtp.gmail.com: 465 選擇 Use SSL encryption 選擇 Use SMTP authentication 然後給定對應的 Gmail 帳號 與 Gmail 密碼 之後存檔. 第2項設定則是必須配合所使用的 Gmail 帳號, 利用 https://www.google.com/settings/security/lesssecureapps 將原定的 Turn off 改為 Turn on, 也就是降低安全設定等級, 接著就可以寄出測試信件, 若成功, 則 WordPress 中的其他模組就可以利用設定寄信.","url":"http://project.mde.tw/blog/yen-ru-he-jian-li-yi-hao-de-wordpress-wang-zhan.html","title":"yen - 如何建立一好的 Wordpress 網站"},{"tags":"Tutorial","text":"Solvespace 是一套小型的參數式 3D 繪圖開源套件, 而 V-rep 則是一套允許教育界免費使用的開源動態模擬套件, 結合這兩個套件在機械設計專題應用, 一方面使用者可以在可攜的架構下來進行產品開發與模擬, 更重要的是, 使用者可以透過原始程式碼, 一窺專業人士編寫電腦輔助機械設計與分析工具時, 所應用的理論分析與基本架構. Solvespace: http://solvespace.com/ 與 https://github.com/whitequark/solvespace V-rep: http://www.coppeliarobotics.com/","url":"http://project.mde.tw/blog/yen-solvespace-yu-v-rep-jie-he-ying-yong.html","title":"yen - Solvespace 與 V-rep 結合應用"},{"tags":"Misc","text":"我們知道自從 2013 年底開始, 與 Raspberry Pi 搭配的 Raspbian 操作系統, 就已經免費放入 Mathematica 相關的套件系統, 但是只允許非營利使用, 相較之下, 以 Python3 為主打造的 Jupyter 就比較自由, 而且全部開源, 因此更值得推廣. 這裡就以 Raspberry Pi 3 卡片電腦上的 Jupyter hub 安裝與啟動為例, 希望作為機械設計專題學員隨身的網際工程運算系統. 最新的 Raspbian 操作系統已經內建 Python3 以及 node.js, 因此當基本的操作系統配置完成, 而且啟動 SSH 之後, 就可以透過下列步驟安裝 Jupyter hub . jupyterhub 安裝 sudo apt-get install npm nodejs-legacy sudo npm install -g configurable-http-proxy sudo pip3 install jupyterhub sudo pip3 install IPython sudo pip3 install jupyter 以 SSL 啟動: 先建立 key 與 certificate: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt 以指定的 IP 啟動: jupyterhub --ip 192.168.1.1 --port 443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt 或不指定 IP: jupyterhub --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt 之後則可以 http://jupyterIP:9443 或 https://jupyterIP:9443 連線","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-xue-yuan-de-sui-shen-jupyter-hub.html","title":"yen - 機械設計專題學員的隨身 Jupyter hub"},{"tags":"Misc","text":"Raspberry Pi 3 Model B 終於在 2016 年 2 月推出了, 這片採用 1.2GHz 64位元四核心 CPU ARMv8 晶片的卡片電腦, 將帶給機械設計專題更多應用的題目. raspbian 安裝 首先, 為了簡化新的 Raspberry Pi 3 安裝 https://www.raspberrypi.org/downloads/noobs/ 多重開機系統的過程, http://cadlab.mde.tw 特別採購一批支援 HDMI 介面的電腦螢幕. 由於 noobs 內含的 https://www.raspberrypi.org/downloads/raspbian/ 與 Ubuntu 操作系統都屬於 Debian 系列, 因此未來幾年, 本地端與區域網路上的伺服器, 都將安裝 Ubuntu 16.04 LTS, 而希望學生人手一塊的 Raspberry Pi 3, 就以安裝 noobs 為主. 完成操作系統安裝後, 必須 enable SSH, 並且參考 這裡 的說明, 安裝並設定中文系統. 基本過程為: 安裝繁體中文語系: $ sudo locale-gen zh_TW.UTF-8 將 /etc/locale.gen 檔案內 # zh_TW.UTF-8 UTF-8 的註解# 拿掉: $ sudo vi /etc/locale.gen 產生繁體中文語系: $ sudo locale-gen 更改預設語系為 zh_TW.UTF-8: $ sudo vi /etc/default/locale LANG=zh_TW.UTF-8 安裝繁體中文字型: $ sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy 安裝 scim 注音輸入: $ sudo apt-get install scim scim-tables-zh scim-chewing PYQt5 與 Leo Editor 安裝 因為 Raspberry Pi 3 在機械設計專題流程中仍以機電控制為主, 而且 raspbian 已經內建 Python3 與 pip3, 因此只要利用 sudo apt-get install python3-pyqt5 安裝 PyQt5 即可. 只是在實際操作 sudo pip3 install https://github.com/leo-editor/leo-editor/archive/master.zip 時, 發現 Leo Editor 無法正確完成安裝, 最後只好下載 Leo Editor 原始碼, 並且將 leo 模組目錄, 直接放到 /usr/local/lib/python3.4/dist-packages 目錄下, 然後再利用 python3 launchLeo.py 啟動 Leo Editor. launchLeo.py 程式碼: #!/usr/bin/env python \"\"\" Leo launcher script A minimal script to launch leo. \"\"\" import leo.core.runLeo leo.core.runLeo.run() Raspberry Pi 無線網路設定 利用 sudo vi 編輯 /etc/wpa_supplicant/wpa_supplicant.conf, 並且採用下列格式, 將周遭卡片電腦移動時可能擷取的無線網路, 以並列的方式進行設定登記. 格式: network={ ssid=\"net1\" psk=\"net1_wifi_password\" key_mgmt=WPA-PSK } network={ ssid=\"net2\" psk=\"net2_wifi_password\" key_mgmt=WPA-PSK } 相關指令: sudo ifdown wlan0 (關閉無線網路) sudo ifup wlan0 (啟動無線網路) ifconfig (察看網路設定) Webcam 拍照 請參考 https://www.raspberrypi.org/documentation/usage/webcams/ , 讓 Raspberry Pi 可以帶著 Webcam, 以 Python3 程式控制拍照流程. 至於安裝 OpenCV 與 Python3 的過程與 http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html 中的說明完全相同, 一旦完成, Raspberry Pi 就可以與其他機構結合, 進行基本的影像辨識應用.","url":"http://project.mde.tw/blog/yen-raspberry-pi-3-ji-ben-she-ding.html","title":"yen - Raspberry Pi 3 基本設定"},{"tags":"Misc","text":"身為一位機械設計工程專長學員, 該如何看待數位運算, 那些技術較有未來? 機械設計專題是一項資訊密集的動態流程, 資訊之所以密集, 肇因於後續的許多控制、製造與管理, 都以設計的發動起始, 因此機械設計者憑藉著口語, 文字, 2D/3D, 理論與實體, 來紀錄並驗證概念與規格的可行性, 即便產品交付客戶手中, 各種後續服務、回收與處理再利用的相關細節規劃, 所涉及的許多資訊與數據處理, 就產品生命週期的概念而言, 都是設計者該盡力思量的範疇. 現在對於手握 Python3 作為數位運算的機械設計專題推動者, 有了福音, 因為 https://software.intel.com/en-us/python-distribution 的推出, 將可讓 Jupyter hub 上的各種機械設計純 Python3 最佳化運算速度提升幾十倍. 並且, 從 http://www.infoworld.com/article/3039935/application-development/21-hot-programming-trends-and-21-going-cold.html 的提醒, 也可以讓即將參與機械設計專題的學員了解, 應該如何取捨工具與技術, 畢竟數位運算科技的快速發展, 應該是機械設計者的絕對利多, 假如大家真能妥善發揮這些較有未來科技功能於工作的每一個流程.","url":"http://project.mde.tw/blog/yen-python-shu-wei-yun-suan-yu-jiao-you-wei-lai-de-ji-shu.html","title":"yen - Python 數位運算與較有未來的技術"},{"tags":"Misc","text":"因為這個網誌系統分為本地端與 Github 端的資料搜尋 ,因此一般並不建議直接將要展示的 stl 帶進倉儲, 否則就必須要分別在近端與遠端的 template 目錄中, 各放置一份檔案. 也就是說, 就這個機械設計專題的協同倉儲網誌來說, 各組員可以分別在自己的個人帳號下建立具有 gh-pages 分支的倉儲, 然後再將 STL 零組件檔案的檢式, 以 Github 特有的標註, 放到文章中, 因為 STL 檔案已經是終端檔案, 比較不會有協同編輯改版的需求, 因此可以放在個人所屬的倉儲中, 只需要透過連結可以檢視即可. 但是若這些檔案真要放到機械設計專題所屬的倉儲中, 也是可以, 但是就必須在近端的 theme/pelican-bootstrap3_local/static 目錄, 以及 theme/pelican-bootstrap3/static 目錄中, 各放一份, 例如, 現在已經在這兩個目錄中各放入 files 目錄, 而且其中還有 40323143 目錄, 並將所有的 STL 零組件檔全部放入. 這時若利用 local-pelican 或 gh-pages-pelican 按鈕建立 blog 中的資料, Pelican 就會將前面提到的 files 目錄, 複製到 blog/theme 目錄中, 因此隨後在 gh-pages 的網頁中, 就是到 blog/theme/files/40323143 目錄來擷取這些零組件檔案. 例如: blog/theme/files/40323143/1long.stl 檔案, 就可以疊上 https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/, 並用 script 標註圈住, 讓使用者可以在瀏覽器中檢視.","url":"http://project.mde.tw/blog/yen-ru-he-zai-pelican-wang-zhi-zhong-jia-ru-github-stl-jian-shi.html","title":"yen - 如何在 Pelican 網誌中加入 Github stl 檢視"},{"tags":"Misc","text":"OpenCV (Open Source Computer Vision) 是一套實時影像程式庫, 這裡希望利用 Python3 來進行應用程式開發. 安裝 Windows 可以直接從 https://github.com/chiamingyen/kmol2016 git clone 可攜系統. 測試程式: import numpy as np import cv2 # 建立一個黑色背景 img = np.zeros((512,512,3), np.uint8) # 以寬度 5 px 畫一條藍色的對角線 img = cv2.line(img,(0,0),(511,511),(255,0,0),5) # 呈現此影像 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() ''' # 載入 jpg 圖檔 image = cv2.imread(\"mario.jpg\", flags=cv2.IMREAD_COLOR) # 然後呈現此影像 cv2.imshow('image',image) cv2.waitKey(0) cv2.destroyAllWindows() ''' 在 Windows 環境執行結果: Ubuntu 14.04 在 Ubuntu 操作系統中 for Python2 與 Python3 的 OpenCV 程式庫編譯流程如下: # apt-get 更新 $ sudo apt-get update # apt-get 升級 $ sudo apt-get upgrade # 安裝所需的開發套件 $ sudo apt-get install build-essential cmake git pkg-config # 安裝編譯過程所需的程式庫 $ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev # 安裝編譯過程所需的程式庫 $ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev # 安裝編譯過程所需的程式庫 $ sudo apt-get install libgtk2.0-dev # 安裝編譯過程所需的 fortran 編譯器 $ sudo apt-get install libatlas-base-dev gfortran # 安裝編譯過程所需的原始碼 $ sudo apt-get install python3.4-dev # 本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy 模組 $ pip3 install numpy # 希望在帳號目錄下的 tmp 進行編譯工作 $ cd # 更換目錄到 tmp $ cd tmp # 利用 git clone 取得原始碼 $ git clone https://github.com/Itseez/opencv.git # 準備進入倉儲切換分支 $ cd opencv # 採用 3.1.0 版 $ git checkout 3.1.0 # 回到用戶目錄 $ cd .. # 再利用 git clone 下載原始碼 $ git clone https://github.com/Itseez/opencv_contrib.git # 準備進入倉儲切換分支 $ cd opencv_contrib # 與 opencv 配合, 採用 3.1.0 版 $ git checkout 3.1.0 $ cd .. # 準備開始建立程式庫 $ cd opencv $ mkdir build $ cd build # 這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案 $ cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_C_EXAMPLES=OFF \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D PYTHON_EXECUTABLE=$(which python3) \\ -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \\ -D BUILD_EXAMPLES=ON .. $ make -j4 $ sudo make install $ sudo ldconfig 完成安裝後, 執行上一個測試程式結果: 以下則為人臉變識程式: https://github.com/shantnu/FaceDetect/ : 執行需要取得 haarcascade_frontalface_default.xml import cv2 import sys cascPath = \"haarcascade_frontalface_default.xml\" faceCascade = cv2.CascadeClassifier(cascPath) video_capture = cv2.VideoCapture(0) while True: # 逐一以影格取像 ret, frame = video_capture.read() gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE ) # 在辨識的臉形外圍畫一個矩形 for (x, y, w, h) in faces: cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2) # 呈現影像 cv2.imshow('Video', frame) if cv2.waitKey(1) & 0xFF == ord('q'): break # 停止執行 video_capture.release() cv2.destroyAllWindows() 人臉辨識程式執行結果:","url":"http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html","title":"yen - 導入 OpenCV 與 Python3"},{"tags":"Tutorial","text":"我們有沒有能力在機械設計專題中, 自行編譯 Solvespace, 並且了解其中的原理後, 新增自己需要的零件設計功能? https://github.com/whitequark/solvespace http://solvespace.com 自行編譯 solvespace: 從 http://www.activestate.com/activeperl/downloads 下載 ActivePerl, 並完成安裝. 下載並安裝 Visual Studio Express. 從 Visual Studio Express 表單中啟動 Dos Command. 進入 Solvespace Makefile 所在目錄, 執行 nmake. 就可以完成 Solvespace.exe 的編譯.","url":"http://project.mde.tw/blog/yen-bian-yi-solvespace.html","title":"yen - 編譯 Solvespace"},{"tags":"Misc","text":"機械設計工程師在面對四種主要的學門領域, 六種表達方式, 以及四種開發流程階段的交互串聯下, 能否在分散式版次管理系統的協助中, 勇往直前? 四種主要的學門領域: 熱流、固力、電子電機、資通. 六種表達方式: 口語、文字、2D、3D、理論分析、實體 四種流程階段: 設計、製造、控制、管理 機械設計專題倉儲: https://github.com/2015fallproject","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-cang-chu.html","title":"yen - 機械設計專題倉儲"},{"tags":"Misc","text":"此項測試目的在利用樹莓派卡片電腦, 以無線網路取得區域網路 IP, 然後從電腦教室中的 Windows 10, 以 X-Windows Server 連線到 Raspberry Pi 電腦系統, 嘗試讓機械設計工程學員評估, 能否在 Windows 10 與隨身的 Ubuntu 電腦系統間, 搭建合用的協同產品開發環境. Windows 10 環境中擬採用的 X-Windows Server: https://sourceforge.net/projects/xming/ Raspberry Pi 擬安裝操作系統: Ubuntu Server + sudo apt-get install ubuntu-desktop 樹莓派採購清單: 操作步驟: 完成清單中的樹莓派硬體採購 在樹莓派中安裝即將推出的 Ubuntu 16.04 LTS Server 版本, 加上 ubuntu-desktop. 測試如何在 http://cadlab.mde.tw 電腦輔助設計室中利用樹莓派的內建 Wifi 取得固定 IP 測試如何在樹莓派系統中以 IPV6 環境上網, 或在樹莓派系統中植入 IPV6 與 IPV4 雙支援, 並安裝 squid Proxy Server, 測試樹莓派在純 IPV6 環境中, 擔任區域網路代理伺服器的效能. 利用本地端的 Windows 10 Professional, 啟動 xming 伺服器後, 以 putty 加上 X11 forwarding 設定, 從 Windows 10 連線到樹莓派, 然後在 Ubuntu 中安裝 Leo Editor, Jupyter, Flask 與 Weppy 等相關機械設計專題工具, 並利用 Firefox 連線到 Onshape, 測試各項工具的使用效能. 完成上述各項任務後, 將流程與心得留在各組對應的機械設計專題倉儲中, 若過程中有些資料不適合在第1時間公開, 則另在 bitbucket 建 private 倉儲, 以五名協同者的編制進行管理. 上述流程中, 各學員同時考量該如何將心得整理為論文或專題報告 pdf 發表格式. 在 KMOL 知識地圖中的屬性: 四種主要的學門領域: 熱流、固力、電子電機 、資通. 六種表達方式: 口語 、文字、 2D、3D、理論分析 、實體 四種流程階段: 設計、 製造、控制 、管理 機械設計專題倉儲: https://github.com/2015fallproject","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-sui-shen-kai-fa-dian-nao.html","title":"yen - 機械設計專題隨身開發電腦"},{"tags":"Misc","text":"許多網路上的文章都只說明如何從動態的網誌系統轉到靜態網誌架構, 但當我們認定動靜之間各有優劣時, 能否兩者整合並存? Worpress 是一套全世界最廣為使用的動態網誌系統, 採用 PHP 編寫, 一般使用 MySQL 資料庫存放資料, 由於 Wordpress 的安裝與使用都非常直覺, 從許多角度來看, 是一套接近完美的動態網誌系統. 但是, PHP 加上 MySQL 的架構仍然需要在伺服器中運行全球資訊網加上 PHP 解譯器, 同時還要 MySQL 資料庫的支援才能啟動運作, 假如管理者沒有跟上 Wordpress 程式碼或 plugin 的漏洞更新, 或者 MySQL 資料庫未能正常提供資料, 這個用 Wordpress 架構的網誌就會出現危機或者無法使用. 雖然 Wordpress 網誌中的動態程式與資料庫具有潛在缺點, 但是動態性也同時展現優點, 因為使用者一般可以透過瀏覽器, 隨時更改網誌系統的設定, 可以即時更新所有內容. 至於 Pellican 靜態網誌系統, 則針對 Wordpress 動態的問題, 將網誌的編寫格式定調在資料提供者能夠閱讀的 Markdown 或其他類似格式, 然後在近端用各種編輯器完成初步 Markdown 文章的存檔後, 再執行 Pelican 的轉檔指令, 讓 Python 程式將一堆設定與一堆 Markdown 資料中, 轉換成一整套所有內容之間互相串連的 html 檔案, 之後再將這批純 html 格式的文檔加上一些 css 與 Javascript 檔案, 送到全球資訊網伺服器中運行. Pelican 的網誌內容, 因為不需要動態的程式編譯執行, 而只在全球資訊網伺服器中存有 html 與 Javascript, 因此沒有動態程式碼漏洞更新的問題, 也不會有線上的網誌管理系統被入侵的問題, 唯一會產生問題的只有全球資訊網伺服器, 運作或不運作, Javascript 有沒有正確存取的問題, 相較於 Wordpress 的動態程式與資料庫互動, 性質單純許多. 但是 Pelican 的靜態性也同時存在問題, 因為大多數的用戶通常採用文字編輯器來準備或管理 Markdown 檔案, 而且是採用命令列的方式來執行 Pelican 轉檔指令, 因此對於電腦程式操作較不熟悉的使用者來說, 導入 Pelican 靜態網誌的距離仍然遙遠, 況且靜態網誌也有不夠動態與直覺的問題, 許多在 Wordpress 線上能夠直接預覽的功能, 在 Pellican 就沒有那麼方便, 而且有很多的 html 與 css 的特定格式, Pelican 的 Markdown 語法根本就不支援. 可是 Pelican 純文本的 Markdown 與 html, 還有一個最大的好處, 就是可以透過 Github Pages 的網頁架構系統, 讓每一個版本的靜態網誌都以分散式版本系統管理, 這是 Wordpress 現存的版次管理 Plugin 所無法做到的功能, 因此一份內容, 同時呈現在 Wordpress 與 Pelican 網誌是最理想的情況, 但是該如何完成? 由於要整合 Pelican 靜態網誌與 Wordpress 動態網誌, 需要透過程式方法來進行, 這裡只先提供可行的初步技術, 驗證魚與熊掌可以兼得, 我們所採用的管理系統為 Leo Editor: https://github.com/leo-editor/leo-editor , 所有的資料處理流程都是依靠 Python3 程式完成. 首先, 看看 Leo Editor 如何透過 Python3 的程式方法與 Wordpress 網誌互動, 這裡所使用的是 XMLRPC 協定 https://en.wikipedia.org/wiki/XML-RPC , 基本上, 從 Leo Editor 節點, 將新資料送到 Wordpress 系統的按鈕程式. # new_to_wp 按鍵 #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): data_list = data.split(\"\\n\") # 只有一項資料的 category 型別為字串 category = data_list[0] # 只有一項資料的 tags 型別為字串 tags = data_list[1] # 有多項資料的 content 型別為數列 # 再將第3行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[2:]) return category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# # Open a file, 這裡將存取 Wordpress 網誌的對應帳號與密碼, 存在操作系統中 # 路徑則從資料節點上層根節點的 body 內文取得 fo = open(p.parent().b, \"r+\") data = [] for line in fo.readlines(): data.append(line) #print(line) #print(data[0]) # Close opend file fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+p.parent().h+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) title = p.h #content = p.b category_str, tags_str, content = get_cat_tag_content(p.b) # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 (因為伺服主機與操作端時差而定) date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) #categories = [\"Uncategorized\"] #tags = [\"python\", \"測試\"] categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published) # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() to_save_post_id.b = post_id to_save_post_id.h = \"文章 id\" # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經送出資料!\") ''' 其他 metaWeblog 的用法: metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid) metaWeblog.editPost (postid, username, password, struct, publish) returns true metaWeblog.getPost (postid, username, password) returns struct(blog content) ''' 至於在 Leo Editor 系統中, 用來編輯既有的 Wordpress 文章的按鈕節點程式碼, 則為: #edit_to_wp #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): data_list = data.split(\"\\n\") # 只有一項資料的 category 型別為字串 category = data_list[0] # 只有一項資料的 tags 型別為字串 tags = data_list[1] # 有多項資料的 content 型別為數列 # 再將第3行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[2:]) return category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# # Open a file fo = open(p.parent().b, \"r+\") data = [] for line in fo.readlines(): data.append(line) #print(line) #print(data[0]) # Close opend file fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+p.parent().h+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) title = p.h #content = p.b category_str, tags_str, content = get_cat_tag_content(p.b) # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 (因為伺服主機與操作端時差而定) date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) #categories = [\"Uncategorized\"] #tags = [\"python\", \"測試\"] categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} # 設法取得原 post 的 id origin_post = p.getLastChild() post_id = origin_post.b status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published) if status: g.es(\"資料已經更新!\") else: g.es(\"有問題, 資料沒有更新!\") ''' 其他 metaWeblog 的用法: metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid) metaWeblog.editPost (postid, username, password, struct, publish) returns true metaWeblog.getPost (postid, username, password) returns struct(blog content) ''' 最後若要經由 Leo Editor 的節點按鈕, 取回既有的 Wordpress 網誌文章, 則可以使用 get_from_wp 按鈕節點: #get_from_wp #coding: utf-8 import xmlrpc.client # 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號 import html ################################# # Open a file fo = open(p.parent().b, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+p.parent().h+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# server = xmlrpc.client.ServerProxy(wp_url) # 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資 # 從最後的 child 節點來取 post_id origin_post = p.getLastChild() post_id = origin_post.b # 取回與 post_id 對應的網誌文章內容 blog_content = server.metaWeblog.getPost (post_id, wp_username, wp_password) title = blog_content[\"title\"] # 這裡要利用 html.unescape 轉回特殊符號 description = html.unescape(blog_content[\"description\"]) mt_text_more = html.unescape(blog_content[\"mt_text_more\"]) if mt_text_more != \"\": post_content = description + \"\\n \\n\"+mt_text_more else: post_content = description # 所取回的 categories 為 list categories = blog_content[\"categories\"] # 索取回的 tags 為以逗點隔開的字串 mt_keywords = blog_content[\"mt_keywords\"] p.h = title categories_str = \"\" for category in categories: # 假如不是最後一個 if category != categories[len(categories)-1]: categories_str += category + \", \" else: # 這是最後一個 categories_str += category p.b = \"categories:\"+categories_str+\"\\ntags:\"+mt_keywords+\"\\n\"+post_content # 因為節點資料更新, commander 必須 redraw c.redraw() g.es(\"資料已經取回\") 好了, 上面的3個 Leo Editor 的按鈕節點程式, 只是從操作系統的特定路徑取出能夠管理遠端 Wordpress 網誌系統的帳號密碼, 然後再透過 XML-RPC 協定, 進行 Wordpress 網誌文章的新增、編輯與取回, 表示使用者可以在一個 Leo Editor 專案檔中完成這些事, 接下來則需要讓 Pelican 轉出的 html 檔案, 能夠同步送到對應的 Wordpress 動態網誌系統, 並且可以做到即時的內容同步, 既可保有靜態網誌的版次管理與單純伺服架構, 而且又可以將 Wordpress 視為 Pelican 的另外一個出口 (意思就是說, Wordpress 中只有特定的內容由 Pelican 端提供, 其他的使用者則仍然透過瀏覽器的方法對 Wordpress 網誌提供內容), 至於後續的處理與可行性驗證, 將在隨後的文章中進行討論.","url":"http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he.html","title":"yen - Pelican 靜態網頁與 Wordpress 的整合"},{"tags":"Misc","text":"利用 Leo Editor 的節點資料程式方法, 可以讓 Pelican 靜態網誌的內容與 Wordpress 動態網誌保持同步. 因為 Pelican 靜態網頁結合 Github Pages 網站, 可以完整保留各版本的所有差異資料 ,而 Wordpress 的動態特性也具有即時更新的優點, 因此本機械設計專題網站, 就利用 Leo Editor 建立了3個按鈕, 可以在靜態與動態網誌之間雙向交換內容. 首先是先編寫 Pelican 網誌的文章, 然後再經由下列 Leo Editor 的按鈕, 以 XML-RPC 協定, 將文章送到對應的 Wordpress 網誌. ＃new-to-wp button #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python # 用跳行符號分割 data_list = data.split(\"\\n\") #第2行為 title title= data_list[1] #第3行為 category category = data_list[2] #第4行為 tags tags = data_list[3] # 有多項資料的 content 型別為數列 # 再將第7行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[6:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 content = content.replace('~~~python', '[code lang=\"python\"]') content = content.replace('~~~', '[/code]') return title, category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# filepath = \"/your/wordpress/username/and/passwrod.txt\" wordpress = \"your.wordpress.site.domain\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 title_str, category_str, tags_str, content = get_cat_tag_content(p.b) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 # 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published) # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() # 改為內文為空的節點, id 直接標在 head 標題 to_save_post_id.b = \"\" to_save_post_id.h = post_id # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經送出資料!\") 其中 filepath 是存放 Wordpress 網誌管理帳號與密碼的存文字檔案路徑 (例如: \"/home/user/file.txt\"), 而 wordpress 則宣告希望對應連結的網址 (例如: \"www.yoursite.blog\"). 當 Wordpress 的網誌文章新增後, 若 Pelican 端的文章改版, 則可以透過下列 edit-to-wp 按鈕進行更新: # edit-to-wp #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python # 用跳行符號分割 data_list = data.split(\"\\n\") #第2行為 title title= data_list[1] #第3行為 category category = data_list[2] #第4行為 tags tags = data_list[3] # 有多項資料的 content 型別為數列 # 再將第7行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[6:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 content = content.replace('~~~python', '[code lang=\"python\"]') content = content.replace('~~~', '[/code]') return title, category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# filepath = \"/your/wordpress/username/and/passwrod.txt\" wordpress = \"your.wordpress.site.domain\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 title_str, category_str, tags_str, content = get_cat_tag_content(p.b) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} # 設法取得原 post 的 id origin_post = p.getLastChild() # 直接從標題取得 post 的 id 號碼 post_id = origin_post.h status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published) if status: g.es(\"資料已經更新!\") else: g.es(\"有問題, 資料沒有更新!\") 最後, 假如使用者透過 Wordpress 的瀏覽器介面新增文章, Pelican 端也可以準備一個空白節點, 並將文章的 id 號碼作為該空白節點的子節點, 且將該子節點的 header, 設為文章的 id 數, 接下來再用滑鼠停在父空白節點上, 然後以滑鼠點按下列的 get-from-wp 按鈕, 就可以將 Wordpress 端的文章取回, 且節點標題會被填入該文章的標題, 之後 Pelican 端的使用者再依據規劃, 以 @clean 存檔的標題命名該節點. # get-from-wp #coding: utf-8 import xmlrpc.client # 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號 import html ################################# filepath = \"/your/wordpress/username/and/passwrod.txt\" wordpress = \"your.wordpress.site.domain\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# server = xmlrpc.client.ServerProxy(wp_url) # 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資 # 從最後的 child 節點來取 post_id origin_post = p.getLastChild() post_id = origin_post.h # 取回與 post_id 對應的網誌文章內容 blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password) title = blog_content[\"title\"] # 這裡要利用 html.unescape 轉回特殊符號 description = html.unescape(blog_content[\"description\"]) mt_text_more = html.unescape(blog_content[\"mt_text_more\"]) if mt_text_more != \"\": post_content = description + \"\\n \\n\"+mt_text_more else: post_content = description # 所取回的 categories 為 list categories = blog_content[\"categories\"] # 所取回的 tags 為以逗點隔開的字串 mt_keywords = blog_content[\"mt_keywords\"] # 取回文章作者 author = blog_content[\"wp_author_display_name\"] p.h = title categories_str = \"\" for category in categories: # 假如不是最後一個 if category != categories[len(categories)-1]: categories_str += category + \", \" else: # 這是最後一個 categories_str += category line1 = \"@language md\\n\" line2 = \"Title: \" +title + \"\\n\" line3 = \"Category: \" + categories_str + \"\\n\" line4 = \"Tags: \" + mt_keywords + \"\\n\" line5 = \"Author: \" + author + \"\\n@others\\n\" post_content = post_content.replace(' ', '\\n \\n') post_content = post_content.replace('[code lang=\"python\"]', '~~~python') post_content = post_content.replace('[/code]', '~~~') p.b = line1 + line2 + line3 + line4 + line5 + post_content + \"\\n\" # 因為節點資料更新, commander 必須 redraw c.redraw() g.es(\"資料已經取回\")","url":"http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html","title":"yen - Pelican 靜態網頁與 Wordpress 的整合方案"},{"tags":"Tutorial","text":"只要是 KMOL 機械設計專題的成員, 就可以依照特定程序, 管理 project.mde.tw 網站上的資料 首先, 你必須是 https://github.com/coursemdetw/project_site/watchers 名單上的成員, 否則就必須透過 Pull Request 的方式來參與 http://project.mde.tw 網誌內容的協同管理. 接下來, 利用 git clone 的方式, 將 https://github.com/coursemdetw/project_site 的倉儲資料複製到近端, 並且將分支切換到 gh-pages, 就可以利用 Leo Editor 開啟或建立, 位於 users 目錄中的 user_template.leo, 然後轉存為\"學號.leo\" 檔案, 透過這個 Leo Editor 的專案檔, 就可以新增文章, 修改其他人的文章, 甚至修改本網誌系統中的任何設定. 將 user_template.leo 轉存為 \"學號.leo\" 後, 第1件重要的事就是修改 @edit user_20160301.md 中的 user_20160301.md 的存檔檔名, 改為 學號_當天日期.md, 然後修改此一 md 檔案的文章標題: Title: user - 使用者的範例網誌文章標題, 因為這個網誌系統根據 Title: 之後的名稱來轉換 html, 若有兩個 .md 檔案的 Title: 資料完全一樣, Pelican 將無法轉檔, 並且會在轉檔的命令列中出現錯誤訊息. 其他的 .md 檔案中, Category: 為文章的類別, 可以參考現有的\"2016g1, Misc 與 Tutorial\" 等3個類別, 可以是組別或是文章的屬性類別. Tags: 則是文章的內容標籤,可以就文章的內容關鍵字加以界定, 至於 Author: 則是用戶的名稱. 在每一個 .md 檔案中, 出現在 \"PELICAN_END_SUMMARY\" 超文件註解標註之前的內容, Pelican 會視為文章的摘要, 當各文章並列時, 文章只會列出標題與摘要. \"PELICAN_END_SUMMARY\" 超文件註解標註之後的內容就是文章的主要內容. 文章中的程式可以利用: for i in range(5): print(i, \":hello\") 來加以標示. 圖檔則可以利用 img 標註引用: 影片引用則可以直接使用 Vimeo 或 Youtube 的 embedded 語法. 因為本網誌能夠在近端與遠端等兩個不同環境下運作, 而兩端的關鍵字搜尋流程與格式不同, 因此轉檔的按鈕也分為 local-pelican 與 gh-pages-pelican 等兩個, 要在近端測試時, 必須滑鼠停在 local-pelican 轉檔按鈕的對應節點上, 然後按下 local-pelican, 經過瀏覽器檢查近端文章轉檔與內容無誤後, 必須將滑鼠停在 gh-pages-pelican 轉檔按鈕的對應節點上, 然後按下 gh-pages-pelican 按鈕, 之後若無任何問題, 就可以將資料提交推送到遠端倉儲的 gh-pages 分支中, 指令如下: git add -A git commit -m \"提交說明訊息\" git push origin gh-pages 最後, 與 http://project.mde.tw 網站維護有關的訊息溝通或註記, 請透過 倉儲 Wiki 進行.","url":"http://project.mde.tw/blog/yen-ru-he-can-yu-projectmdetw-de-xie-tong-bian-ji.html","title":"yen - 如何參與 project.mde.tw 的協同編輯"},{"tags":"Tutorial","text":"Flask 是一套支援 Python3 的全球資訊網程式框架, 這裡希望用它來開發網際輔助機械設計程式. http://flask.pocoo.org/ 是一套簡潔的 Python3 網際程式框架, 在這一系列的導引資料中, 將利用 https://github.com/2015fallhw/simpleflask 倉儲來存放資料, 並將資料同步推送到 http://simpleflask-2014openshift.rhcloud.com/ 執行. 程式環境 假如在 Windows 環境中, 使用可攜套件: https://github.com/chiamingyen/kmol2016 , 則已經內建 Flask 模組, 假如沒有, 可以利用 pip install Flask 安裝. 假如是在 Ubuntu, 可以要用 pip3 install Flask 安裝, 至於在 OpenShift 的 Python3 應用程式, 則是透過 setup.py 安裝. #setup.py 檔案 from setuptools import setup setup(name='KMOL 2016 project', version='1.0', description='OpenShift App', author='KMOL', author_email='course@mde.tw', url='https://www.python.org/community/sigs/current/distutils-sig', install_requires=['Flask>=0.10.1'], ) 由於這裡所開發的 Flask 程式, 需要在近端與 OpenShift 都能運作, 因此 wsgi.py 的內容設計為: #!/usr/bin/python # 導入 os 模組, 主要用來判斷是否在 OpenShift 上執行 import os # 導入同目錄下的 myflaskapp.py import myflaskapp # 以下開始判斷在 OpenShift 或近端執行 if 'OPENSHIFT_REPO_DIR' in os.environ.keys(): # 表示程式在雲端執行 application = myflaskapp.app else: # 表示在近端執行, 以 python3 wsgi.py 執行, 若採 uwsgi 則與 Openshift 運作模式相同 myflaskapp.app.run(debug=True) 也就是說, wsgi.py 會透過os.environ.keys() 的值來判定執行的環境, 若是在 uwsgi 的環境執行時, 則必須使用與 OpenShift 環境相同的啟動模式. 而 wsgi.py 中所導入的 myflaskapp.py 內容則為: # coding: utf-8 from flask import Flask, send_from_directory, request, redirect, render_template, session, make_response import random app = Flask(__name__) # 使用 session 必須要設定 secret_key # In order to use sessions you have to set a secret key # set the secret key. keep this really secret: app.secret_key = 'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T' @app.route(\"/\") def index(): #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零 # 將標準答案存入 answer session 對應區 theanswer = random.randint(1, 100) thecount = 0 # 將答案與計算次數變數存進 session 對應變數 session['answer'] = theanswer session['count'] = thecount return render_template(\"index.html\", answer=theanswer, count=thecount) @app.route('/user/ ') # 為了避免 syntaxhighlighter 自動加上 , 在這裡先行用註解補上, 之後再找解決方案 def user(name): return render_template(\"user.html\", name=name) @app.route('/red') def red(): # 重新導向 google return redirect(\"http://www.google.com\") @app.route('/guessform') def guessform(): session[\"count\"] += 1 guess = session.get(\"guess\") theanswer = session.get(\"answer\") count = session.get(\"count\") return render_template(\"guessform.html\", guess=guess, answer=theanswer, count=count) @app.route('/docheck', methods=['POST']) def docheck(): # session[] 存資料 # session.get() 取 session 資料 # 利用 request.form[] 取得表單欄位資料, 然後送到 template guess = request.form[\"guess\"] session[\"guess\"] = guess # 假如使用者直接執行 doCheck, 則設法轉回根方法 if guess is None: redirect(\"/\") # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況 try: theanswer = int(session.get('answer')) except: redirect(\"/\") # 經由表單所取得的 guess 資料型別為 string try: theguess = int(guess) except: return redirect(\"/guessform\") # 每執行 doCheck 一次,次數增量一次 session[\"count\"] += 1 count = session.get(\"count\") # 答案與所猜數字進行比對 if theanswer < theguess: return render_template(\"toobig.html\", guess=guess, answer=theanswer, count=count) elif theanswer > theguess: return render_template(\"toosmall.html\", guess=guess, answer=theanswer, count=count) else: # 已經猜對, 從 session 取出累計猜測次數 thecount = session.get('count') return \"猜了 \"+str(thecount)+\" 次, 終於猜對了, 正確答案為 \"+str(theanswer)+\": 再猜 \" return render_template(\"docheck.html\", guess=guess) @app.route('/option', methods=[\"GET\", \"POST\"]) def option(): option_list1 = [\"1\", \"2\", \"3\", \"4\"] option_list2 = [\"a\", \"b\"] return render_template('option.html', option_list1=option_list1, option_list2=option_list2) @app.route('/optionaction', methods=['POST']) def optionaction(): # 這裡將根據使用者所選擇的選項值, 來進行後續的設計運算 return request.form[\"option1\"] + \":\" + request.form[\"option2\"] # 等運算或資料處理結束後, 再將相關值送到對應的 template 進行資料的展示 #return render_template('optionaction.html', option_list1=option_list1, option_list2=option_list2) if __name__ == \"__main__\": app.run() 此外, 因為 Flask 內定靜態目錄名稱為 static, 且 template 名稱為 templates, 因此在最基本的 Flask 程式架構中, 也需要自行建立這兩個目錄, 然後將靜態文件放入 static 目錄中, 而對應的 template 文件檔案, 則放入 templates 目錄中.","url":"http://project.mde.tw/blog/yen-wang-ji-flask-cheng-shi-jia-gou.html","title":"yen - 網際 Flask 程式架構"},{"tags":"Tutorial","text":"利用 Github Pages 與 Pelican 建立協同專題製作網誌 機械設計工程網誌啟動 本網誌自 2016 Spring 開始啟動, 相關建置步驟如下: 以 https://github.com/coursemdetw 帳號建立 Gihub 倉儲 https://github.com/coursemdetw/project_site 將倉儲資料 git clone 到近端 利用 git branch 指令, 建立 gh-pages 分支 利用 git checkout 指令, 切換至 gh-pages 分支 開始建立 Pelican 網誌所需的協同架構資料 安排 users 目錄, 將分別存放各協同組員的 .leo 檔案 確定 gh-pages 分支中的網誌 http://coursemdetw.github.io/project_site/ 可以正常運作 根據 Github pages 專用網域設定說明 https://help.github.com/articles/using-a-custom-domain-with-github-pages/ , 建立 CNAME, 納入 project.mde.tw 將 https://github.com/coursemdetw/project_site 倉儲的 Default Branch 設為 gh-pages 分支 在 mde.tw 網域的 DNS 代管設定中, 加入 project.mde.tw 與 coursemdetw.github.io 之間的 CNAME 別名設定 等待 CNAME 別名生效後, http://project.mde.tw 即可正常連結使用 Pelican 網誌設定 由於本網誌將 Pelican https://github.com/getpelican/pelican 設定相關的所有資料都留在 Gihub 倉儲 https://github.com/coursemdetw/project_site 中, 目的在讓其他人可以參考本網誌的所有細節內容. 一般在實際應用, 只需將 blog 目錄 https://github.com/coursemdetw/project_site/tree/gh-pages/blog 中的資料送到全球資訊網伺服器即可. 本專題製作採用 http://leoeditor.com/ 管理所有資料, 但各參與協同的人員各自在 users 目錄下擁有一個 .leo 檔案, 可以分別控管本網誌的所有設定, 並且以協同方式維護網誌內容. 本網誌分為近端與 Github Pages 端的資料管理配置, 關鍵字搜尋採用 https://github.com/getpelican/pelican-plugins/tree/master/tipue_search , 近端的設定檔案為 local_publishconf.py, 而 Github Pages 端的特有設定為 publishconf.py, 且為了區隔兩端的資料連結差異, 近端的 Pelican 轉檔按鈕為 @button local pelican, 而 Github Pages 端的轉檔按鈕為 @button gh-pages pelican. 最後, 為了有效區隔各組員所寫的網誌文章, content 目錄內的各 .md 檔案, 除了要求必須冠上組員帳號外, 也希望在文章標題前面加上組員帳號標示, 以避免組員間因為使用相同的文章標題名稱而無法正確完成 Pelican 網誌的轉檔 (本系統採用自動文章標題轉換為 html 檔名的設定). 組員參與協同 所有專題製作成員均為 https://github.com/coursemdetw/project_site 倉儲的協同者, git clone 資料後, 即可將分支固定在 gh-pages 後進行各項資料協同管理的工作. 參與協同的步驟: git clone 倉儲資料. 確定在近端已經切換分支到 gh-pages, 利用 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案. 修改 @edit user_20160301.md 的標題與內容, 例如, 將 @edit user_20160301.md 改為 @edit 學號_20160301.md, 且將 \"Title: user - 使用者的範例網誌文章標題\" 改為 \"Title: 學號 - 使用者的範例網誌文章標題\", \"Author: user\" 改為 \"Author: 學號\" 之後, 記得將已經修改過的 user_template.leo 存為 學號.leo 檔案. 在學號.leo 專案檔案中, 將滑鼠停在 @button local pelican 節點上, 再點擊 local-pelican 按鈕進行轉檔, 最後利用瀏覽器開啟 project_site 目錄中的 index.html, 檢查是否在近端可以正確轉檔. 若近端的 Pelican 網誌可以正確納入所新增的文章內容, 改將滑鼠停在 @button gh-pages pelican 節點上, 再點擊 gh-pages-pelican 按鈕, 進行 Github Pages 端所需要的內容轉檔. 利用 git add -A, git commit -m \"訊息\", git push origin gh-pages 等3個步驟, 將 gh-pages 分支資料, 提交並推送到 http://project.mde.tw 網誌資料儲存規劃 一個靜態網站的內容除了文字檔案外, 還包括 Javascript 檔案, Brython 檔案, 圖檔, 影片檔案, 以及其他各種非 html 的文件檔, 為了保有本網誌專案倉儲的簡潔, 除了必要的設定與文字檔案外, 其他資料均存放在倉儲以外的相關資源位置, 其規劃如下: Javascript 與 Brython 程式檔案, 除了儘量使用各 CDN 所提供的最新版本外, 目前以 https://github.com/2015fallhw/cptocadp/tree/master/static 對應的 OpenShift 網站存放, 例如, Cango-8v03.js 位於 http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js 一般圖檔與非 html 文件檔案, 建議以 Github Pages 的網頁架構儲存在獨立的倉儲中, 且該倉儲僅存放檔案, 而無文字檔案, 例如: http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png 即為其中的一個圖檔. 影片檔案則分別存在 https://vimeo.com/ 與 https://www.youtube.com/ (相同檔案各存一份). 圖檔引用 影片檔引用 Gocycle_disassemble from 虎尾科大機械設計工程 on Vimeo . 特別提醒 本網誌為了同時支援近端與遠端的資料內容使用, 資料轉檔分為近端按鈕與遠端按鈕, 協同成員在推送資料到遠端之前, 必須確定資料為遠端 Github Pages 格式. 鼓勵各成員深入研究本網誌的細節架構, 勇於提出問題, 解決問題, 打造出最適合機械設計工程團隊使用的網際協同架構、模式與系統工具.","url":"http://project.mde.tw/blog/yen-2016-nian-zhuan-ti-qi-dong.html","title":"yen - 2016 年專題啟動"},{"tags":"Misc","text":"突然間, Github Pages 的網頁轉換機制不再更新 使用 Github Pages 建立網頁最大的問題就是, 在完全沒有任何錯誤訊息提醒的情況下, 送到 Github Pages 對應分支倉儲的資料不再成功轉為網頁資料. 因應之道, 只能刪除原先不再更新的倉儲, 另外再建立一個對應的 Github Pages 倉儲, 重新進行各項設定.","url":"http://project.mde.tw/blog/yen-github-pages-wang-ye-zi-liao-geng-xin-wen-ti.html","title":"yen - Github Pages 網頁資料更新問題"},{"tags":"Misc","text":"機械設計專題題目的分類, 一般就學門領域的組合, 可視為熱流體力學, 固體力學, 電子電機與資訊科技的綜合體. 雖然機械設計專題, 以設計流程為主, 但是通常離不開製造、控制與管理的範疇. 也就是說, 機械設計流程必須納入製造、控制與管理的層面, 才能得到更大的價值. 機械指的是機巧的配置, 而配置的內容, 來自熱流體力學, 固體力學, 電子電機與資訊科技的內涵, 其中更因不同的設計、製造、控制與管理流程, 而產生不同的功用. 至於設計則隱含內容的表達與驗證, 其表達的方式通常指口語表達, 文字表達, 2D 圖形表達, 3D 影像表達, 理論分析表達與實體原型的表達等六大類. 因此機械設計專題, 就可以從熱流體力學, 固體力學, 電子電機與資訊科技的組合搭配中, 納入各種設計、製造、控制與管理工具的運用, 最後用表達方式加以呈現的差異, 進行分類. 換言之, 機械設計專題的題目與施行內容的分類, 可以從3個大軸向切入: 所包含的學門領域軸向, 也就是熱流體力學, 固體力學, 電子電機與資訊科技等. 所牽涉的流程層面, 也就是設計、製造、控制與管理流程等. 所使用的表達方式, 也就是口語表達, 文字表達, 2D 圖形表達, 3D 影像表達, 理論分析表達與實體原型的表達等. 其中隸屬於設計的工程設計面, 又可細分為: 選用設計, 也就是從現有的零件或配件群中選用的設計. 配置設計, 也就是根據所選擇的零配件加以組合, 以決定設計的組合順序或組合方式. 參數設計, 也就是決定內容所需的數據或尺寸. 原創設計, 也就是前所未見的配置參數設計或前所未見的整體設計. 重新設計, 也就是根據的新的需求、新的材料與元件發明, 所進行的設計. 客製化設計, 又稱為多選項設計, 也就是設計中的每一個功能, 都提供客戶不同等級的元件選擇所牽涉的設計. 總之, 這裡針對機械設計專題題目分類的目的, 在讓選擇專題題目與製作內容的成員能有些初步概念, 儘管機械設計的範圍很廣, 能夠採用的方式與納入的內容也很多, 但是只要關注機械設計所牽涉的領域、流程與表達方法, 使專題題目具有代表性與功能性, 就能讓最後交付的內容更具價值.","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-fen-lei.html","title":"yen - 機械設計專題分類"},{"tags":"Misc","text":"如何將電腦教室分組, 比序與排座位的流程網際自動化 在 http://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html 中, 說明了一個實際的電腦教室排座位的流程, 其中使用了網際即時試算表 https://ethercalc.tw/ , 以及幾個 Python3 的資料處理程式, 最後可以根據電腦教室的配置, 完成各組員的座位編排. 座位編排流程如下: 讓所有學員自行分組 分組確定後, 根據學號比序, 產生各組組長 再根據各組組長學號, 再進行組長學號比序, 以決定各組的組序 完成各組序與各組內的組員順序後, 再根據座位編排規定, 最後列出學員座位表, 讓學員依序入座 本機械設計專題製作練習, 希望能夠利用網際程式方法, 以 https://github.com/mitsuhiko/flask , https://www.sqlite.org/ 將流程自動化, 當操作者從網際即時試算表中取得各組分組資料後, 可以輸入本練習所完成的網站表單中, 然後操作者可以根據頁面中的選項, 選擇各組選出組長的方式, 依據學號增量排序, 學號最小者為組長, 或遞減排序, 學號大者為組長, 或者亂數排序後, 排序第一組為組長等三種選擇. 接著操作者可以在頁面選擇組序排列的選項, 也是學號遞增排序, 學號遞減排序或學號亂數排序, 以便訂出各組的組序. 當操作者決定各組內與組外的排序選項後, 按下\"排電腦教室座位\" (也可加入排座位的選項, 列先排, 行先排或者全部按亂數排. 完成座位安排後, 必須將各組組員名單與分組名單分別存入資料庫, 以便後續讓使用者查詢各組座位與分組資訊, 並且在隨後 加入各組員回報電腦使用情形與各組員自評登錄成績之應用. 原始倉儲資料: https://github.com/2015fallhw/2016springcd/tree/gh-pages","url":"http://project.mde.tw/blog/yen-xie-tong-chan-pin-she-ji-ke-cheng-task0-yan-shen-lian-xi.html","title":"yen - 協同產品設計課程 Task0 延伸練習"},{"tags":"Tutorial","text":"這裡放入 user 所寫的文章摘要 這裡為 user 所寫的文章主要內容","url":"http://project.mde.tw/blog/user-shi-yong-zhe-de-fan-li-wang-zhi-wen-zhang-biao-ti.html","title":"user - 使用者的範例網誌文章標題"},{"tags":"2016bg2","text":"暑期第一個禮拜的 星期二 目前組合進度 目前遇到的狀況 我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態 滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。","url":"http://project.mde.tw/blog/40323250ri-zhi-1050628.html","title":"40323250日誌 - 105/06/28"},{"tags":"2016bg2","text":"暑期第一個禮拜的 星期三 進度 目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖: 以下是零件 以下是v-rep拆解後的截圖 簡易版 完整版 明天應該就可以開始測試模擬了。 Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。","url":"http://project.mde.tw/blog/40323250ri-zhi-1050629.html","title":"40323250日誌 - 105/06/29"},{"tags":"2016bg2","text":"Summer project 1.畫3D Printer (V-rep ,Onshape) 2.實驗室網站介面 3.Octopi ,機械手臂 4.OpenCV 5.RGA演算 6.認證主機(Virtual Box) 7.Proxy 8.報告(拍照 ,內容整理) 9.找碩班教授 暑期人數 : 七月:第一組3人 ,第二組4人 八月:第一組3人 ,第二組4人 ,第三組1人 You can't see me","url":"http://project.mde.tw/blog/summer-plan.html","title":"Summer Plan"},{"tags":"2016g1","text":"在Onshape上充實零件庫 日記: 今天將所有機械手臂零件全部合進零件庫，並用零件庫的零件再組合出一個組圖。今天沒有設定新的變數，未來將會新增有關手臂長度的零件參數，並由實際使用需求及感測器尺寸調整參數。 備註: 1.夾頭動力傳輸由原先畫的6齒圓齒輪改成25齒的正齒輪 6/28零件庫 組合圖","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-28ri.html","title":"40323143 -  日誌  105年6月28日"},{"tags":"2016bg2","text":"OpenCv example with python test 實作系統Ubuntu 14.04 以及 老師整合的檔案 範例網址1. 使用到的圖片 程式碼 import numpy as np import cv2 img = cv2.imread('messi.jpg',0) cv2.imshow('image',img) k = cv2.waitKey(0) if k == 27: # wait for ESC key to exit cv2.destroyAllWindows() elif k == ord('s'): # wait for 's' key to save and exit cv2.imwrite('messigray.png',img) cv2.destroyAllWindows() 執行結果 範例網址2. 程式碼 import numpy as np import cv2 cap = cv2.VideoCapture(0) while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow('frame',gray) if cv2.waitKey(1) & 0xFF == ord('q'): break When everything done, release the capture cap.release() cv2.destroyAllWindows() 執行結果 範例網址3.(同上) 程式碼 import numpy as np import cv2 cap = cv2.VideoCapture(0) Define the codec and create VideoWriter object fourcc = cv2.VideoWriter_fourcc(*'XVID') out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480)) while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,1) # write the flipped frame out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) & 0xFF == ord('q'): break else: break Release everything if job is finished cap.release() out.release() cv2.destroyAllWindows() 執行結果 得到檔案名稱為output的avi影片檔","url":"http://project.mde.tw/blog/opencvfan-li-zhi-xing.html","title":"OpenCv範例執行"},{"tags":"2016g1","text":"只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容 這裡為 40323130 所寫的文章主要內容 這是設計構想的全圖 我的想法是讓3D printer 在一個輸送帶上的平面列印，在輸送帶後方因為曲率不同使成品自然脫落，然後用一個盛盤接住成品一動到固定位置，使成盤傾斜讓成品掉落我們想要放置的位置。 我使用一個由上而往看下呈一個工字型的機構，因為我認為這種機構機構簡單、組裝容易、運動路徑明確，控制上應該比較方便，可以節省很多製造、控制上的麻煩。 動力方面想使用馬達接上摩擦輪驅動另外兩個摩擦輪，原本想用齒輪作為動力傳輸，但考慮到組原想要自己製造出來的想法，齒輪對我們來說製造難度太高，所以改用摩擦輪。 組裝上也是盡量用簡單方便的方法組裝，例如摩擦輪就只是挖一個槽用重力固定，馬達安裝是用夾板鎖螺栓固定，其餘都是鎖螺栓夾緊，在組裝上應該不會有困難。 零件圖:","url":"http://project.mde.tw/blog/40323143-3d-printer-lie-yin-wan-xia-liao-hou-de-cang-chu-ji-gou-she-ji-li-nian-ji-hui-tu.html","title":"40323143 - 3D printer 列印完下料後的倉儲機構設計理念及繪圖"},{"tags":"2016g1","text":"在Onshape上建立零件庫 日記: 今天將個人Onshape上的機械手臂部分零件合進零件庫，設定六個參數，分別是motor_fixhole , motor_x , motor_y , motor_z , suan_pan , degore 六個參數，motor_fixhole為設定馬達固定孔大小，motor_x , motor_y , motor_z為設定馬達的長寬高， suan_pan為設定旋盤的大小，大小為motor_y的1.7倍\u0007，degore為設定底座的直徑，大小為3倍的suan_pan。 合進零件庫的零件 參數設定","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-27ri.html","title":"40323143 -  日誌  105年6月27日"},{"tags":"2016g1","text":"研讀Octopi的設定檔 設定檔位置位在 /Octoprint/src/octoprint/setting.py 設定檔位置位在 /Octoprint/src/octoprint/static/less/octoprint.less 目前遇到的問題 host位置顯示在0.0.0.0:5000 可是網頁開起來無法顯示","url":"http://project.mde.tw/blog/40323131ri-zhi-1050628.html","title":"40323131日誌 105/06/28"},{"tags":"2016g1","text":"安裝wxpython 與 將control_3dprinter 從原本python2語法 修改成python3語法 python2語法 修改成python3語法 原本圖片的紅框處為 except IOError, x:為python2語法，將它修改成能在python3上執行 原來python2 為Queue 將它修改成queue 因為python3裡頭更改成queue了 還有要加上括號，因為python2上執行可以不需要括號起來，但是在python3上執行要加上小括號，目前找到這些語法問題 目前遇到的問題 在下圖執行的時候跑出name 'reload' is not define 上網google一下，找到了有可能是沒有reload到，所以多 import imp 可是又遇到了下圖的問題，好像是python2默認的使用的是ascii，要將它更改成utf-8，不過看起來沒有成功 想要執行一下，來確認一下是否更改成功，不過不知道為什麼又跑出name 'reload' is not define 目前卡在這邊，無法想通為什麼會變成這樣","url":"http://project.mde.tw/blog/40323131ri-zhi-1050630.html","title":"40323131日誌 105/06/30"},{"tags":"2016g1","text":"只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容 這裡為 40323130 所寫的文章主要內容 本機械設計專題網誌的架構包含近端與遠端的資料檢視設計, 專案資料以 Leo Editor 進行管理. 以下教學影片示範從 http://project.mde.tw 機械設計專題網誌中取得倉儲的網址後, 可以利用 git clone 複製倉儲資料, 之後: 利用 git checkout gh-pages 將工作目錄指到 Github pages 的對應分支內容 以 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案 根據自己的帳號, 修改 .md 檔案存檔的名稱, 目的在透過加入帳號與時間註記, 避免 content 目錄中的檔案彼此複寫 在 .md 的 Title 標題中, 冠上自己的帳號, 主要也是避免 Pelican 將 .md 根據標題轉成 html 時, 產生檔案複寫 本系統的 Pelican 分為近端與遠端轉檔按鈕, 因此若要在近端檢查時, 與要推送到 Github 時採用不同轉檔按鈕 為了簡化 git 指令的 add, commit 與 push, 加入 ungit, 只要啟動隨身系統候, 再利用 start_ungit.bat 開啟, 就可以在瀏覽器中簡化改版過程 Vimeo: 2016project_1 from 虎尾科大機械設計工程 on Vimeo . Youtube:","url":"http://project.mde.tw/blog/40323143-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html","title":"40323143 - 說明如何參與協同機械設計專題網誌編寫"},{"tags":"2016g1","text":"設定使用octopi與實作 octopi走乙太網路線進行控制以及連線 實際測試的照片以及需要用到的方法","url":"http://project.mde.tw/blog/octopice-shi-yu-shi-zuo.html","title":"Octopi測試與實作"},{"tags":"2016g1","text":"更新資料Wxpython for python3 安裝方法 https://www.youtube.com/watch?v=_djD5EHfNCw #先檢查網路 #確定python版本為python3.4 pip install -U --trusted-host wxpython.org --pre -f https://wxpython.org/Phoenix/snapshot-builds/ wxPython_Phoenix #記得打開terimal 檢查import wx #看有沒有成功 #因為要做串列傳輸Serial #要下指令安裝pyserial pip install pyserial 接下來先用範例程式測試串列傳輸 https://github.com/pyserial/pyserial/tree/master/examples # #!/usr/bin/env python # # A simple terminal application with wxPython. # # (C) 2001-2015 Chris Liechti # # SPDX-License-Identifier: BSD-3-Clause import codecs import serial import threading import wx import wxSerialConfigDialog SERIALRX = wx.NewEventType() # bind to serial data receive events EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0) class SerialRxEvent(wx.PyCommandEvent): eventType = SERIALRX def __init__(self, windowID, data): wx.PyCommandEvent.__init__(self, self.eventType, windowID) self.data = data def Clone(self): self.__class__(self.GetId(), self.data) # ---------------------------------------------------------------------- ID_CLEAR = wx.NewId() ID_SAVEAS = wx.NewId() ID_SETTINGS = wx.NewId() ID_TERM = wx.NewId() ID_EXIT = wx.NewId() ID_RTS = wx.NewId() ID_DTR = wx.NewId() NEWLINE_CR = 0 NEWLINE_LF = 1 NEWLINE_CRLF = 2 class TerminalSetup: \"\"\" Placeholder for various terminal settings. Used to pass the options to the TerminalSettingsDialog. \"\"\" def __init__(self): self.echo = False self.unprintable = False self.newline = NEWLINE_CRLF class TerminalSettingsDialog(wx.Dialog): \"\"\"Simple dialog with common terminal settings like echo, newline mode.\"\"\" def __init__(self, *args, **kwds): self.settings = kwds['settings'] del kwds['settings'] # begin wxGlade: TerminalSettingsDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.checkbox_echo = wx.CheckBox(self, -1, \"Local Echo\") self.checkbox_unprintable = wx.CheckBox(self, -1, \"Show unprintable characters\") self.radio_box_newline = wx.RadioBox(self, -1, \"Newline Handling\", choices=[\"CR only\", \"LF only\", \"CR+LF\"], majorDimension=0, style=wx.RA_SPECIFY_ROWS) self.sizer_4_staticbox = wx.StaticBox(self, -1, \"Input/Output\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade self.__attach_events() self.checkbox_echo.SetValue(self.settings.echo) self.checkbox_unprintable.SetValue(self.settings.unprintable) self.radio_box_newline.SetSelection(self.settings.newline) def __set_properties(self): # begin wxGlade: TerminalSettingsDialog.__set_properties self.SetTitle(\"Terminal Settings\") self.radio_box_newline.SetSelection(0) self.button_ok.SetDefault() # end wxGlade def __do_layout(self): # begin wxGlade: TerminalSettingsDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_4_staticbox.Lower() sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL) sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4) sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4) sizer_4.Add(self.radio_box_newline, 0, 0, 0) sizer_2.Add(sizer_4, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId()) self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId()) def OnOK(self, events): \"\"\"Update data wil new values and close dialog.\"\"\" self.settings.echo = self.checkbox_echo.GetValue() self.settings.unprintable = self.checkbox_unprintable.GetValue() self.settings.newline = self.radio_box_newline.GetSelection() self.EndModal(wx.ID_OK) def OnCancel(self, events): \"\"\"Do not update data but close dialog.\"\"\" self.EndModal(wx.ID_CANCEL) # end of class TerminalSettingsDialog class TerminalFrame(wx.Frame): \"\"\"Simple terminal program for wxPython\"\"\" def __init__(self, *args, **kwds): self.serial = serial.Serial() self.serial.timeout = 0.5 # make sure that the alive event can be checked from time to time self.settings = TerminalSetup() # placeholder for the settings self.thread = None self.alive = threading.Event() # begin wxGlade: TerminalFrame.__init__ kwds[\"style\"] = wx.DEFAULT_FRAME_STYLE wx.Frame.__init__(self, *args, **kwds) # Menu Bar self.frame_terminal_menubar = wx.MenuBar() wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_CLEAR, \"&Clear;\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.Append(ID_SAVEAS, \"&Save; Text As...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_TERM, \"&Terminal; Settings...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_EXIT, \"&Exit;\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"&File;\") wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_RTS, \"RTS\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_DTR, \"&DTR;\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_SETTINGS, \"&Port; Settings...\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"Serial Port\") self.SetMenuBar(self.frame_terminal_menubar) # Menu Bar end self.text_ctrl_output = wx.TextCtrl(self, -1, \"\", style=wx.TE_MULTILINE | wx.TE_READONLY) self.__set_properties() self.__do_layout() self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS) self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) # end wxGlade self.__attach_events() # register events self.OnPortSettings(None) # call setup dialog on startup, opens port if not self.alive.isSet(): self.Close() def StartThread(self): \"\"\"Start the receiver thread\"\"\" self.thread = threading.Thread(target=self.ComPortThread) self.thread.setDaemon(1) self.alive.set() self.thread.start() self.serial.rts = True self.serial.dtr = True self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts) self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr) def StopThread(self): \"\"\"Stop the receiver thread, wait until it's finished.\"\"\" if self.thread is not None: self.alive.clear() # clear alive event for thread self.thread.join() # wait until thread has finished self.thread = None def __set_properties(self): # begin wxGlade: TerminalFrame.__set_properties self.SetTitle(\"Serial Terminal\") self.SetSize((546, 383)) self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, \"\")) # end wxGlade def __do_layout(self): # begin wxGlade: TerminalFrame.__do_layout sizer_1 = wx.BoxSizer(wx.VERTICAL) sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0) self.SetSizer(sizer_1) self.Layout() # end wxGlade def __attach_events(self): # register events at the controls self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey) self.Bind(EVT_SERIALRX, self.OnSerialRead) self.Bind(wx.EVT_CLOSE, self.OnClose) def OnExit(self, event): # wxGlade: TerminalFrame. \"\"\"Menu point Exit\"\"\" self.Close() def OnClose(self, event): \"\"\"Called on application shutdown.\"\"\" self.StopThread() # stop reader thread self.serial.close() # cleanup self.Destroy() # close windows, exit app def OnSaveAs(self, event): # wxGlade: TerminalFrame. \"\"\"Save contents of output window.\"\"\" with wx.FileDialog( None, \"Save Text As...\", \".\", \"\", \"Text File|*.txt|All Files|*\", wx.SAVE) as dlg: if dlg.ShowModal() == wx.ID_OK: filename = dlg.GetPath() with codecs.open(filename, 'w', encoding='utf-8') as f: text = self.text_ctrl_output.GetValue().encode(\"utf-8\") f.write(text) def OnClear(self, event): # wxGlade: TerminalFrame. \"\"\"Clear contents of output window.\"\"\" self.text_ctrl_output.Clear() def OnPortSettings(self, event): # wxGlade: TerminalFrame. \"\"\" Show the port settings dialog. The reader thread is stopped for the settings change. \"\"\" if event is not None: # will be none when called on startup self.StopThread() self.serial.close() ok = False while not ok: with wxSerialConfigDialog.SerialConfigDialog( self, -1, \"\", show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW, serial=self.serial) as dialog_serial_cfg: dialog_serial_cfg.CenterOnParent() result = dialog_serial_cfg.ShowModal() # open port if not called on startup, open it on startup and OK too if result == wx.ID_OK or event is not None: try: self.serial.open() except serial.SerialException as e: with wx.MessageDialog(self, str(e), \"Serial Port Error\", wx.OK | wx.ICON_ERROR)as dlg: dlg.ShowModal() else: self.StartThread() self.SetTitle(\"Serial Terminal on {} [{},{},{},{}{}{}]\".format( self.serial.portstr, self.serial.baudrate, self.serial.bytesize, self.serial.parity, self.serial.stopbits, ' RTS/CTS' if self.serial.rtscts else '', ' Xon/Xoff' if self.serial.xonxoff else '', )) ok = True else: # on startup, dialog aborted self.alive.clear() ok = True def OnTermSettings(self, event): # wxGlade: TerminalFrame. \"\"\"\\ Menu point Terminal Settings. Show the settings dialog with the current terminal settings. \"\"\" with TerminalSettingsDialog(self, -1, \"\", settings=self.settings) as dialog: dialog.CenterOnParent() dialog.ShowModal() def OnKey(self, event): \"\"\"\\ Key event handler. If the key is in the ASCII range, write it to the serial port. Newline handling and local echo is also done here. \"\"\" code = event.GetUnicodeKey() if code < 256: # XXX bug in some versions of wx returning only capital letters code = event.GetKeyCode() if code == 13: # is it a newline? (check for CR which is the RETURN key) if self.settings.echo: # do echo if needed self.text_ctrl_output.AppendText('\\n') if self.settings.newline == NEWLINE_CR: self.serial.write(b'\\r') # send CR elif self.settings.newline == NEWLINE_LF: self.serial.write(b'\\n') # send LF elif self.settings.newline == NEWLINE_CRLF: self.serial.write(b'\\r\\n') # send CR+LF else: char = unichr(code) if self.settings.echo: # do echo if needed self.WriteText(char) self.serial.write(char.encode('UTF-8', 'replace')) # send the character def WriteText(self, text): if self.settings.unprintable: text = ''.join([c if (c >= ' ' and c != '\\x7f') else unichr(0x2400 + ord(c)) for c in text]) self.text_ctrl_output.AppendText(text) def OnSerialRead(self, event): \"\"\"Handle input from the serial port.\"\"\" self.WriteText(event.data.decode('UTF-8', 'replace')) def ComPortThread(self): \"\"\"\\ Thread that handles the incoming traffic. Does the basic input transformation (newlines) and generates an SerialRxEvent \"\"\" while self.alive.isSet(): b = self.serial.read(self.serial.in_waiting or 1) if b: # newline transformation if self.settings.newline == NEWLINE_CR: b = b.replace(b'\\r', b'\\n') elif self.settings.newline == NEWLINE_LF: pass elif self.settings.newline == NEWLINE_CRLF: b = b.replace(b'\\r\\n', b'\\n') event = SerialRxEvent(self.GetId(), b) self.GetEventHandler().AddPendingEvent(event) def OnRTS(self, event): # wxGlade: TerminalFrame. self.serial.rts = event.IsChecked() def OnDTR(self, event): # wxGlade: TerminalFrame. self.serial.dtr = event.Checked() # end of class TerminalFrame class MyApp(wx.App): def OnInit(self): wx.InitAllImageHandlers() frame_terminal = TerminalFrame(None, -1, \"\") self.SetTopWindow(frame_terminal) frame_terminal.Show(True) return 1 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop() wxSerialConfigDialog.py #!/usr/bin/env python # # A serial port configuration dialog for wxPython. A number of flags can # be used to configure the fields that are displayed. # # (C) 2001-2015 Chris Liechti # # SPDX-License-Identifier: BSD-3-Clause import wx import serial import serial.tools.list_ports SHOW_BAUDRATE = 1 << 0 SHOW_FORMAT = 1 << 1 SHOW_FLOW = 1 << 2 SHOW_TIMEOUT = 1 << 3 SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT class SerialConfigDialog(wx.Dialog): \"\"\"\\ Serial Port configuration dialog, to be used with pySerial 2.0+ When instantiating a class of this dialog, then the \"serial\" keyword argument is mandatory. It is a reference to a serial.Serial instance. the optional \"show\" keyword argument can be used to show/hide different settings. The default is SHOW_ALL which corresponds to SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be found in this module (not the class). \"\"\" def __init__(self, *args, **kwds): # grab the serial keyword and remove it from the dict self.serial = kwds['serial'] del kwds['serial'] self.show = SHOW_ALL if 'show' in kwds: self.show = kwds.pop('show') # begin wxGlade: SerialConfigDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.label_2 = wx.StaticText(self, -1, \"Port\") self.choice_port = wx.Choice(self, -1, choices=[]) self.label_1 = wx.StaticText(self, -1, \"Baudrate\") self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN) self.sizer_1_staticbox = wx.StaticBox(self, -1, \"Basics\") self.panel_format = wx.Panel(self, -1) self.label_3 = wx.StaticText(self.panel_format, -1, \"Data Bits\") self.choice_databits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_4 = wx.StaticText(self.panel_format, -1, \"Stop Bits\") self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_5 = wx.StaticText(self.panel_format, -1, \"Parity\") self.choice_parity = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, \"Data Format\") self.panel_timeout = wx.Panel(self, -1) self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, \"Use Timeout\") self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, \"\") self.label_6 = wx.StaticText(self.panel_timeout, -1, \"seconds\") self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, \"Timeout\") self.panel_flow = wx.Panel(self, -1) self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, \"RTS/CTS\") self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, \"Xon/Xoff\") self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, \"Flow Control\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade # attach the event handlers self.__attach_events() def __set_properties(self): # begin wxGlade: SerialConfigDialog.__set_properties self.SetTitle(\"Serial Port Configuration\") self.choice_databits.SetSelection(0) self.choice_stopbits.SetSelection(0) self.choice_parity.SetSelection(0) self.text_ctrl_timeout.Enable(False) self.button_ok.SetDefault() # end wxGlade self.SetTitle(\"Serial Port Configuration\") if self.show & SHOW_TIMEOUT: self.text_ctrl_timeout.Enable(0) self.button_ok.SetDefault() if not self.show & SHOW_BAUDRATE: self.label_1.Hide() self.combo_box_baudrate.Hide() if not self.show & SHOW_FORMAT: self.panel_format.Hide() if not self.show & SHOW_TIMEOUT: self.panel_timeout.Hide() if not self.show & SHOW_FLOW: self.panel_flow.Hide() # fill in ports and select current setting preferred_index = 0 self.choice_port.Clear() self.ports = [] for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())): self.choice_port.Append(u'{} - {}'.format(portname, desc)) self.ports.append(portname) if self.serial.name == portname: preferred_index = n self.choice_port.SetSelection(preferred_index) if self.show & SHOW_BAUDRATE: preferred_index = None # fill in baud rates and select current setting self.combo_box_baudrate.Clear() for n, baudrate in enumerate(self.serial.BAUDRATES): self.combo_box_baudrate.Append(str(baudrate)) if self.serial.baudrate == baudrate: preferred_index = n if preferred_index is not None: self.combo_box_baudrate.SetSelection(preferred_index) else: self.combo_box_baudrate.SetValue(u'{}'.format(self.serial.baudrate)) if self.show & SHOW_FORMAT: # fill in data bits and select current setting self.choice_databits.Clear() for n, bytesize in enumerate(self.serial.BYTESIZES): self.choice_databits.Append(str(bytesize)) if self.serial.bytesize == bytesize: index = n self.choice_databits.SetSelection(index) # fill in stop bits and select current setting self.choice_stopbits.Clear() for n, stopbits in enumerate(self.serial.STOPBITS): self.choice_stopbits.Append(str(stopbits)) if self.serial.stopbits == stopbits: index = n self.choice_stopbits.SetSelection(index) # fill in parities and select current setting self.choice_parity.Clear() for n, parity in enumerate(self.serial.PARITIES): self.choice_parity.Append(str(serial.PARITY_NAMES[parity])) if self.serial.parity == parity: index = n self.choice_parity.SetSelection(index) if self.show & SHOW_TIMEOUT: # set the timeout mode and value if self.serial.timeout is None: self.checkbox_timeout.SetValue(False) self.text_ctrl_timeout.Enable(False) else: self.checkbox_timeout.SetValue(True) self.text_ctrl_timeout.Enable(True) self.text_ctrl_timeout.SetValue(str(self.serial.timeout)) if self.show & SHOW_FLOW: # set the rtscts mode self.checkbox_rtscts.SetValue(self.serial.rtscts) # set the rtscts mode self.checkbox_xonxoff.SetValue(self.serial.xonxoff) def __do_layout(self): # begin wxGlade: SerialConfigDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_flow_staticbox.Lower() sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL) self.sizer_timeout_staticbox.Lower() sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL) self.sizer_format_staticbox.Lower() sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL) grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0) self.sizer_1_staticbox.Lower() sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL) sizer_basics = wx.FlexGridSizer(3, 2, 0, 0) sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0) sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0) sizer_basics.AddGrowableCol(1) sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0) sizer_2.Add(sizer_1, 0, wx.EXPAND, 0) grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0) self.panel_format.SetSizer(sizer_format) sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0) sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0) sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) self.panel_timeout.SetSizer(sizer_timeout) sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0) sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add((10, 10), 1, wx.EXPAND, 0) self.panel_flow.SetSizer(sizer_flow) sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK) wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel) if self.show & SHOW_TIMEOUT: wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout) def OnOK(self, events): success = True self.serial.port = self.ports[self.choice_port.GetSelection()] if self.show & SHOW_BAUDRATE: try: b = int(self.combo_box_baudrate.GetValue()) except ValueError: with wx.MessageDialog( self, 'Baudrate must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.baudrate = b if self.show & SHOW_FORMAT: self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()] self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()] self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()] if self.show & SHOW_FLOW: self.serial.rtscts = self.checkbox_rtscts.GetValue() self.serial.xonxoff = self.checkbox_xonxoff.GetValue() if self.show & SHOW_TIMEOUT: if self.checkbox_timeout.GetValue(): try: self.serial.timeout = float(self.text_ctrl_timeout.GetValue()) except ValueError: with wx.MessageDialog( self, 'Timeout must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.timeout = None if success: self.EndModal(wx.ID_OK) def OnCancel(self, events): self.EndModal(wx.ID_CANCEL) def OnTimeout(self, events): if self.checkbox_timeout.GetValue(): self.text_ctrl_timeout.Enable(True) else: self.text_ctrl_timeout.Enable(False) # end of class SerialConfigDialog class MyApp(wx.App): \"\"\"Test code\"\"\" def OnInit(self): wx.InitAllImageHandlers() ser = serial.Serial() print(ser) # loop until cancel is pressed, old values are used as start for the next run # show the different views, one after the other # value are kept. for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL): dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser, show=flags) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break # the user can play around with the values, CANCEL aborts the loop while True: dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break return 0 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop()","url":"http://project.mde.tw/blog/pyserial.html","title":"PySerial"},{"tags":"2016g1","text":"找到的些許文章和探討 在Octoprint底下有個資料夾 底層有些方法包括模組以及設定檔 linux指令: cp mv 指令再raspberry pi 要熟悉，因為在搬移檔案以及設定檔案，會常使用到，以及設定需要的檔案，像是網路的方法，以及未來可能要用到的USB掛載傳輸資料或者使用 #先檢查自己找到的usb數量 $ sudo fdisk -l #...省略.... #Device Boot Start End Sectors Size Id Type #/dev/mmcblk0p1 8192 137215 129024 63M c W95 FAT32 (LBA) #/dev/mmcblk0p2 137216 31116287 30979072 14.8G 83 Linux $ sudo mkdir /media/usbstick $ sudo chown pi:pi /media/usbstick #手動掛載 $ sudo mount -t vfat -o uid=pi,gid=pi /dev/sda1 /media/usbstick #就可以進行存取 #要拔除時要下指令 $ sudo umount /media/usbstick 在這些設定檔中使用到的可以更改圖片或者是把程式碼拿出來理解目前解讀進度: 1.再octoprint中有將各模組拆開來，近日把python的設定看完，可能會接近5%的進度 2.圖片用到的部分，可能要從新Make(command)才可以用 待完成部分: 1.javascript 2.往後寫出一套for our flask.py 3.plugin部分","url":"http://project.mde.tw/blog/shu-mei-pai-zhi-ling-biao-he-shi-yong.html","title":"樹梅派指令表和使用"},{"tags":"2016g1","text":"關於IPV4 IPV6設定 #先檢查網路 $ ifconfig #修改/etc/network/interface的檔案 # interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback sudo eth0 iface eth0 inet static address 140.130.17.105 netmask 255.255.255.0 network 140.130.17.0 broadcast 140.130.17.255 gateway 140.130.17.254 # dns-* options are implemented by the resolvconf package, if $ dns-nameservers 140.130.1.2 140.130.17.3 168.95.1.1 dns-search mde.nfu.edu.tw #老師的地址3004 #從新啟動 可以到IPV6的網站測試是否可以連線 試用ubuntu系統改成IPV6和IPV4使用，並測試速度的使用上的問題，主要是在沒有IPV6的網站沒辦法連上去，這部份可能需要依靠proxy進行代理伺服器","url":"http://project.mde.tw/blog/ubuntu-ipv4-ipv6-shi-yong-jiao-xue.html","title":"ubuntu IPV4 IPV6 使用教學"},{"tags":"2016g1","text":"raspberry pi connect 3d printer to control the 3d printer 1.回報目前專題進度: 事項一:目前題目定義 製作一台3D printer跟atom同樣款式的 事項二:因為有三組的成員，目前分配如下所示 40323123 這組:利用octopi來進行遠端控制，以及自動下料等的問題，自動下料的機構利用GA進行運算 40323250 這組:進行組裝，設計，Onshape組裝，V-Rep(組裝設計模擬) 黃婉菁這組:先利用opencv來產生3d module並轉換成stl進行列印(主要目的影像建模出3Dstl) 參考資料: 1.octopi octopi 2.octoprintDocs octoprint Docs 3.octopi_github octoprint WIKI FAQ Github 4.flux 3d printer中的底板樣式以及掃描方式 5.OpenCv 3d nodule OpenCv可參考","url":"http://project.mde.tw/blog/40323123-zhuan-ti-can-kao-zi-liao.html","title":"40323123 - 專題參考資料"},{"tags":"2016g1","text":"Control 3D printer and some Question 1.第一步清理平台 2.幫滑軌上專用潤滑油 3.加熱後將線材退出 4.清理機台外觀 5.確保滑軌滑動順利 約兩個禮拜做一次，自動校正，不要太長使用，會導致買新的噴頭。 詳細注意事項，在另行公告","url":"http://project.mde.tw/blog/bao-yang-3dlie-yin-ji.html","title":"保養3D列印機"},{"tags":"2016g1","text":"OpenCv in python and use 實作系統Ubuntu 14.04 剛開始必須要先安裝依些相關的compiler以及設定黨 步驟如同老師所下載的順序 apt-get 更新 $ sudo apt-get update apt-get 升級 $ sudo apt-get upgrade 安裝所需的開發套件 $ sudo apt-get install build-essential cmake git pkg-config 安裝編譯過程所需的程式庫 $ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev 安裝編譯過程所需的程式庫 $ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev 安裝編譯過程所需的程式庫 $ sudo apt-get install libgtk2.0-dev 安裝編譯過程所需的 fortran 編譯器 $ sudo apt-get install libatlas-base-dev gfortran 安裝編譯過程所需的原始碼 $ sudo apt-get install python3.4-dev 本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy 模組 $ sudo pip3 install numpy 希望在帳號目錄下的 tmp 進行編譯工作 $ cd new folder $ mkdir tmp 更換目錄到 tmp $ cd tmp 利用 git clone 取得原始碼 $ git clone https://github.com/Itseez/opencv.git 準備進入倉儲切換分支 $ cd opencv 採用 3.1.0 版 $ git checkout 3.1.0 回到用戶目錄 $ cd .. 再利用 git clone 下載原始碼 $ git clone https://github.com/Itseez/opencv_contrib.git 準備進入倉儲切換分支 $ cd opencv_contrib 與 opencv 配合, 採用 3.1.0 版 $ git checkout 3.1.0 $ cd .. 準備開始建立程式庫 $ cd opencv $ mkdir build $ cd build 這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案 $ cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_C_EXAMPLES=OFF \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D PYTHON_EXECUTABLE=$(which python3) \\ -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \\ -D BUILD_EXAMPLES=ON .. $ make -j4 $ sudo make install $ sudo ldconfig 有做些許更改同樣也可以達到使用上的設定 windows中 只需要開起2016spring中把py檔 用cmd line 來執行 下python3 你的程式碼的名子 只要有攝影機就可以執行 請注意 必須要裝好攝影機的驅動才可以執行cvcapture(0) 否則無法執行 0是預設的第1台攝影機 1是第2台 以此類推","url":"http://project.mde.tw/blog/opencvshi-zuo.html","title":"OpenCv實作"},{"tags":"2016g1","text":"新的R2C2資料 中間有新的資料for raspberrypi 是使用node.js啟動server client端可以看到的 https://github.com/nneves/Raspberrypi_NodeJS RaspberryPi R2C2","url":"http://project.mde.tw/blog/r2c2de-zi-liao.html","title":"R2C2的資料"},{"tags":"2016g1","text":"raspberry pi connect 3d printer to control the 3d printer 遠端控制3D列印 這邊使用的遠端列印是使用web client控制 目前有兩套在觀望的系統~ 一個是 octopi 另一個是 Astropromt 或者是我們自己寫一套 兩套皆使用樹梅派當為控制電腦及server 使用心得:在之前已經有安裝過octopi，使用狀況是不錯，但是gui介面有些許的問題，使用上是沒什麼大礙，在3D printer的控制板，做動方式，像是一般CNC一樣，接收 G指令 Gcoce 大全 控制系統的code解析 這兩套系統，都有開放原始碼，不過因為解析程式有巨大的阻礙，因為對python和樹梅派不熟悉，導致只會安裝不會自己編譯。","url":"http://project.mde.tw/blog/40323123-3d-printer.html","title":"40323123 - 3d printer"},{"tags":"2016g1","text":"這裡放入 40323123 所寫的文章摘要 這裡為 40323123 所寫的文章主要內容","url":"http://project.mde.tw/blog/40323123-zhuan-ti-zu-yuan-de-fan-li-wen-zhang-biao-ti.html","title":"40323123 - 專題組員的範例文章標題"}]}