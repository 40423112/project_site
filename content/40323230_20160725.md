Title: 40323230紀錄 - SLVS資料庫函式
Category: 2016bg2
Tags: Kmol, SWIG, Solvespace, CDemo, Python-Solvespace
Author: 40323230


`slvs`資料庫（`_slvs.pyd`或`_slvs.so`）轉成Python後的內容。

協助Python程式使用指令。

＊ <kbd>Tips</kbd> 的標籤是比較實用的註解。

*內容待勘誤*

*07/29更新*

<!-- PELICAN_END_SUMMARY -->

<h2>前言 :</h2>

`DOC.txt`是原本`CDemo.c`編譯成`CDemo.exe`前的使用解說。

裡面的名稱結構是使用C語言的方式，雖然`slvs.py`已經幫忙轉換了裡面的名稱，但是仍有些許函式名稱變化。

所以紀錄一下在Python中如何使用這些功能，並稍微翻譯其內容；而手冊中不清楚的地方也會補充。

預計讓這篇文章達到易使用和易理解的功能。

<img src="http://i.imgur.com/p85ZpZV.jpg" >

直接命令相關代號：

```
sys = 系統

g, hg = 群組編號

h = 寫入項目名稱
```

由於內容較多，尋找時，可以使用<kbd>Ctrl</kbd>+<kbd>F</kbd>搜尋關鍵字。

稱號下方是原始的命令代號，用於Solve Space圖形化介面的按鈕對應。

<h2>預期運行結果 :</h2>

若要使用SLVS資料庫，必須透過`slvs.py`介面來轉換。

在你的Python程式中使用以下指令：

<pre class="brush: python">
#導入slvs.py
from slvs import *

#導入Solid Python
#沒有使用就不需要導入
import solid

#創造你的系統，以及支援單位數量
#支援單位數量上限端看Python的記憶體數量
#預設單位數為50
sys = System(20)

...
</pre>

欲執行解題，Python必須使用下列命令：

<pre class="brush: python">
#執行解題
sys.solve()
#直接命令
Slvs_Solve(sys, g)

#結果回報的值如下
if (sys.result == SLVS_RESULT_OKAY):
    ...
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    ...
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    ...
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    ...
</pre>

在執行解題程式後，會出現三種結果：

1. 所有約束都能滿足，會回傳`SLVS_RESULT_OKAY`，`param`中的內容也會更新。

2. 解題程式能夠證明約束條件互相牴觸，會傳回`SLVS_RESULT_INCONSISTENT`，相關約束的列表會產生在`failed`列表中。

3. 解題程式能夠證明約束條件沒有互相牴觸，但也沒有完全約束，會傳回`SLVS_RESULT_DIDNT_CONVERGE`，相關約束的列表會產生在`failed`列表中。

最後能調用以下值來檢查結果。

<pre class="brush: python">
#實體結果
#格式為%.3f
sys.get_param(0).val

#約束結果
#格式為%lu
sys.failed[i]
</pre>

而過於嚴重的錯誤會回傳`SLVS_RESULT_TOO_MANY_UNKNOWNS`，必須檢查整個程式。

TYPES OF ENTITIES
===================

`SLVS_E`

實體的類型，屬於物件的部分。

1. <kbd>Point3D</kbd> 此物件屬於3D點。

1. <kbd>Point2D</kbd> 此物件屬於2D點。

1. <kbd>Normal3D</kbd> 此物件屬於3D向量。

1. <kbd>Normal2D</kbd> 此物件屬於2D向量。

1. <kbd>Line3D</kbd> 此物件屬於3D線段。

1. <kbd>Line2D</kbd> 此物件屬於2D線段。

1. <kbd>Curve</kbd> 此物件屬於曲線。

1. <kbd>Circular</kbd> 此物件屬於圓弧。

1. <kbd>WorkPlane</kbd> 此物件屬於工作平面。

實體可以馬上建立物件並用傳統結構的方式導入。

建立物件後也能用轉換好的`slvs.py`函式呼叫。

或是使用直接指令建立物件。

輸入值後方加入`, sys`，以傳入系統清單`sys`中；亦可用`sys.add_`加入以下支援的實體，而取出的編號取決於註冊的順序。

```
add_param( )
add_point2d( )
add_point3d( )
add_entity( )
```

取出時亦同（函數中加上編號就能指定）：

```
get_Point2d( )
get_Point3d( )
get_LineSegment2d( )
get_LineSegment3d( )
get_Normal3d( )
get_Distance( )
get_Workplane( )
get_Cubic( )
get_Circle( )
get_ArcOfCircle( )
```

而查詢實體類型可以用：

```
entity_type( )
```

＊若沒有使用`sys`的註冊，將會被警告註冊值不可為`Null`。

Point in 3D <kbd>Point3D</kbd>
----------------------------

`SLVS_E_POINT_IN_3D`

使用指令：

<pre class="brush: python">
#標準
a = sys.add_param(10.0) #X軸座標
b = sys.add_param(20.0) #Y軸座標
c = sys.add_param(30.0) #Z軸座標
p = sys.add_point3d(a, b, c)
#直接命令
Slvs_MakePoint3d(h, group, x, y, z)
#簡化
p = Point3d(a, b, c)
</pre>

`p`代表空間中的輸入點。

Point in 2D  <kbd>Point2D</kbd>
----------------------------

`SLVS_E_POINT_IN_2D`

使用指令：

<pre class="brush: python">
#標準
wrkpl = Workplane(p1, wnormal) #某個工作平面
a = sys.add_param(10.0) #U軸座標
b = sys.add_param(20.0) #V軸座標
p = sys.add_point2d(wrkpl, a, b)
#直接命令
Slvs_MakePoint2d(h, g, wrkpl, u, v)
#簡化
p = Point2d(wplane, a, b)
</pre>

`p`代表工作平面上的輸入點。

Normal in 3D <kbd>Normal3D</kbd>
----------------------------

`SLVS_E_NORMAL_IN_3D`

使用指令：

<pre class="brush: python">
#標準
w = sys.add_param(10.0) #實數座標
a = sys.add_param(20.0) #X軸座標
b = sys.add_param(30.0) #Y軸座標
c = sys.add_param(40.0) #Z軸座標
p = Normal3d(w, a, b, c)
#直接命令
Slvs_MakeNormal3d(h, g, qw, qx, qy, qz)
</pre>

`p`代表空間中的一條法線。

在SolveSpace中，法線是由一個3x3的旋轉矩陣從基本的坐標系到一個新的架構，是由單位四元數定義的。

可以想像這個四元數代表一個通過原點的平面。

這個平面跟三個向量相關：基礎向量`U`和`V`在平面上、而法線`N`則垂直它，相當於`[ U V N ]'`。

因此U、N、N都有單位長度，而他們都正交，所以：

```
U cross V = N
V cross N = U
N cross U = V
```

轉換函式`Slvs_Quaternion`提供了在`U`、`V`、`N`和單位四元數之間轉換。

單位四元數只有三個自由度，但是要在四個參數中指定。因此一個額外的約束產生了，就是：

`w^2 + x^2 + y^2 + z^2 = 1`

Make a Quaternion for a Work Plane <kbd>Tips</kbd>
----------------------------

要定義一個由`U[1 0 0]`向量（等同X軸）和`V[0 1 0]`向量（等同Y軸）組成的平面，是需要一條3D法線的。

若是不會計算四元數，可以利用下列函式達成：

<pre class="brush: python">
#函式轉換四元數
qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0)

#帶入3D法線的函式中
normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys)

#做成工作平面
o = Point3d(Param(0.0), Param(0.0), Param(0.0))
plane = Workplane(o, normal)
</pre>

這個公式在製作2D平面時非常方便。

以下是不同平面參考：

```
XY平面：[1 0 0], [0 1 0]
MakeQuaternion(1, 0, 0, 0, 1, 0)

YZ平面：[0 1 0], [0 0 1]
MakeQuaternion(0, 1, 0, 0, 0, 1)

XZ平面：[1 0 0], [0 0 1]
MakeQuaternion(1, 0, 0, 0, 0, 1)
```

Normal in 2D <kbd>Normal2D</kbd>
----------------------------

`SLVS_E_NORMAL_IN_2D`

使用指令：

<pre class="brush: python">
#直接命令
wrkpl = Workplane(p1, wnormal) #某個工作平面
Slvs_MakeNormal2d(h, g, wrkpl)
#這個函式沒有簡化
</pre>

代表垂直工作平面的一條法線。

Distance
----------------------------

`SLVS_E_DISTANCE`

使用指令：

<pre class="brush: python">
#標準
wrkpl = Workplane(p1, wnormal) #某個工作平面
r = sys.add_param(10.0) #距離d
p = Distance(wplane, r)
#直接命令
Slvs_MakeDistance(h, g, wrkpl, d)

</pre>

`p`代表與工作平面平行的距離。

Work Plane <kbd>WorkPlane</kbd>
----------------------------

`SLVS_E_WORKPLANE`

使用指令：

<pre class="brush: python">
#標準
normal = Normal3d(1, 0, 0, 0) #某個法線
o = Point3d(10, 10, 10) #某個點
p = Workplane(o, normal)
#直接命令
Slvs_MakeWorkplane(h, g, o, normal)
</pre>

`p`代表通過原點，與法線垂直的工作平面。

Line Segment <kbd>Line2D/3D</kbd>
----------------------------

`SLVS_E_LINE_SEGMENT`

使用指令：

<pre class="brush: python">
#標準
wrkpl = Workplane(p1, wnormal) #某個工作平面
a = Point3d(0, 0, 0) #某個3D點
b = Point3d(10, 10, 10) #某個3D點
c = Point2d(wplane, 0, 0) #某個2D點
d = Point2d(wplane, 10, 10) #某個2D點
p = LineSegment2d(wrkpl, c, d)
p = LineSegment3d(a, b)
#直接命令
Slvs_MakeLineSegment(h, group, wrkpl, ptA, ptB)
</pre>

這個函式在直接命令上是2D的方式繪出線條。

`p`代表兩個點之間的連線。

Cubic <kbd>Cubic</kbd>
----------------------------

`SLVS_E_CUBIC`

使用指令：

<pre class="brush: python">
#標準
wrkpl = Workplane(p1, wnormal) #某個工作平面
a = Point3d(0, 0, 0) #第零個點
b = Point3d(10, 0, 0) #第一個點
c = Point3d(0, 10, 0) #第二個點
d = Point3d(0, 0, 10) #第三個點
p = Cubic(wrkpl, a, b, c, d)
#直接命令
Slvs_MakeCubic(h, group, wrkpl, pt0, pt1, pt2, pt3)
</pre>

`p`代表四個點構成的貝茲曲線。

四個點可以是四個3D點，也可以是四個2D和工作平面構成。

四個點的公式如下：

<pre class="brush: python">
#公式（t從0積分到1）
p(t) = P0*(1 - t)^3 + 3*P1*(1 - t)^2*t + 3*P2*(1 - t)*t^2 + P3*t^3
</pre>

Circle <kbd>Circular</kbd>
----------------------------

`SLVS_E_CIRCLE`

使用指令：

<pre class="brush: python">
#標準
wrkpl = Workplane(p1, wnormal) #某個工作平面
normal = Normal3d(1, 0, 0, 0) #某條3D法線
o = Point2d(wplane, 0, 0) #圓心
r = Distance(wplane, 20) #半徑
p = Circle(wrkpl, normal, o, r)
#直接命令
Slvs_MakeCircle(h, group, wrkpl, center, normal, radius)
</pre>

`p`代表與一條法線垂直（可選：或與一個平面平行），由圓心和半徑構成的完整圓。

Arc of Circle <kbd>Circular</kbd>
----------------------------

SLVS_E_ARC_OF_CIRCLE

使用指令：

<pre class="brush: python">
#標準
wrkpl = Workplane(p1, wnormal) #某個工作平面
o = Point2d(wplane, 0, 0) #圓心
s = Point2d(wplane, 50, 0) #起點
e = Point2d(wplane, 0, 50) #終點
normal = Normal3d(1, 0, 0, 0) #某條3D法線
p = ArcOfCircle(wrkpl, normal, o, s, e)
#直接命令
Slvs_MakeArcOfCircle(h, group, wrkpl, normal, center, start, end)
</pre>

`p`代表三個點與一條法線垂直（可選：或與一個平面平行）的不完全圓。

TYPES OF CONSTRAINTS
===================

`SLVS_C`

約束的類型，大部分的指令都會自動判斷狀況。

1. <kbd>3D</kbd> 此種約束只能用在3D或投影到平面上。

2. <kbd>2D</kbd> 此種約束只能用在平面上。

4. <kbd>Val</kbd> 此種約束必須設定額外的參考值。

輸入值最後端加入群組編號可以規定群組（預設值`Slvs_hGroup group = USE_DEFAULT_GROUP`）。

約束的直接命令：

<pre class="brush: python">
Slvs_MakeConstraint((h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB,  entityC,  entityD, other, other2)
</pre>

Point to Point Distance <kbd>Val</kbd>
----------------------------

`SLVS_C_PT_PT_DISTANCE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Point3d p1, Point3d p2)
</pre>

約束兩個`Point3d`的距離，非硬性，必要時會自動調整距離。

Projected Point Distance <kbd>Val</kbd>
----------------------------

`SLVS_C_PROJ_PT_DISTANCE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl,
</pre>

約束兩個`Point3d`的投影到`Workplane`距離，是硬性的約束。

Points Coincident
----------------------------

`SLVS_C_POINTS_COINCIDENT`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.coincident(Point3d p1, Point3d p2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.coincident(Workplane wrkpl, Point p1, Point p2)
</pre>

兩個點（`Point3d`或`Point2d`）的座標相等。（即：在彼此之上）

Point to Plane Distance <kbd>Val</kbd>
----------------------------

`SLVS_C_PT_PLANE_DISTANCE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Workplane wrkpl, Point3d p)
</pre>

從一個`Point3d`點到一個平面`Workplane`的距離，是硬性的約束。

距離值的正負會規定點在平面之上或之下。

Point to Line Distance  <kbd>Val</kbd>
----------------------------

`SLVS_C_PT_LINE_DISTANCE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Point3d p, LineSegment3d line)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment line)
</pre>

從一個`Point2d/3d`點到一條`LineSegment2d/3d`直線的距離，假如約束是投影的，會變成硬性約束。

距離值的正負會規定點在線段之上或之下。

若約束是套用在3D空間，距離則會變成非硬性約束。

Point in Plane
----------------------------

`SLVS_C_PT_IN_PLANE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Workplane wrkpl, Point3d p)
</pre>

一個`Point3d`點會被固定在一個`Workplane`平面上。

Point on Plane
----------------------------

`SLVS_C_PT_ON_LINE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Point3d p, LineSegment3d line)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Workplane wrkpl, Point p, LineSegment line)
</pre>

一個點`Point2d/3d`會被固定在一條`LineSegment2d/3d`直線上。

注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。

Equal Length of Lines
----------------------------

`SLVS_C_EQUAL_LENGTH_LINES`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal(Workplane wrkpl, LineSegment line1, LineSegment line2)
</pre>

兩條`LineSegment2d`線段的長度等長。

Ratio of Length <kbd>Val</kbd>
----------------------------

`SLVS_C_LENGTH_RATIO`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.ratio(double value, Workplane wrkpl, LineSegment line1, LineSegment line2)
</pre>

第一條`LineSegment2d`線段長度除以第二條`LineSegment2d`線段長度的比值。

Equal Length of Point to Lines
----------------------------

`SLVS_C_EQ_LEN_PT_LINE_D`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal(Workplane wrkpl, Point2d p, LineSegment line1, LineSegment line2)
</pre>

第一條`LineSegment2d`線段長度等於一個`Point2d`點到第二條`LineSegment2d`線的距離。

Equal Distance of Point to Lines
----------------------------

`SLVS_C_EQ_PT_LN_DISTANCES`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment line1, LineSegment line2)
</pre>

第一個`Point2d`點到第一條`LineSegment2d`線段長度等於第二個`Point2d`點到第二條`LineSegment2d`線段的距離。

Equal Angle
----------------------------

`SLVS_C_EQUAL_ANGLE`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal_angle(Workplane wrkpl, LineSegment line1, LineSegment line2, LineSegment line3, LineSegment line4)
</pre>

第一條`LineSegment2d`線段和第二條`LineSegment2d`線段的夾角等於第三條`LineSegment2d`線段和第四條`LineSegment2d`線段的夾角。

Equal Length of Line to Arc
----------------------------

`SLVS_C_EQUAL_LINE_ARC_LEN`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal(Workplane wrkpl, LineSegment line, Circular c)
</pre>

一條`LineSegment2d`線段長度和另一段`Circular`圓弧長度相等。

Symmetric
----------------------------

`SLVS_C_SYMMETRIC`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2)
</pre>

第一個`Point2d/3d`點會和第二個`Point2d/3d`點對稱於一個工作平面。

意味著兩個點到平面的距離都相等，而兩點的連線可以做為平面的法線。

Horizontal and Vertical
----------------------------

`SLVS_C_SYMMETRIC_HORIZ`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2)
</pre>

`SLVS_C_SYMMETRIC_VERT`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2)
</pre>

兩個輸入的`Point2d`點會互相對稱水平軸或垂直軸。

亦或規定一條線段的水平或垂直。

Diameter <kbd>Val</kbd>
----------------------------

`SLVS_C_DIAMETER`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.diameter(double diameter, Workplane wrkpl, Circular c)
</pre>

一段`Circular`圓或圓弧的周長或弧長。

Point on Circle
----------------------------

`SLVS_C_PT_ON_CIRCLE`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Workplane wrkpl, Point p, Circle circle)
</pre>

一個`Point2d`點會被固定在一個`Circle`圓或一段圓弧上。

Same Orientation
----------------------------

`SLVS_C_SAME_ORIENTATION`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.orientation(Normal3d nrml1, Normal3d nrml2)
</pre>

兩條`Normal3d`法線的方向相等。

Angle <kbd>Val</kbd>
----------------------------

`SLVS_C_ANGLE`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.angle(Workplane wrkpl, double value, LineSegment line1, LineSegment line2, bool other)
</pre>

兩條`LineSegment2d`線段的夾角，定義值單位為度。

公式如下（`A`和`B`為兩條線的向量）：

`(A dot B)/(|A||B|) = cos(valA)`

注意這裡的值定義比較不明確，無論正負90度都會是相同的結果。

所以必須使用`other`布林值來判斷正負。

Perpendicular
----------------------------

`SLVS_C_PERPENDICULAR`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.perpendicular(Workplane wrkpl, LineSegment line1, LineSegment line2, bool other
</pre>

源自約束`SLVS_C_ANGLE`。

這個約束是定義角度約束為90度的情況。

Parallel
----------------------------

`SLVS_C_PARALLEL`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.parallel(LineSegment3d line1, LineSegment3d line2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.parallel(Workplane wrkpl, LineSegment line1, LineSegment line2)
</pre>

兩條`LineSegment2d/3d`線段互相平行。

注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。

Arc and Line Tangent <kbd>Val</kbd>
----------------------------

`SLVS_C_ARC_LINE_TANGENT`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.tangent(Circular arc, LineSegment line, bool other)
</pre>

一段`Circular`圓或圓弧和一條`LineSegment2d`線段相切。

若布林值是`False`，則圓弧的切點會位於它的起點`s`；反之若為`True`，則會位於它的終點`e`。

Cubic and Line Tangent <kbd>Val</kbd>
----------------------------

`SLVS_C_CUBIC_LINE_TANGENT`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.tangent(Cubic c, LineSegment3d l, bool other)
</pre>

一條`Cubic`貝茲曲線和一條`LineSegment3d`線段相切。

若布林值是`False`，則貝茲曲線的切點會位於它的起點`w`；反之若為`True`，則會位於它的終點`k`。

Curve and Curve Tangent <kbd>Val</kbd>
----------------------------

`SLVS_C_CURVE_CURVE_TANGENT`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2)
</pre>

兩條`Cubic`曲線相切。

若布林值是`False`，則圓弧的切點會位於它的起點`s`，貝茲曲線的切點會位於它的起點`w`；反之若為`True`，則會位於它的終點`e`或`k`。

Equal Radius
----------------------------

`SLVS_C_EQUAL_RADIUS`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2)
</pre>

兩條`Circular`圓或圓弧的半徑相等。

Where Dragged
----------------------------

`SLVS_C_WHERE_DRAGGED`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.dragged(Point3d p)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.dragged(Workplane wrkpl, Point2d p)
</pre>

命令約束盡量固定這個`Point2d/3d`點，取而代之的是移動周遭的項目。

這個點被固定後移動量會較小。