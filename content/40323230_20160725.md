Title: 40323230紀錄 - SLVS資料庫函式
Date: 2016-07-29 12:00
Category: 2016bg2
Tags: Kmol, SWIG, Solvespace, CDemo, Python-Solvespace
Author: 40323230


`slvs`資料庫（`_slvs.pyd`或`_slvs.so`）轉成Python後的內容。

協助Python程式使用指令。

＊ <kbd>Tips</kbd> 的標籤是比較實用的註解。

*內容待勘誤*

*07/29更新*

<!-- PELICAN_END_SUMMARY -->

<h2>前言 :</h2>

`DOC.txt`是原本`CDemo.c`編譯成`CDemo.exe`前的使用解說。

裡面的名稱結構是使用C語言的方式，雖然`slvs.py`已經幫忙轉換了裡面的名稱，但是仍有些許函式名稱變化。

所以紀錄一下在Python中如何使用這些功能，並稍微翻譯其內容；而手冊中不清楚的地方也會補充。

預計讓這篇文章達到易使用和易理解的功能。

由於內容較多，尋找時，可以使用<kbd>Ctrl</kbd>+<kbd>F</kbd>搜尋關鍵字。

稱號下方是原始的命令代號，用於Solve Space圖形化介面的按鈕對應。

<h2>預期運行結果 :</h2>

若要使用SLVS資料庫，必須透過`slvs.py`介面來轉換。

在你的Python程式中使用以下指令：

<pre class="brush: python">
#導入slvs.py
from slvs import *

#導入Solid Python
#沒有使用就不需要導入
import solid

#創造你的系統，以及支援單位數量
#支援單位數量上限端看Python的記憶體數量
#預設單位數為50
sys = System(20)

...
</pre>

欲執行解題，Python必須使用下列命令：

<pre class="brush: python">
#執行解題
sys.solve()
#直接命令
Slvs_Solve(sys, g)

#結果回報的值如下
if (sys.result == SLVS_RESULT_OKAY):
    ...
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
</pre>

在執行解題程式後，會出現三種結果：

1. 所有約束都能滿足，會回傳`SLVS_RESULT_OKAY`，`param`中的內容也會更新。

2. 解題程式能夠證明約束條件互相牴觸，會傳回`SLVS_RESULT_INCONSISTENT`，相關約束的列表會產生在`failed`列表中。

3. 解題程式能夠證明約束條件沒有互相牴觸，但也沒有完全約束，會傳回`SLVS_RESULT_DIDNT_CONVERGE`，相關約束的列表會產生在`failed`列表中。

最後能調用以下值來檢查結果。

<pre class="brush: python">
#實體結果
#格式為%.3f
sys.get_param(0).val
</pre>

而過於嚴重的錯誤會回傳`SLVS_RESULT_TOO_MANY_UNKNOWNS`，必須檢查整個程式。

TYPES OF ENTITIES
===

`SLVS_E`

實體的類型，屬於物件的部分，Entity中還有一些子分類。

1. <kbd>Point</kbd> 此物件屬於點。

1. <kbd>LineSegment</kbd> 此物件屬於線段。

1. <kbd>Circular</kbd> 此物件屬於圓弧。

1. 沒有標籤的項目屬於 <kbd>Entity</kbd> 旗下的物件。

根據這些關係，在約束時必須判斷其分類以填入。

輸入值後方加入`, sys`，以傳入系統清單`sys`中；亦可用`sys.add_`加入以下支援的實體，而取出的編號取決於註冊的順序。

```
add_param( )
add_point2d( )
add_point3d( )
add_entity( )
```

取出時亦同（函數中加上編號就能指定）：

```
get_Point2d( )
get_Point3d( )
get_LineSegment2d( )
get_LineSegment3d( )
get_Normal3d( )
get_Distance( )
get_Workplane( )
get_Cubic( )
get_Circle( )
get_ArcOfCircle( )
```

Point
---

`SLVS_E_POINT_IN_3D`

<kbd>Entity</kbd> / <kbd>Point</kbd> / <kbd>Point3d</kbd>

使用指令：

<pre class="brush: python">
Point3d(Param x, Param y, Param z)
</pre>

代表空間中的輸入點。

`SLVS_E_POINT_IN_2D`

<kbd>Entity</kbd> / <kbd>Point</kbd> / <kbd>Point2d</kbd>

使用指令：

<pre class="brush: python">
Point2d(Workplane workplane, Param u, Param v)
</pre>

`p`代表工作平面上的輸入點。

Normal
---

`SLVS_E_NORMAL_IN_3D`

<kbd>Entity</kbd> / <kbd>Normal3d</kbd>

使用指令：

<pre class="brush: python">
Normal3d(Param qw, Param qx, Param qy, Param qz)
</pre>

`p`代表空間中的一條法線。

`SLVS_E_NORMAL_IN_2D`

<kbd>Entity</kbd> / <kbd>Normal3d</kbd> / <kbd>Normal2d</kbd>

使用指令：

<pre class="brush: python">
Normal3d(Workplane wrkpl)
</pre>

代表垂直工作平面的一條法線。

在SolveSpace中，法線是由一個3x3的旋轉矩陣從基本的坐標系到一個新的架構，是由單位四元數定義的。

可以想像這個四元數代表一個通過原點的平面。

這個平面跟三個向量相關：基礎向量`U`和`V`在平面上、而法線`N`則垂直它，相當於`[ U V N ]'`。

因此U、N、N都有單位長度，而他們都正交，所以：

```
U cross V = N
V cross N = U
N cross U = V
```

轉換函式`Slvs_Quaternion`提供了在`U`、`V`、`N`和單位四元數之間轉換。

單位四元數只有三個自由度，但是要在四個參數中指定。因此一個額外的約束產生了，就是：

`w^2 + x^2 + y^2 + z^2 = 1`

Make a Quaternion for a Work Plane <kbd>Tips</kbd>
---

要定義一個由`U[1 0 0]`向量（等同X軸）和`V[0 1 0]`向量（等同Y軸）組成的平面，是需要一條3D法線的。

若是不會計算四元數，可以利用下列函式達成：

<pre class="brush: python">
#函式轉換四元數
qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0)

#帶入3D法線的函式中
normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys)

#做成工作平面
o = Point3d(Param(0.0), Param(0.0), Param(0.0))
plane = Workplane(o, normal)
</pre>

這個公式在製作2D平面時非常方便。

以下是不同平面參考：

```
XY平面：[1 0 0], [0 1 0]
MakeQuaternion(1, 0, 0, 0, 1, 0)

YZ平面：[0 1 0], [0 0 1]
MakeQuaternion(0, 1, 0, 0, 0, 1)

XZ平面：[1 0 0], [0 0 1]
MakeQuaternion(1, 0, 0, 0, 0, 1)
```

Distance
---

`SLVS_E_DISTANCE`

<kbd>Entity</kbd> / <kbd>Distance</kbd>

使用指令：

<pre class="brush: python">
Distance(Workplane wrkpl, Param distance)
</pre>

`p`代表與工作平面平行的距離。

Work Plane
---

<kbd>Entity</kbd> / <kbd>Workplane</kbd>

`SLVS_E_WORKPLANE`

使用指令：

<pre class="brush: python">
Workplane(Point3d origin, Normal3d normal)
</pre>

`p`代表通過原點，與法線垂直的工作平面。

Line Segment
---

`SLVS_E_LINE_SEGMENT`

<kbd>Entity</kbd> / <kbd>LineSegment</kbd> / <kbd>LineSegment3d</kbd>

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
LineSegment3d(Point3d a, Point3d b)
</pre>

<kbd>Entity</kbd> / <kbd>LineSegment</kbd> / <kbd>LineSegment2d</kbd>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
LineSegment2d(Workplane wrkpl, Point2d a, Point2d b)
</pre>

在兩個`Point2d/3d`點之間繪出直線條。

`p`代表兩個點之間的連線。

Cubic
---

`SLVS_E_CUBIC`

<kbd>Entity</kbd> / <kbd>Cubic</kbd>

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3)
</pre>

四個點構成的貝茲曲線。

四個點的公式如下：

<pre class="brush: python">
#公式（t從0積分到1）
p(t) = P0*(1 - t)^3 + 3*P1*(1 - t)^2*t + 3*P2*(1 - t)*t^2 + P3*t^3
</pre>

Circle
---

<kbd>Entity</kbd> / <kbd>Circular</kbd> / <kbd>Circle</kbd>

`SLVS_E_CIRCLE`

使用指令：

<pre class="brush: python">
Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius)
</pre>

與一條`Normal3d`法線垂直，與一個`Workplane`平面平行，由`Point2d`圓心和`Distance`半徑構成的完整圓。

Arc of Circle
---

`SLVS_E_ARC_OF_CIRCLE`

<kbd>Circular</kbd> / <kbd>ArcOfCircle</kbd>

使用指令：

<pre class="brush: python">
ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end)
</pre>

與一條`Normal3d`法線垂直，與一個`Workplane`平面平行，由`Point2d`圓心和兩個`Point2d`點構成的三點弧。

TYPES OF CONSTRAINTS
===

`SLVS_C`

約束的類型，大部分的指令都會自動判斷狀況。

1. <kbd>3D</kbd> 此種約束只能用在3D或投影到平面上。

2. <kbd>2D</kbd> 此種約束只能用在平面上。

4. <kbd>Val</kbd> 此種約束必須設定額外的參考值。

輸入值最後端加入群組編號可以規定群組（預設值`Slvs_hGroup group = USE_DEFAULT_GROUP`）。

約束的直接命令：

<pre class="brush: python">
Slvs_MakeConstraint((h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB,  entityC,  entityD, other, other2)
</pre>

Distance <kbd>Val</kbd>
---

`SLVS_C_PT_PT_DISTANCE`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Point3d p1, Point3d p2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2)
</pre>

約束兩個`Point2d/3d`的距離。

`SLVS_C_PROJ_PT_DISTANCE`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl)
</pre>

約束兩個`Point3d`的投影到`Workplane`距離。

`SLVS_C_PT_PLANE_DISTANCE`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Workplane wrkpl, Point3d p)
</pre>

從一個`Point3d`點到一個平面`Workplane`的距離，是硬性的約束。

距離值的正負會規定點在平面之上或之下。

`SLVS_C_PT_LINE_DISTANCE`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Point3d p, LineSegment3d line)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment line)
</pre>

從一個`Point2d/3d`點到一條`LineSegment2d/3d`直線的距離，假如約束是投影的，會變成硬性約束。

距離值的正負會規定點在線段之上或之下。

若約束是套用在3D空間，距離則會變成非硬性約束。

Points Coincident
---

`SLVS_C_POINTS_COINCIDENT`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.coincident(Point3d p1, Point3d p2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.coincident(Workplane wrkpl, Point p1, Point p2)
</pre>

兩個點（`Point3d`或`Point2d`）的座標相等。（即：在彼此之上）

On
---

`SLVS_C_PT_IN_PLANE`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Workplane wrkpl, Point3d p)
</pre>

一個`Point3d`點會被固定在一個`Workplane`平面上。

`SLVS_C_PT_ON_LINE`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Point3d p, LineSegment3d line)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Workplane wrkpl, Point p, LineSegment line)
</pre>

一個點`Point2d/3d`會被固定在一條`LineSegment2d/3d`直線上。

注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。

`SLVS_C_PT_ON_CIRCLE`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.on(Workplane wrkpl, Point p, Circle circle)
</pre>

一個`Point2d`點會被固定在一個`Circle`圓或一段圓弧上。

Equal
---

`SLVS_C_EQUAL_LENGTH_LINES`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal(Workplane wrkpl, LineSegment line1, LineSegment line2)
</pre>

兩條`LineSegment2d`線段的長度等長。

`SLVS_C_EQ_LEN_PT_LINE_D`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal(Workplane wrkpl, Point2d p, LineSegment line1, LineSegment line2)
</pre>

第一條`LineSegment2d`線段長度等於一個`Point2d`點到第二條`LineSegment2d`線的距離。

`SLVS_C_EQ_PT_LN_DISTANCES`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment line1, LineSegment line2)
</pre>

第一個`Point2d`點到第一條`LineSegment2d`線段長度等於第二個`Point2d`點到第二條`LineSegment2d`線段的距離。

`SLVS_C_EQUAL_ANGLE`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal_angle(Workplane wrkpl, LineSegment line1, LineSegment line2, LineSegment line3, LineSegment line4)
</pre>

第一條`LineSegment2d`線段和第二條`LineSegment2d`線段的夾角等於第三條`LineSegment2d`線段和第四條`LineSegment2d`線段的夾角。

`SLVS_C_EQUAL_LINE_ARC_LEN`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal(Workplane wrkpl, LineSegment line, Circular c)
</pre>

一條`LineSegment2d`線段長度和另一段`Circular`圓弧長度相等。

`SLVS_C_EQUAL_RADIUS`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2)
</pre>

兩條`Circular`圓或圓弧的半徑相等。

Ratio of Length <kbd>Val</kbd>
---

`SLVS_C_LENGTH_RATIO`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.ratio(double value, Workplane wrkpl, LineSegment line1, LineSegment line2)
</pre>

第一條`LineSegment2d`線段長度除以第二條`LineSegment2d`線段長度的比值。

Symmetric
---

`SLVS_C_SYMMETRIC`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2)
</pre>

第一個`Point2d/3d`點會和第二個`Point2d/3d`點對稱於一個工作平面。

意味著兩個點到平面的距離都相等，而兩點的連線可以做為平面的法線。

`SLVS_C_SYMMETRIC_HORIZ`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2)
</pre>

`SLVS_C_SYMMETRIC_VERT`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2)
</pre>

兩個輸入的`Point2d`點會互相對稱水平軸或垂直軸。

亦或規定一條線段的水平或垂直。

`SLVS_C_SYMMETRIC_LINE`
---

<pre class="brush: python">
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment line)
</pre>

規定兩個`Point2d`點，對稱`LineSegment2d`線段。

Middle point
---

`SLVS_C_AT_MIDPOINT`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.midpoint(Point3d p, LineSegment3d line)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment line)
</pre>

讓一個`Point2d/3d`點位於一條線的中點。

Horizontal & Vertical
---

`SLVS_C_HORIZONTAL`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.horizontal(Workplane wrkpl, LineSegment line)
</pre>

`SLVS_C_VERTICAL`

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.vertical(Workplane wrkpl, LineSegment line)
</pre>

規定一條`LineSegment2d`直線水平或垂直。

Diameter <kbd>Val</kbd>
---

`SLVS_C_DIAMETER`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.diameter(double diameter, Workplane wrkpl, Circular c)
</pre>

一段`Circular`圓或圓弧的直徑。

Same Orientation
---

`SLVS_C_SAME_ORIENTATION`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.orientation(Normal3d nrml1, Normal3d nrml2)
</pre>

兩條`Normal3d`法線的方向相等。

Angle <kbd>Val</kbd>
---

`SLVS_C_ANGLE`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.angle(Workplane wrkpl, double value, LineSegment line1, LineSegment line2, bool other)
</pre>

兩條`LineSegment2d`線段的夾角，定義值單位為度。

公式如下（`A`和`B`為兩條線的向量）：

`(A dot B)/(|A||B|) = cos(valA)`

注意這裡的值定義比較不明確，無論正負90度都會是相同的結果。

所以必須使用`other`布林值來判斷正負。

`SLVS_C_PERPENDICULAR`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.perpendicular(Workplane wrkpl, LineSegment line1, LineSegment line2, bool other
</pre>

源自約束`SLVS_C_ANGLE`。

這個約束是定義角度約束為90度的情況。

Parallel
---

`SLVS_C_PARALLEL`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.parallel(LineSegment3d line1, LineSegment3d line2)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.parallel(Workplane wrkpl, LineSegment line1, LineSegment line2)
</pre>

兩條`LineSegment2d/3d`線段互相平行。

注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。

Tangent <kbd>Val</kbd>
---

`SLVS_C_ARC_LINE_TANGENT`
---

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.tangent(ArcOfCircle arc, LineSegment line, bool other)
</pre>

一段`Circular`圓弧和一條`LineSegment2d`線段相切。

若布林值是`False`，則圓弧的切點會位於它的起點`s`；反之若為`True`，則會位於它的終點`e`。

`SLVS_C_CUBIC_LINE_TANGENT`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.tangent(Cubic c, LineSegment3d l, bool other)
</pre>

一條`Cubic`貝茲曲線和一條`LineSegment3d`線段相切。

若布林值是`False`，則貝茲曲線的切點會位於它的起點`w`；反之若為`True`，則會位於它的終點`k`。

`SLVS_C_CURVE_CURVE_TANGENT`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2)
</pre>

兩條`Cubic`曲線相切。

若布林值是`False`，則圓弧的切點會位於它的起點`s`，貝茲曲線的切點會位於它的起點`w`；反之若為`True`，則會位於它的終點`e`或`k`。

Where Dragged
---

`SLVS_C_WHERE_DRAGGED`
---

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
Constraint.dragged(Point3d p)
</pre>

<kbd>2D</kbd> 使用指令：

<pre class="brush: python">
Constraint.dragged(Workplane wrkpl, Point2d p)
</pre>

永久鎖定這個`Point2d/3d`點的座標在目前計算的座標上，再也不會改變。

在2D平面上，會移除兩個自由度；在3D空間中，是三個自由度。

Set Dragged <kbd>Tips</kbd>
---

關於鎖定位置，另一個系統約束如下：

<pre class="brush: python">
sys.set_dragged(Point p)
</pre>

是命令約束盡量固定這個`Point2d/3d`點，取而代之的是移動周遭的項目。

這個點被固定後移動量會較小。

ADDITIONAL TYPES OF CONSTRAINTS
===

一些額外的約束條件，目前沒有對應實體項目可用。

Point and Face 
---

`SLVS_C_PT_FACE_DISTANCE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
#這個功能尚未建構
</pre>

Point on Face 
---

`SLVS_C_PT_ON_FACE`

<kbd>3D</kbd> 使用指令：

<pre class="brush: python">
#這個功能尚未建構
</pre>